/****************************
*                           *
*  Sha1 auxiliar functions  *
*                           *
****************************/


fn GETBIT(stack u8[12] aux, inline int bit_idx, inline int base_idx) -> inline u8 {

	inline u8 selectedBit;
	inline int byte_idx, total_idx;

	total_idx = bit_idx + base_idx;

	byte_idx = total_idx / 8;
	total_idx -= (total_idx / 8);

	selectedBit = aux[byte_idx];
	selectedBit >>= total_idx; 
	selectedBit &= 0x01;

	return selectedBit;	
}


fn GETBIT_u32(stack u32 x, inline int bit_idx, stack u8 t) -> stack u8 {

	stack u8[4] aux;
	stack u8 res;

	aux[u32 0] = ((x >> (bit_idx)) & 0x01);
	
	t = aux[3];

	return t;	
}


fn getBits(stack u8[12] array_r, stack u8[12] array_c, inline int i, inline int idx0, inline int idx1) -> stack u8, stack u8, stack u8 {

	stack u8 t0, t1, t2;
	//stack u32 word0, word1, word2;

	t0 = 0;
	t1 = 0;
	t2 = 0;

	//word0 = array_r[u32 idx0];

	//word1 = array_c[u32 idx1];
	//word2 = array_r[u32 idx1];


	//t = GETBIT_u32(word0, i, t);
	//t1 = GETBIT_u32(word1, i, t1);
	//t2 = GETBIT_u32(word2, i, t2);

	return t0, t1, t2;

}

fn GETBIT_EXTENDED(stack u8[32] aux, inline int bit_idx) -> inline u8 {

	inline u8 selectedBit;
	inline int byte_idx;

	byte_idx = bit_idx / 8;
	bit_idx = bit_idx - bit_idx / 8;

	selectedBit = aux[byte_idx];
	selectedBit >>= bit_idx; 
	selectedBit &= 0x01;

	return  selectedBit;	
}

fn SETBIT_u32(stack u8[12] x, inline int bit_idx, stack u8 bit, inline int idx) -> stack u8[12] {

	inline u8 a;
	inline int byte,bit;

	byte = bit_idx / 8;
	bit = bit_idx - (byte * 8);

	a = 1;
	a <<= bit;

	if (bit == 1){
		x[byte] = x[byte] | a;
	} else{
		a ^= 0xFF;
		x[byte] &= a; 
	}
	
	return x;
}

fn LEFTROTATE(stack u8[12] x, inline int n, stack u8[12] y) -> stack u8[12] {

	inline u32[1] aux;
	inline int i;

	i = 0;

	while(i < 4){
		aux[0] = x[u32 0]; // copy 4 bytes

		aux[0] = ((aux[0] << n) | (aux[0] >> (32- n)));

		y[i * 4] = aux[u8 0];
		y[i * 4 + 1] = aux[u8 1];
		y[i * 4 + 2] = aux[u8 2];
		y[i * 4 + 3] = aux[u8 3]; 

		i += 1;
	} 

	return y;
}

fn RIGHTSHIFT(stack u8[60] x, inline int i, stack u8[12] z, inline int pos_hHa) -> stack u8[12] {
	
	
	stack u32[1] aux;

	stack u32 num;

	aux[u8 0] = x[pos_hHa * 4];
	aux[u8 1] = x[pos_hHa * 4 + 1];
	aux[u8 2] = x[pos_hHa * 4 + 2];
	aux[u8 3] = x[pos_hHa * 4 + 3];

	num = aux[0];
	aux[0] = num >> i;

	z[0] = aux[u8 0];
	z[1] = aux[u8 1];
	z[2] = aux[u8 2];
	z[3] = aux[u8 3];

	aux[u8 0] = x[20 + pos_hHa * 4];
	aux[u8 1] = x[20 + pos_hHa * 4 + 1];
	aux[u8 2] = x[20 + pos_hHa * 4 + 2];
	aux[u8 3] = x[20 + pos_hHa * 4 + 3];

	num = aux[0];
	aux[0] = num >> i;

	z[4] = aux[u8 0];
	z[5] = aux[u8 1];
	z[6] = aux[u8 2];
	z[7] = aux[u8 3];

	aux[u8 0] = x[40 + pos_hHa * 4];
	aux[u8 1] = x[40 + pos_hHa * 4 + 1];
	aux[u8 2] = x[40 + pos_hHa * 4 + 2];
	aux[u8 3] = x[40 + pos_hHa * 4 + 3];
	
	num = aux[0];
	aux[0] = num >> i;
	
	z[8] = aux[u8 0];
	z[9] = aux[u8 1];
	z[10] = aux[u8 2];
	z[11] = aux[u8 3];

	return z;
}




fn mpc_words(stack u8[12] x, stack u8[12] y, stack u8[12] z, inline int i) -> stack u32, stack u32 {


	stack u32 a,b,c;
	stack u32 word_a,word_b;

	a = x[u32 i];
	b = y[u32 i];
	c = z[u32 i];

	word_a = a ^ c;
	word_b = b ^ c;

	return word_a, word_b;
}

fn mpc_xor(stack u8[12] x, stack u8[12] y, stack u8[12] z) -> stack u8[12] {
	
	inline int i;
	
	z[u32 0] = x[u32 0] ^ y[u32 0];
	z[u32 1] = x[u32 1] ^ y[u32 1];
	z[u32 2] = x[u32 2] ^ y[u32 2];
	z[u32 3] = x[u32 3] ^ y[u32 3];

	return z;
}

fn mpc_xor_w(stack u8[960] w, stack u8[12] y, stack u8[12] z, inline int pos_w) -> stack u8[12] {
	
	inline int i;

	i=0;

	while(i < 4){
		z[i] = w[pos_w + i] ^ y[i];
		z[4 + i] = w[320 + pos_w + i] ^ y[4 + i];
		z[8 + i] = w[640 + pos_w + i] ^ y[8 + i];

		i += 1;
	}

	return z;
}

fn mpc_xor_k(stack u8[4] k, stack u8[12] y, stack u8[12] z) -> stack u8[12] {
	
	inline int i;

	i=0;

	while(i < 4){
		z[i] = k[i] ^ y[i];
		z[4 + i] = k[i] ^ y[4 + i];
		z[8 + i] = k[i] ^ y[8 + i];

		i += 1;
	}

	return z;
}

fn mpc_xor_hHa(stack u8[60] hHa, stack u8[12] y, stack u8[12] z, inline int pos_hHa) -> stack u8[12] {
	
	inline int i;

	i=0;

	while(i < 4){
		z[i] = hHa[pos_hHa * 4 + i] ^ y[i];
		z[4 + i] = hHa[20 + pos_hHa * 4 + i] ^ y[4 + i];
		z[8 + i] = hHa[40 + pos_hHa * 4 + i] ^ y[8 + i];

		i += 1;
	}

	return z;
}

fn mpc_xor_three(stack u8[12] x, stack u8[12] y, stack u8[4] k,  inline int i) -> stack u32 {
	
	stack u32 aux_x, aux_y, aux_k; 

	aux_x = x[u32 i];
	aux_y = y[u32 i];
	aux_k = k[u32 i];

	aux_k = aux_x ^ aux_y ^ aux_k;

	x[u32 i] = aux_k;
	
	return aux_k;
}






fn mpc_ADD(stack u8[12] x, stack u8[12] y, stack u8[12] z, reg u64 randomness, inline int randCount, reg u64 views, inline int countY, inline int mpcRounds) -> stack u8[12], inline int, inline int, reg u64 {
	
	stack u8[12] c, r, aux, c_aux;
	inline int i, j;

	stack u8[3] a, b;

	stack u8 t, t0, t1, t2;

	stack u32 word, word_a, word_b, word0, word1;
	
	i = 0;

	while(i < 3){
		j = 0;

		while(j < 4){
			c[i*4+j] = 0;
			j += 1;
		}
		i += 1;
	}

	i = 0;

	while(i < 3){
		r[i * 4] = [randomness + i * 1472 * mpcRounds + randCount];
		r[i * 4 + 1] = [randomness + i * 1472 * mpcRounds + randCount + 1];
		r[i * 4 + 2] = [randomness + i * 1472 * mpcRounds + randCount + 2];
		r[i * 4 + 3] = [randomness + i * 1472 * mpcRounds + randCount + 3];

		i += 1;
	}

	randCount += 4;

	i = 0;
	
	while(i < 31){

		j = 0;

		while(j < 3){
			word_a, word_b = mpc_words(x, y, c, j);
			t = GETBIT_u32(word_a,i,t);
			t1 = GETBIT_u32(word_b,i,t1);
			a[j] = t;
			b[j] = t1;
			j += 1;
		}
				

		// Set first word
		
		t0, t1, t2 = getBits(r, c, i, 1, 0);
		
		t = ( t0 ^ (a[0] & b[1]) ^ (a[1] & b[0]) ) ^ (a[0]&b[0]) ^ t1  ^ t2;

		c = SETBIT_u32(c, i + 1, t, 0);
		

		// Set second word
		
		t0, t1, t2 = getBits(r, c, i, 2, 1);
		
		t = ( t0 ^ (a[1] & b[2]) ^ (a[2] & b[1]) ) ^ (a[1]&b[1]) ^ t1  ^ t2;

		c = SETBIT_u32(c, i + 1, t, 1);
		

		// Set third word
		
		t0, t1, t2 = getBits(r, c, i, 0, 2);
		
		t = ( t0 ^ (a[2]&b[0]) ^ (a[0]&b[2]) ) ^ (a[2]&b[2]) ^ t1  ^ t2;

		c = SETBIT_u32(c, i + 1, t, 2);

		i += 1;
		
	}
		
	i = 0;

	while(i < 3){

		z[i * 4] = x[i * 4] ^ y[i * 4] ^ c[i * 4];
		z[i * 4 + 1] = x[i * 4 + 1] ^ y[i * 4 + 1] ^ c[i * 4 + 1];
		z[i * 4 + 2] = x[i * 4 + 2] ^ y[i * 4 + 2] ^ c[i * 4 + 2];
		z[i * 4 + 3] = x[i * 4 + 3] ^ y[i * 4 + 3] ^ c[i * 4 + 3];

		(u8)[views + 3072 + i * 1480 * mpcRounds+ countY] = c[i * 4];
		(u8)[views + 3072 + i * 1460 * mpcRounds + countY + 1] = c[i * 4 + 1];
		(u8)[views + 3072 + i * 1460 * mpcRounds + countY + 2] = c[i * 4 + 2];
		(u8)[views + 3072 + i * 1460 * mpcRounds + countY + 3] = c[i * 4 + 3];

		i += 1;

	}

	countY += 4;

	return z, randCount, countY, views;
}

fn mpc_ADD_W(stack u8[960] w, stack u8[12] y, reg u64 randomness, inline int randCount, reg u64 views, inline int countY, inline int pos_w, inline int mpcRounds) -> stack u8[12], inline int, inline int, reg u64 {
	
	stack u8[12] c, r, aux, aux2;
	inline int i, j;

	reg u8 retrievedBit0, retrievedBit1;	

	reg u8[3] a, b;

	stack u8 t, t0, t1, t2;
	
	i = 0;

	while(i < 3){
		j = 0;
		while(j < 4){
			c[i*4+j] = 0;
			j += 1;
		}
		i += 1;
	}

	i = 0;

	while(i < 3){
		r[i * 4] = [randomness + i * 16 * mpcRounds + randCount];
		r[i * 4 + 1] = [randomness + i * 16 * mpcRounds + randCount + 1];
		r[i * 4 + 2] = [randomness + i * 16 * mpcRounds + randCount + 2];
		r[i * 4 + 3] = [randomness + i * 16 * mpcRounds + randCount + 3];

		i += 1;
	}

	randCount += 4;

	i += 1;

	while(i < 31){

		aux = mpc_xor_w(w, c, aux, pos_w);

		aux2 = mpc_xor(y, c, aux2);

		j = 0;

		while(j < 3){

			t = GETBIT(aux,i, j*32);
			a[j] = t;

			t = GETBIT(aux2,i, j*32);
			b[j] = t;

			j += 1;
		}


		/* Set first word */

		t0, t1, t2 = getBits(r, c, i, 1, 0);
		
		t = ( t0 ^ (a[0] & b[1]) ^ (a[1] & b[0]) ) ^ (a[0]&b[0]) ^ t1  ^ t2;

		c = SETBIT_u32(c, i + 1, t, 0);


		/* Set second word */

		t0, t1, t2 = getBits(r, c, i, 2, 1);
		
		t = ( t0 ^ (a[1] & b[2]) ^ (a[2] & b[1]) ) ^ (a[1]&b[1]) ^ t1  ^ t2;

		c = SETBIT_u32(c, i + 1, t, 1);
		

		/* Set third word */

		t0, t1, t2 = getBits(r, c, i, 0, 2);
		
		t = ( t0 ^ (a[2]&b[0]) ^ (a[0]&b[2]) ) ^ (a[2]&b[2]) ^ t1  ^ t2;

		c = SETBIT_u32(c, i + 1, t, 2);
		
		i += 1;
		
	}

	i = 0;

	while(i < 3){
		y[i * 4] = w[80 * i + pos_w * 4] ^ y[i * 4] ^ c[i * 4];
		y[i * 4 + 1] = w[80 * i + pos_w * 4 + 1] ^ y[i * 4 + 1] ^ c[i * 4 + 1];
		y[i * 4 + 2] = w[80 * i + pos_w * 4 + 2] ^ y[i * 4 + 2] ^ c[i * 4 + 2];
		y[i * 4 + 3] = w[80 * i + pos_w * 4 + 3] ^ y[i * 4 + 3] ^ c[i * 4 + 3];

		(u8)[views + 3072 + i * 1480 * mpcRounds + countY] = c[i * 4];
		(u8)[views + 3072 + i * 1480 * mpcRounds + countY + 1] = c[i * 4 + 1];
		(u8)[views + 3072 + i * 1480 * mpcRounds + countY + 2] = c[i * 4 + 2];
		(u8)[views + 3072 + i * 1480 * mpcRounds + countY + 3] = c[i * 4 + 3];

		i += 1;

	}

	countY += 4;

	return y, randCount, countY, views;
}

fn mpc_ADD_K(stack u8[12] x, stack u8[4] k, reg u64 randomness, inline int randCount, reg u64 views, inline int countY, inline int mpcRounds) -> stack u8[12], inline int, inline int, reg u64 {

	stack u8[12] c, r, aux, aux2;
	inline int i, j;

	inline u32 xor_aux;

	reg u8 retrievedBit0, retrievedBit1;

	reg u8[3] a, b;

	stack u8 t, t0, t1, t2;

	i = 0;

	while(i < 3){
		j = 0;
		while(j < 4){
			c[i*4+j] = 0;
			j += 1;
		}
		i += 1;
	}

	i = 0;

	while(i < 3){
		r[i * 4] = [randomness + i * 16 * mpcRounds + randCount];
		r[i * 4 + 1] = [randomness + i * 16 * mpcRounds + randCount + 1];
		r[i * 4 + 2] = [randomness + i * 16 * mpcRounds + randCount + 2];
		r[i * 4 + 3] = [randomness + i * 16 * mpcRounds + randCount + 3];

		i += 1;
	}

	randCount += 4;

	i  =0;
	
	while(i < 31){

		aux = mpc_xor(x, c, aux);
		aux2 = mpc_xor_k(k, c, aux2);


		j = 0;

		while(j < 3){

			t = GETBIT(aux,i, j*32);
			a[j] = t;

			t = GETBIT(aux2,i, j*32);
			b[j] = t;

			j += 1;
		}

		/* Set first word */

		t0, t1, t2 = getBits(r, c, i, 1, 0);
		
		t = ( t0 ^ (a[0] & b[1]) ^ (a[1] & b[0]) ) ^ (a[0]&b[0]) ^ t1  ^ t2;

		c = SETBIT_u32(c, i + 1, t, 0);


		/* Set second word */

		t0, t1, t2 = getBits(r, c, i, 2, 1);
		
		t = ( t0 ^ (a[1] & b[2]) ^ (a[2] & b[1]) ) ^ (a[1]&b[1]) ^ t1  ^ t2;

		c = SETBIT_u32(c, i + 1, t, 1);
		

		/* Set third word */

		t0, t1, t2 = getBits(r, c, i, 0, 2);
		
		t = ( t0 ^ (a[2]&b[0]) ^ (a[0]&b[2]) ) ^ (a[2]&b[2]) ^ t1  ^ t2;

		c = SETBIT_u32(c, i + 1, t, 2);

		i += 1;
		
	}

	i = 0;
	
	while(i < 3){
		
		xor_aux = mpc_xor_three(x,c,k,i);
		//x[u32 i] = xor_aux;
		
		(u8)[views + 3072 + i * 1480 * mpcRounds + countY] = c[i * 4];
		(u8)[views + 3072 + i * 1480 * mpcRounds + countY + 1] = c[i * 4 + 1];
		(u8)[views + 3072 + i * 1480 * mpcRounds + countY + 2] = c[i * 4 + 2];
		(u8)[views + 3072 + i * 1480 * mpcRounds + countY + 3] = c[i * 4 + 3];

		i += 1;

	}

	countY += 4;

	return x, randCount, countY, views;

}

fn mpc_ADD_hHa(stack u8[60] x, stack u8[12] y, stack u8[60] z, reg u64 randomness, inline int randCount, reg u64 views, inline int countY, inline int pos_hHa, inline int mpcRounds) -> stack u8[60], inline int, inline int, reg u64 {
	
	stack u8[12] c, r, aux, aux2;
	inline int i, j;

	reg u8 retrievedBit0, retrievedBit1;

	reg u8[3] a, b;

	stack u8 t, t0, t1, t2;
	
	i = 0;
	while(i < 3){
		j = 0;
		while(j < 4){
			c[i*4+j] = 0;
			j += 1;
		}
		i += 1;
	}

	i = 0;

	while(i < 3){
		r[i * 4] = [randomness + i * 16 * mpcRounds + randCount];
		r[i * 4 + 1] = [randomness + i * 16 * mpcRounds + randCount + 1];
		r[i * 4 + 2] = [randomness + i * 16 * mpcRounds + randCount + 2];
		r[i * 4 + 3] = [randomness + i * 16 * mpcRounds + randCount + 3];

		i += 1;
	}

	randCount += 4;

	i = 0;

	while(i < 31){

		aux = mpc_xor_hHa(x, c, aux, pos_hHa);
		aux2 = mpc_xor(y, c, aux2);
		
		j = 0;
		
		while(j < 3){

			t = GETBIT(aux,i, j*32);
			a[j] = t;

			t = GETBIT(aux2,i, j*32);
			b[j] = t;

			j += 1;
		}


		/* Set first word */

		t0, t1, t2 = getBits(r, c, i, 1, 0);
		
		t = ( t0 ^ (a[0] & b[1]) ^ (a[1] & b[0]) ) ^ (a[0]&b[0]) ^ t1  ^ t2;

		c = SETBIT_u32(c, i + 1, t, 0);


		/* Set second word */

		t0, t1, t2 = getBits(r, c, i, 2, 1);
		
		t = ( t0 ^ (a[1] & b[2]) ^ (a[2] & b[1]) ) ^ (a[1]&b[1]) ^ t1  ^ t2;

		c = SETBIT_u32(c, i + 1, t, 1);
		

		/* Set third word */

		t0, t1, t2 = getBits(r, c, i, 0, 2);
		
		t = ( t0 ^ (a[2]&b[0]) ^ (a[0]&b[2]) ) ^ (a[2]&b[2]) ^ t1  ^ t2;

		c = SETBIT_u32(c, i + 1, t, 2);

		i += 1;
	}

	i = 0;

	while(i < 3){

		z[20 * i + pos_hHa * 4] = x[20 * i + pos_hHa * 4] ^ y[i * 4] ^ c[i * 4];
		z[20 * i + pos_hHa * 4 + 1] = x[20 * i + pos_hHa * 4 + 1] ^ y[i * 4 + 1] ^ c[i * 4 + 1];
		z[20 * i + pos_hHa * 4 + 2] = x[20 * i + pos_hHa * 4 + 2] ^ y[i * 4 + 2] ^ c[i * 4 + 2];
		z[20 * i + pos_hHa * 4 + 3] = x[20 * i + pos_hHa * 4 + 3] ^ y[i * 4 + 3] ^ c[i * 4 + 3];

		(u8)[views + 3072 + i * 1480 * mpcRounds + countY] = c[i * 4];
		(u8)[views + 3072 + i * 1480 * mpcRounds + countY + 1] = c[i * 4 + 1];
		(u8)[views + 3072 + i * 1480 * mpcRounds + countY + 2] = c[i * 4 + 2];
		(u8)[views + 3072 + i * 1480 * mpcRounds + countY + 3] = c[i * 4 + 3];

		i += 1;

	}

	countY += 4;

	return z, randCount, countY, views;
}








fn mpc_AND(stack u8[12] x, stack u8[12] y, stack u8[12] z, reg u64 randomness, inline int randCount, reg u64 views, inline int countY, inline int mpcRounds) -> stack u8[12], inline int, inline int, stack u64 {

	stack u8[12] r;
	inline int i;

	i = 0;

	while(i < 3){
		r[i * 4] = [randomness + i * 16 * mpcRounds + randCount];
		r[i * 4 + 1] = [randomness + i * 16 * mpcRounds + randCount + 1];
		r[i * 4 + 2] = [randomness + i * 16 * mpcRounds + randCount + 2];
		r[i * 4 + 3] = [randomness + i * 16 * mpcRounds + randCount + 3];

		i += 1;
	}

	randCount += 4;

	// t[0] = (x[0] & y[1]) ^ (x[1] & y[0]) ^ (x[0] & y[0]) ^ r[0] ^ r[1];

	z[0] = (x[0] & y[4]) ^ (x[4] & y[0]) ^ (x[0] & y[0]) ^ r[0] ^ r[4];
	z[1] = (x[1] & y[5]) ^ (x[5] & y[1]) ^ (x[1] & y[1]) ^ r[1] ^ r[5];
	z[2] = (x[2] & y[6]) ^ (x[6] & y[2]) ^ (x[2] & y[2]) ^ r[2] ^ r[6];
	z[3] = (x[3] & y[7]) ^ (x[7] & y[3]) ^ (x[3] & y[3]) ^ r[3] ^ r[7];


	// t[1] = (x[1] & y[2]) ^ (x[2] & y[1]) ^ (x[1] & y[1]) ^ r[1] ^ r[2];

	z[4] = (x[4] & y[8])  ^ (x[8] & y[4])  ^ (x[4] & y[4]) ^ r[4] ^ r[8];
	z[5] = (x[5] & y[9])  ^ (x[9] & y[5])  ^ (x[5] & y[5]) ^ r[5] ^ r[9];
	z[6] = (x[6] & y[10]) ^ (x[10] & y[6]) ^ (x[6] & y[6]) ^ r[6] ^ r[10];
	z[7] = (x[7] & y[11]) ^ (x[11] & y[7]) ^ (x[7] & y[7]) ^ r[7] ^ r[11];


	// t[2] = (x[2] & y[0]) ^ (x[0] & y[2]) ^ (x[2] & y[2]) ^ r[2] ^ r[0];

	z[8]  = (x[8] & y[0])  ^ (x[0] & y[8])  ^ (x[8] & y[8])   ^ r[8] ^ r[0];
	z[9]  = (x[9] & y[1])  ^ (x[1] & y[9])  ^ (x[9] & y[9])   ^ r[9] ^ r[1];
	z[10] = (x[10] & y[2]) ^ (x[2] & y[10]) ^ (x[10] & y[10]) ^ r[10] ^ r[2];
	z[11] = (x[11] & y[3]) ^ (x[3] & y[11]) ^ (x[11] & y[11]) ^ r[11] ^ r[3];

	i = 0;

	while(i < 3){
		(u8)[views + i * 1480 * mpcRounds + countY] =  y[i * 4];
		(u8)[views + i * 1480 * mpcRounds + countY + 1] = y[i * 4 + 1];
		(u8)[views + i * 1480 * mpcRounds + countY + 2] = y[i * 4 + 2];
		(u8)[views + i * 1480 * mpcRounds + countY + 3] = y[i * 4 + 3];
		i += 1;
	}

	countY += 4;

	return z, randCount, countY, views;
}


fn mpc_MAJ(stack u8[12] a, stack u8[12] b, stack u8[12] c, stack u8[12] z, reg u64 randomness, inline int randCount, reg u64 views, inline int countY, inline int mpcRounds) -> stack u8[12], inline int, inline int, reg u64 {
	stack u8[12] t0, t1, aux;


	t0 = mpc_xor(a, b, t0);
	t1 = mpc_xor(a, c, t1);
	z, randCount, countY, views = mpc_AND(t0, t1, z, randomness, randCount, views, countY, mpcRounds);
	aux = z;
	z = mpc_xor(aux, a, z);

	return z, randCount, countY, views;
}

/*************
*            *
*  MPC Sha1  *
*            *
*************/

fn mpc_SHA1(stack u8[96] results, reg u64 inputs, inline int numBits, reg u64 randomness, reg u64 views, inline int countY, inline int mpcRounds) -> stack u8[96], reg u64, inline int {


	inline int chars, i, j, randCount, right_shift_aux;
	stack u8[192] chunks; // chunks[3][64]
	stack u8[960] w; // W[80][3];

	stack u8[12] temp, aux; // uint32_t temp[3];
	stack u8[12] t0;  // uint32_t t0[3];

	stack u8[12] a, b, c, d, e, f, aux;
	stack u8[4] k;
	reg u32[1] k_aux;

	stack u32[5] hA;
	stack u8[60] hHa, hHa_aux;

	hA[0] = 0x67452301;
	hA[1] = 0xEFCDAB89;
	hA[2] = 0x98BADCFE;
	hA[3] = 0x10325476;
	hA[4] = 0xC3D2E1F0;
	
	j = 0;
	
	while(j < 5){
		hHa[j * 4] = hA[u8 (j*4)];
		hHa[j * 4 + 1] = hA[u8 (j*4 + 1)];
		hHa[j * 4 + 2] = hA[u8 (j*4 + 2)];
		hHa[j * 4 + 3] = hA[u8 (j*4 + 3)];

		hHa[20 + j * 4] = hA[u8 (j*4)];
		hHa[20 + j * 4 + 1] = hA[u8 (j*4 + 1)];
		hHa[20 + j * 4 + 2] = hA[u8 (j*4 + 2)];
		hHa[20 + j * 4 + 3] = hA[u8 (j*4 + 3)];

		hHa[40 + j * 4] = hA[u8 (j*4)];
		hHa[40 + j * 4 + 1] = hA[u8 (j*4 + 1)];
		hHa[40 + j * 4 + 2] = hA[u8 (j*4 + 2)];
		hHa[40 + j * 4 + 3] = hA[u8 (j*4 + 3)];

		j += 1;
	}

	randCount = 0;

	chars = numBits >> 3;

	i= 0;
	
	while(i < 3){
		j = 0;
		while(j < 16){
			chunks[i*64 + j] = [inputs + 6144 + i*3*16 + i*16 + j]; // + 6144 to get the shares
			j += 1;
		}

		chunks[i*64 + chars] = 0x80;
		

		chunks[i*64 + 62] = numBits >> 8;
		chunks[i*64 + 63] = numBits;

		j = 0;

		while(j < 64){
			(u8)[views + i * 3 * 64 + j] = chunks[i*64 + j];
			j += 1;
		}

		j = 0;
		while(j < 16){
			w[i * 320 + j * 4] = (chunks[i * 64 + j * 4] << 24);
			w[i * 320 + j * 4 + 1] = (chunks[i * 64 + j * 4 + 1] << 16);
			w[i * 320 + j * 4 + 2] = (chunks[i * 64 + j * 4 + 2] << 8);
			w[i * 320 + j * 4 + 3] = chunks[i * 64 + j * 4 + 3];

			j += 1; 
		}
	}

	j = 16;
	
	while(j < 80){
		i = 0;
		while(i < 3){

			temp[0] = w[i * 320 + j * 4 - 12] ^ w[i * 320 + j * 4 - 40];
			temp[1] = w[i * 320 + j * 4 - 11] ^ w[i * 320 + j * 4 - 39];
			temp[2] = w[i * 320 + j * 4 - 10] ^ w[i * 320 + j * 4 - 38];
			temp[3] = w[i * 320 + j * 4 - 9]  ^ w[i * 320 + j * 4 - 37];

			temp[0] = temp[0] ^ w[i * 320 + j * 4 - 56];
			temp[1] = temp[1] ^ w[i * 320 + j * 4 - 55];
			temp[2] = temp[2] ^ w[i * 320 + j * 4 - 54];
			temp[3] = temp[3] ^ w[i * 320 + j * 4 - 53];

			temp[0] = temp[0] ^ w[i * 320 + j * 4 - 64];
			temp[1] = temp[1] ^ w[i * 320 + j * 4 - 63];
			temp[2] = temp[2] ^ w[i * 320 + j * 4 - 62];
			temp[3] = temp[3] ^ w[i * 320 + j * 4 - 61];

			aux = LEFTROTATE(temp,1,aux);
		
			w[i * 320 + j * 4] = aux[0];
			w[i * 320 + j * 4 + 1] = aux[1];
			w[i * 320 + j * 4 + 2] = aux[2];
			w[i * 320 + j * 4 + 3] = aux[3];

			i += 1;
		}
		j += 1;
	}

	i = 0;
	
	while(i < 3){

		// uint32_t a[3] = { hA[0],hA[0],hA[0] };
		a[i * 4] =  hA[u8 0];
		a[i * 4 + 1] = hA[u8 1];
		a[i * 4 + 2] = hA[u8 2];
		a[i * 4 + 3] = hA[u8 3]; 

		// uint32_t b[3] = { hA[1],hA[1],hA[1] };
		b[i * 4] =  hA[u8 5];
		b[i * 4 + 1] = hA[u8 6];
		b[i * 4 + 2] = hA[u8 7];
		b[i * 4 + 3] = hA[u8 8]; 

		// uint32_t c[3] = { hA[2],hA[2],hA[2] };
		c[i * 4] =  hA[u8 0];
		c[i * 4 + 1] = hA[u8 10];
		c[i * 4 + 2] = hA[u8 11];
		c[i * 4 + 3] = hA[u8 12]; 

		// uint32_t d[3] = { hA[3],hA[3],hA[3] };
		d[i * 4] =  hA[u8 13];
		d[i * 4 + 1] = hA[u8 14];
		d[i * 4 + 2] = hA[u8 15];
		d[i * 4 + 3] = hA[u8 16]; 

		// uint32_t e[3] = { hA[4],hA[4],hA[4] };
		e[i * 4] =  hA[u8 17];
		e[i * 4 + 1] = hA[u8 18];
		e[i * 4 + 2] = hA[u8 19];
		e[i * 4 + 3] = hA[u8 20]; 

		i += 1;
	}

	j = 0;
	
	while(j < 80){

		if(j <= 19){

			i = 0;
			
			while(i < 3){
				f[i * 4] = c[i * 4] ^ d[i * 4];
				f[i * 4 + 1] = c[i * 4 + 1] ^ d[i * 4 + 1];
				f[i * 4 + 2] = c[i * 4 + 2] ^ d[i * 4 + 2];
				f[i * 4 + 3] = c[i * 4 + 3] ^ d[i * 4 + 3];

				i += 1;
			}
			
			aux = f;
			f, randCount, countY, views = mpc_AND(b, aux, f, randomness, randCount, views, countY, mpcRounds);

			i = 0;
			
			while(i < 3){
				f[i * 4] = d[i * 4] ^ f[i * 4];
				f[i * 4 + 1] = d[i * 4 + 1] ^ f[i * 4 + 1];
				f[i * 4 + 2] = d[i * 4 + 2] ^ f[i * 4 + 2];
				f[i * 4 + 3] = d[i * 4 + 3] ^ f[i * 4 + 3];

				i += 1;
			}

			k_aux[0] = 0x5A827999;
			k[0] = k_aux[u8 0];
			k[1] = k_aux[u8 1];
			k[2] = k_aux[u8 2];
			k[3] = k_aux[u8 3];
		}
		if(j <= 39) {

			i = 0;

			while(i < 3){
				f[i * 4] = b[i * 4] ^ c[i * 4];
				f[i * 4 + 1] = b[i * 4 + 1] ^ c[i * 4 + 1];
				f[i * 4 + 2] = b[i * 4 + 2] ^ c[i * 4 + 2];
				f[i * 4 + 3] = b[i * 4 + 3] ^ c[i * 4 + 3];

				f[i * 4] = d[i * 4] ^ f[i * 4];
				f[i * 4 + 1] = d[i * 4 + 1] ^ f[i * 4 + 1];
				f[i * 4 + 2] = d[i * 4 + 2] ^ f[i * 4 + 2];
				f[i * 4 + 3] = d[i * 4 + 3] ^ f[i * 4 + 3];

				i += 1;
			}

			k_aux[0] = 0x6ED9EBA1;
			k[0] = k_aux[u8 0];
			k[1] = k_aux[u8 1];
			k[2] = k_aux[u8 2];
			k[3] = k_aux[u8 3];
		}
		if(j <= 59) {

			f, randCount, countY, views = mpc_MAJ(b,c,d,f,randomness, randCount, views, countY, mpcRounds);

			k_aux[0] = 0x8F1BBCDC;
			k[0] = k_aux[u8 0];
			k[1] = k_aux[u8 1];
			k[2] = k_aux[u8 2];
			k[3] = k_aux[u8 3];
		}
		else {
			i = 0;
			while(i < 3){
				f[i * 4] = b[i * 4] ^ c[i * 4];
				f[i * 4 + 1] = b[i * 4 + 1] ^ c[i * 4 + 1];
				f[i * 4 + 2] = b[i * 4 + 2] ^ c[i * 4 + 2];
				f[i * 4 + 3] = b[i * 4 + 3] ^ c[i * 4 + 3];

				f[i * 4] = d[i * 4] ^ f[i * 4];
				f[i * 4 + 1] = d[i * 4 + 1] ^ f[i * 4 + 1];
				f[i * 4 + 2] = d[i * 4 + 2] ^ f[i * 4 + 2];
				f[i * 4 + 3] = d[i * 4 + 3] ^ f[i * 4 + 3];

				i += 1;
			}
			k_aux[0] = 0xCA62C1D6;
			k[0] = k_aux[u8 0];
			k[1] = k_aux[u8 1];
			k[2] = k_aux[u8 2];
			k[3] = k_aux[u8 3];
		}

		
		temp = LEFTROTATE(a,5,temp);
		aux = temp;
		
		temp, randCount, countY, views = mpc_ADD(f, aux, temp, randomness, randCount, views, countY, mpcRounds);
		aux = temp;
		temp, randCount, countY, views = mpc_ADD(e, aux, temp, randomness, randCount, views, countY, mpcRounds);
		temp, randCount, countY, views = mpc_ADD_K(temp, k, randomness, randCount, views, countY, mpcRounds);
		temp, randCount, countY, views = mpc_ADD_W(w, temp, randomness, randCount, views, countY, i, mpcRounds);
		
		i = 0;

		while(i < 3){

			e[i * 4] = d[i * 4];
			e[i * 4 + 1] = d[i * 4 + 1];
			e[i * 4 + 2] = d[i * 4 + 2];
			e[i * 4 + 3] = d[i * 4 + 3];

			d[i * 4] = c[i * 4];
			d[i * 4 + 1] = c[i * 4 + 1];
			d[i * 4 + 2] = c[i * 4 + 2];
			d[i * 4 + 3] = c[i * 4 + 3];

			aux = c;
			c = LEFTROTATE(aux,30,c);

			b[i * 4] = a[i * 4];
			b[i * 4 + 1] = a[i * 4 + 1];
			b[i * 4 + 2] = a[i * 4 + 2];
			b[i * 4 + 3] = a[i * 4 + 3];

			a[i * 4] = temp[i * 4];
			a[i * 4 + 1] = temp[i * 4 + 1];
			a[i * 4 + 2] = temp[i * 4 + 2];
			a[i * 4 + 3] = temp[i * 4 + 3];

			i += 1;
		}
		
	}
	
	hHa_aux = hHa;
	hHa, randCount, countY, views = mpc_ADD_hHa(hHa_aux, a, hHa, randomness, randCount, views, countY, 0, mpcRounds);
	hHa_aux = hHa;
	hHa, randCount, countY, views = mpc_ADD_hHa(hHa_aux, b, hHa, randomness, randCount, views, countY, 1, mpcRounds);
	hHa_aux = hHa;
	hHa, randCount, countY, views = mpc_ADD_hHa(hHa_aux, c, hHa, randomness, randCount, views, countY, 2, mpcRounds);
	hHa_aux = hHa;
	hHa, randCount, countY, views = mpc_ADD_hHa(hHa_aux, d, hHa, randomness, randCount, views, countY, 3, mpcRounds);
	hHa_aux = hHa;
	hHa, randCount, countY, views = mpc_ADD_hHa(hHa_aux, e, hHa, randomness, randCount, views, countY, 4, mpcRounds);
	
	i = 0;
	
	while(i < 5){

		t0 = RIGHTSHIFT(hHa,24,t0,i);

		j = 0;
		while(j < 3){
			results[j * 32 + i * 4] = t0[j * 4];
			results[j * 32 + i * 4 + 1] = t0[j * 4 + 1];
			results[j * 32 + i * 4 + 2] = t0[j * 4 + 2];
			results[j * 32 + i * 4 + 3] = t0[j * 4 + 3];

			j += 1;
		}
		

		t0 = RIGHTSHIFT(hHa, 16, t0, i);
		
		j = 0;
		while(j < 3){
			results[j * 32 + (i + 1) * 4] = t0[j * 4];
			results[j * 32 + (i + 1) * 4 + 1] = t0[j * 4 + 1];
			results[j * 32 + (i + 1) * 4 + 2] = t0[j * 4 + 2];
			results[j * 32 + (i + 1) * 4 + 3] = t0[j * 4 + 3];

			j += 1;
		}

		t0 = RIGHTSHIFT(hHa, 8, t0, i);
		
		j = 0;
		while(j < 3){
			results[j * 32 + (i + 2) * 4] = t0[j * 4];
			results[j * 32 + (i + 2) * 4 + 1] = t0[j * 4 + 1];
			results[j * 32 + (i + 2) * 4 + 2] = t0[j * 4 + 2];
			results[j * 32 + (i + 2) * 4 + 3] = t0[j * 4 + 3];

			j += 1;
		}

		j = 0;
		
		while(j < 3){
			results[j * 32 + (i + 3) * 4] = hHa[j * 20 + i * 4];
			results[j * 32 + (i + 3) * 4 + 1] = hHa[j * 20 + i * 4 + 1];
			results[j * 32 + (i + 3) * 4 + 2] = hHa[j * 20 + i * 4 + 2];
			results[j * 32 + (i + 3) * 4 + 3] = hHa[j * 20 + i * 4 + 3];

			j += 1;
		}
	}
	

	return results, views, countY;
}

/***********************
*                      *
*  Commits & mpc_Sha1  *
*                      *
***********************/

fn commits(inline int numBits, reg u64 keys_shares, reg u64 randomness, reg u64 views, inline int countY, reg u64 a, inline int mpc_idx, inline int mpcRounds) -> reg u64, inline int, reg u64 {

	stack u8[96] hashes;
	
	stack u8[80] result1, result2, result3 ;

	inline int i, j;
	
	hashes, views, countY = mpc_SHA1(hashes, keys_shares, numBits, randomness, views, countY, mpcRounds);

	j = 0;
	while(j <  5){

		i = 0;
		while(i < 3){
			(u8)[views + 3072 + 1480 * mpcRounds * i + countY] = hashes[32 * i + j * 4];
			(u8)[views + 3072 + 1480 * mpcRounds * i + countY + 1] = hashes[32 * i + j * 4 + 1];
			(u8)[views + 3072 + 1480 * mpcRounds * i + countY + 2] = hashes[32 * i + j * 4 + 2];
			(u8)[views + 3072 + 1480 * mpcRounds * i + countY + 3] = hashes[32 * i + j * 4 + 3];

			i += 1;
		}

		countY += 4;
		j += 1;
	}

	j = 20;

	while(j>0){
		(u8)[a + 32 * mpc_idx + j] = (u8)[views + 3072 + countY-j];  
		(u8)[a + 32 + 32 * mpc_idx + j] = (u8)[views + 3072 + 1480 + countY-j];
		(u8)[a + 64 + 32 * mpc_idx + j] = (u8)[views + 3072 + 2960 + countY-j];

		j -= 1;
	}

	return views, countY, a;
}





/******************************
*                             *
*  SHA256 auxiliar functions  *
*                             *
******************************/


fn ROTLEFT(reg u32 a, inline int b) -> reg u32{
	reg u32 aux; 
	aux = ((a << b) | (a >> (32 - b)));
	return aux;
} 

fn ROTRIGHT(reg u32 a, inline int b) -> stack u32{
	stack u32 aux; 
	aux = ((a >> b) | (a << (32 - b)));
	return aux;
}


fn EP0(stack u8[4] x) -> reg u32{

	reg u32 aux, aux0, aux1, aux2;

	aux = x[u32 0];

	aux0 = ROTRIGHT(aux,2);
	aux1 = ROTRIGHT(aux,13);
	aux2 = ROTRIGHT(aux,22);

	aux0 ^= aux1 ^ aux2;

	return aux0;
}

fn EP1(stack u8[4] x) -> reg u32{

	reg u32 aux, aux0, aux1, aux2;

	aux = x[u32 0];

	aux0 = ROTRIGHT(aux,6);
	aux1 = ROTRIGHT(aux,11);
	aux2 = ROTRIGHT(aux,25);

	aux0 ^= aux1 ^ aux2;

	return aux0;
} 


fn SIG0(reg u32 x) -> reg u32 {

	reg u32 aux, aux0, aux1, aux2;

	aux0 = ROTRIGHT(x,7);
	aux1 = ROTRIGHT(x,18);
	aux2 = x >> 3;

	aux = aux0 ^ aux1 ^ aux2;

	return aux;
	
} 
fn SIG1(reg u32 x) -> reg u32{
	reg u32 aux, aux0, aux1;

	aux0 = ROTRIGHT(x,17);
	aux1 = ROTRIGHT(x,19);

	aux = aux0 ^ aux1 ^ (x >> 10);

	return aux;
}


fn CH(stack u8[4] x, stack u8[4] y, stack u8[4] z) -> reg u32{
	
	inline int i;
	reg u32 aux;

	aux = (x[u32 0] & y[u32 0]) ^((x[u32 0] ^ 0xFF) & z[u32 0]);

	return aux;
}

fn MAJ(stack u8[4] x, stack u8[4] y, stack u8[4] z) -> reg u32{
	inline int i;
	stack u32 aux;

	aux = (x[u32 i] & y[u32 i]) ^ (x[u32 i] & z[u32 i]) ^ (y[u32 i] & z[u32 i]);

	return aux;
}


fn initializeK(stack u32[64] k) -> stack u32[64]{
	k[0] = 0x428a2f98;
    k[1] = 0x71374491;
    k[2] = 0xb5c0fbcf;
    k[3] = 0xe9b5dba5;
    k[4] = 0x3956c25b;
    k[5] = 0x59f111f1;
    k[6] = 0x923f82a4;
    k[7] = 0xab1c5ed5;
    k[8] = 0xd807aa98;
    k[9] = 0x12835b01;
    k[10] = 0x243185be;
    k[11] = 0x550c7dc3;
    k[12] = 0x72be5d74;
    k[13] = 0x80deb1fe;
    k[14] = 0x9bdc06a7;
    k[15] = 0xc19bf174;
    k[16] = 0xe49b69c1;
    k[17] = 0xefbe4786;
    k[18] = 0x0fc19dc6;
    k[19] = 0x240ca1cc;
    k[20] = 0x2de92c6f;
    k[21] = 0x4a7484aa;
    k[22] = 0x5cb0a9dc;
    k[23] = 0x76f988da;
    k[24] = 0x983e5152;
    k[25] = 0xa831c66d;
    k[26] = 0xb00327c8;
    k[27] = 0xbf597fc7;
    k[28] = 0xc6e00bf3;
    k[29] = 0xd5a79147;
    k[30] = 0x06ca6351;
    k[31] = 0x14292967;
    k[32] = 0x27b70a85;
    k[33] = 0x2e1b2138;
    k[34] = 0x4d2c6dfc;
    k[35] = 0x53380d13;
    k[36] = 0x650a7354;
    k[37] = 0x766a0abb;
    k[38] = 0x81c2c92e;
    k[39] = 0x92722c85;
    k[40] = 0xa2bfe8a1;
    k[41] = 0xa81a664b;
    k[42] = 0xc24b8b70;
    k[43] = 0xc76c51a3;
    k[44] = 0xd192e819;
    k[45] = 0xd6990624;
    k[46] = 0xf40e3585;
    k[47] = 0x106aa070;
    k[48] = 0x19a4c116;
    k[49] = 0x1e376c08;
    k[50] = 0x2748774c;
    k[51] = 0x34b0bcb5;
    k[52] = 0x391c0cb3;
    k[53] = 0x4ed8aa4a;
    k[54] = 0x5b9cca4f;
    k[55] = 0x682e6ff3;
    k[56] = 0x748f82ee;
    k[57] = 0x78a5636f;
    k[58] = 0x84c87814;
    k[59] = 0x8cc70208;
    k[60] = 0x90befffa;
    k[61] = 0xa4506ceb;
    k[62] = 0xbef9a3f7;
    k[63] = 0xc67178f2;

    return k;
}

fn sha256_transform(stack u8[32] ctx_state, stack u8[64] ctx_data)
{
    stack u8[4] a, b, c, d, e, f, g, h, t1, t2;

    stack u8[256] m;

    reg u32 sig0, sig1, aux0, aux1;

    inline int i, j;

    stack u32[64] k;
    k = initializeK(k);

    j=0;

    i = 0;

    while(i < 16){

    	m[j] = (ctx_data[j]);
    	m[j + 1] = (ctx_data[j + 1]);
    	m[j + 2] = (ctx_data[j + 2]);
    	m[j + 3] = (ctx_data[j + 3]);
    	j += 4;

    	i += 1;

    }

    while( i < 64){
    	aux0 = m[u32 i - 15];
    	aux1 = m[u32 i - 2];

    	sig0 = SIG0(aux0);
    	sig1 = SIG1(aux1);
    	
    	m[i] = sig1 + m[i - 7] + sig0 + m[i - 16];

    	i += 1;
    } 

    i = 0;
    while(i < 4){
    	a[i] = ctx_state[i];
    	b[i] = ctx_state[4 + i];
    	c[i] = ctx_state[8 + i];
	    d[i] = ctx_state[12 + i];
	    e[i] = ctx_state[16 + i];
	    f[i] = ctx_state[20 + i];
	    g[i] = ctx_state[24 + i];
	    h[i] = ctx_state[28 + i];

	    i += 1;
    }
    
    i = 0;
    while(i < 64){

    	sig0 = EP1(e);
    	sig1 = CH(e,f,g);

    	t1[u32 0] = h[u32 0] + sig0 + sig1 + k[i] + m[u32 i];

    	sig0 = EP0(a);
    	sig1 = MAJ(a,b,c);

    	t2[u32 0] = sig0 + sig1;
        h = g;
        g = f;
        f = e;
        e[u32 0] = d[u32 0] + t1[u32 0];
        d = c;
        c = b;
        b = a;
        a[u32 0] = t1[u32 0] + t2[u32 0];

        i += 1;
    }

    i = 0;
    while(i < 4){
	    ctx_state[i] += a[i];
	    ctx_state[4 + i] += b[i];
	    ctx_state[8 + i] += c[i];
	    ctx_state[12 + i] += d[i];
	    ctx_state[16 + i] += e[i];
	    ctx_state[20 + i] += f[i];
	    ctx_state[24 + i] += g[i];
	    ctx_state[28 + i] += h[i];

	    i += 1;
	}
}

fn sha256_init(stack u8[32] ctx_state, stack u32 ctx_datalen, stack u64 ctx_bitlen) 
{
    ctx_datalen = 0;
    ctx_bitlen = 0;
    ctx_state[0] = 0x6a;
    ctx_state[1] = 0x09;
    ctx_state[2] = 0xe6;
    ctx_state[3] = 0x67;
    ctx_state[4] = 0xbb;
    ctx_state[5] = 0x67;
    ctx_state[6] = 0xae;
    ctx_state[7] = 0x85;
    ctx_state[8] = 0x3c;
    ctx_state[9] = 0x6e;
    ctx_state[10] = 0xf3;
    ctx_state[11] = 0x72;
    ctx_state[12] = 0xa5;
    ctx_state[13] = 0x4f;
    ctx_state[14] = 0xf5;
    ctx_state[15] = 0x3a;
    ctx_state[16] = 0x51;
    ctx_state[17] = 0x0e;
    ctx_state[18] = 0x52;
    ctx_state[19] = 0x7f;
    ctx_state[20] = 0x9b;
    ctx_state[21] = 0x05;
    ctx_state[22] = 0x68;
    ctx_state[23] = 0x8c;
    ctx_state[24] = 0x1f;
    ctx_state[25] = 0x83;
    ctx_state[26] = 0xd9;
    ctx_state[27] = 0xab;
    ctx_state[28] = 0x5b;
    ctx_state[29] = 0xe0;
    ctx_state[30] = 0xcd;
    ctx_state[31] = 0x19;

    //return ctx_state, ctx_datalen, ctx_bitlen;
}

fn sha256_update1(stack u8[32] ctx_state, stack u32 ctx_datalen, stack u64 ctx_bitlen, stack u8[16] data, inline int len) -> stack u32
{
    inline int i;
    stack u8[64] ctx_data;

    i = 0;
    while(i < len){

    	ctx_data[(int)ctx_datalen] = data[i];
    	ctx_datalen += 1;

    	if(ctx_datalen == 64){
    		sha256_transform(ctx_state, ctx_data);
    		ctx_bitlen += 512;
    		ctx_datalen = 0;
    	}

    	i += 1;
    }

    return ctx_datalen;
}

fn sha256_update2(stack u8[32] ctx_state, stack u32 ctx_datalen, stack u64 ctx_bitlen, stack u8[64] data, inline int len) -> stack u32
{
    inline int i;
    stack u8[64] ctx_data;

    i = 0;

    while(i < len){

    	ctx_data[(int)ctx_datalen] = data[i];
    	ctx_datalen += 1;

    	if(ctx_datalen == 64){
    		sha256_transform(ctx_state, ctx_data);
    		ctx_bitlen += 512;
    		ctx_datalen = 0;
    	}
    }
    return ctx_datalen;
}

fn sha256_update3(stack u8[32] ctx_state, stack u32 ctx_datalen, stack u64 ctx_bitlen, stack u8[370] data, inline int len) -> stack u32
{
    inline int i;
    stack u8[64] ctx_data;

    i = 0;

    while(i < len){

    	ctx_data[(int)ctx_datalen] = data[i];
    	ctx_datalen += 1;

    	if(ctx_datalen == 64){
    		sha256_transform(ctx_state, ctx_data);
    		ctx_bitlen += 512;
    		ctx_datalen = 0;
    	}
    }
    return ctx_datalen;
}

fn sha256_update4(stack u8[32] ctx_state, stack u32 ctx_datalen, stack u64 ctx_bitlen, stack u8[12] data, inline int len) -> stack u32
{
    inline int i;
    stack u8[64] ctx_data;

    i = 0;

    while( i < len){

    	ctx_data[(int)ctx_datalen] = data[i];
    	ctx_datalen += 1;

    	if(ctx_datalen == 64){
    		sha256_transform(ctx_state, ctx_data);
    		ctx_bitlen += 512;
    		ctx_datalen = 0;
    	}
    }
    return ctx_datalen;
}

fn sha256_final(stack u8[32] ctx_state, stack u32 ctx_datalen, stack u64 ctx_bitlen, reg u64 a, inline int round_idx, inline int player_idx, inline int mpcRounds)
{
    inline int i;
    stack u8[64] ctx_data;
    reg u32[2] datalen_aux;

    i = ctx_datalen;

    // Pad whatever data is left in the buffer.
    if (ctx_datalen < 56) {
        ctx_data[i] = 0x80;
        i += 1;
        while (i < 56){
            ctx_data[i] = 0x00;
            i += 1;
        }
    }
    else {
        ctx_data[i] = 0x80;
        i += 1;
        while (i < 64){
            ctx_data[i] = 0x00;
            i += 1;
        }
        sha256_transform(ctx_state, ctx_data);

        i = 0;

        while(i < 56){
        	ctx_data[i] = 0x00;
        	i += 1;
        }
    }

    // Append to the padding the total message's length in bits and transform.
    
    datalen_aux[0] = 0;
    datalen_aux[1] = ctx_datalen;
    ctx_bitlen += datalen_aux[u64 0] * 8;
    ctx_data[u64 7] = ctx_bitlen;
    
    sha256_transform(ctx_state, ctx_data);

    // Since this implementation uses little endian byte ordering and SHA uses big endian,
    // reverse all the bytes when copying the final state to the output hash.

    i = 0;

    while(i < 4){
        (u8)[a + 1536 + player_idx * 32 * mpcRounds + round_idx * 32 + i] = ctx_state[i] & 0xff;
        (u8)[a + 1536 + player_idx * 32 * mpcRounds + round_idx * 32 + i + 4]  = (ctx_state[i + 4]) & 0xff;
        (u8)[a + 1536 + player_idx * 32 * mpcRounds + round_idx * 32 + i + 8]  = (ctx_state[i + 8]) & 0xff;
        (u8)[a + 1536 + player_idx * 32 * mpcRounds + round_idx * 32 + i + 12] = (ctx_state[i + 12]) & 0xff;
        (u8)[a + 1536 + player_idx * 32 * mpcRounds + round_idx * 32 + i + 16] = (ctx_state[i + 16]) & 0xff;
        (u8)[a + 1536 + player_idx * 32 * mpcRounds + round_idx * 32 + i + 20] = (ctx_state[i + 20]) & 0xff;
        (u8)[a + 1536 + player_idx * 32 * mpcRounds + round_idx * 32 + i + 24] = (ctx_state[i + 24]) & 0xff;
        (u8)[a + 1536 + player_idx * 32 * mpcRounds + round_idx * 32 + i + 28] = (ctx_state[i + 28]) & 0xff;

        i += 1;
    }
}

/*****************
*                *
*   H - SHA256   *
*                *
*****************/


fn H(reg u64 keys_shares, reg u64 views, reg u64 rs, reg u64 a, inline int mpcRounds) -> reg u64 {

	inline int i, j, z;

	stack u32 ctx_datalen;
	stack u64 ctx_bitlen;
	stack u8[32] ctx_state;


	stack u8[16] keys_aux;
	stack u8[64] viewsX_aux;
	stack u8[370] viewsY_aux;
	stack u8[12] rs_aux;

	reg u8 data;
	reg u8 len;

	i = 0;

	while(i < mpcRounds){

		j = 0;

		while(j < 3){

			sha256_init(ctx_state, ctx_datalen, ctx_bitlen);
			
			z = 0;
			while(z < 16){
				keys_aux[z] = [keys_shares + j * 16 * mpcRounds + i * 16];

				viewsX_aux[z*4] = [views + j * 64 * mpcRounds + i * 64 + z * 4];
				viewsX_aux[z*4 + 1] = [views + j * 64 * mpcRounds + i * 64 + z * 4 + 1];
				viewsX_aux[z*4 + 2] = [views + j * 64 * mpcRounds + i * 64 + z * 4 + 2];
				viewsX_aux[z*4 + 3] = [views + j * 64 * mpcRounds + i * 64 + z * 4 + 3];

				if (z < 12){
					rs_aux[z] = [rs + j * 4 * mpcRounds + i * 12 + z];
				}

				z += 1;
			}

			z = 0; 

			while(z < 370){
				viewsY_aux[z] = [views + 3072 + j * 1480 * mpcRounds + i * 370 + z];

				z += 1;
			} 

			ctx_datalen = sha256_update1(ctx_state, ctx_datalen, ctx_bitlen, keys_aux, 16);
			ctx_datalen = sha256_update2(ctx_state, ctx_datalen, ctx_bitlen, viewsX_aux, 64);
			ctx_datalen = sha256_update3(ctx_state, ctx_datalen, ctx_bitlen, viewsY_aux, 370);
			ctx_datalen = sha256_update4(ctx_state, ctx_datalen, ctx_bitlen, rs_aux, 12);
			sha256_final(ctx_state, ctx_datalen, ctx_bitlen, a, i, j, mpcRounds);

			j += 1;
		}

		i += 1;
	}

	return a;
}

fn sha256_update5(stack u8[32] ctx_state, stack u8[64] ctx_data, stack u32 ctx_datalen, stack u64 ctx_bitlen, stack u8[32] data, inline int len) -> stack u8[32], stack u32, stack u64
{
    inline int i;

    i = 0;
    while(i < len){

    	ctx_data[(int)ctx_datalen] = data[i];
    	ctx_datalen += 1;

    	if(ctx_datalen == 64){
    		sha256_transform(ctx_state, ctx_data);
    		ctx_bitlen += 512;
    		ctx_datalen = 0;
    	}

    	i += 1;
    }

    return ctx_state, ctx_datalen, ctx_bitlen;
}

fn sha256_update6(stack u8[32] ctx_state, stack u8[64] ctx_data, stack u32 ctx_datalen, stack u64 ctx_bitlen, reg u64 data, inline int len) -> stack u8[32], stack u32, stack u64
{
    inline int i;

    i = 0;
    while(i < len){

    	ctx_data[(int)ctx_datalen] = (u8)[data + i];
    	ctx_datalen += 1;

    	if(ctx_datalen == 64){
    		sha256_transform(ctx_state, ctx_data);
    		ctx_bitlen += 512;
    		ctx_datalen = 0;
    	}

    	i += 1;
    }

    return ctx_state, ctx_datalen, ctx_bitlen;
}

fn sha256_update7(stack u8[32] ctx_state, stack u8[64] ctx_data, stack u32 ctx_datalen, stack u64 ctx_bitlen, reg u64 data, inline int len) -> stack u8[32], stack u32, stack u64
{
    inline int i;

    i = 0;
    while(i < len){

    	ctx_data[(int)ctx_datalen] = (u8)[data + 1536 + i];
    	ctx_datalen += 1;

    	if(ctx_datalen == 64){
    		sha256_transform(ctx_state, ctx_data);
    		ctx_bitlen += 512;
    		ctx_datalen = 0;
    	}

    	i += 1;
    }

    return ctx_state, ctx_datalen, ctx_bitlen;
}

fn sha256_final1(stack u8[32] ctx_state, stack u8[64] ctx_data, stack u32 ctx_datalen, stack u64 ctx_bitlen, stack u8[32] hash) -> stack u8[32]
{
    inline int i;

    reg u32[2] datalen_aux;

    i = ctx_datalen;

    // Pad whatever data is left in the buffer.
    if (ctx_datalen < 56) {
        ctx_data[i] = 0x80;
        i += 1;
        while (i < 56){
            ctx_data[i] = 0x00;
            i += 1;
        }
    }
    else {
        ctx_data[i] = 0x80;
        i += 1;
        while (i < 64){
            ctx_data[i] = 0x00;
            i += 1;
        }
        sha256_transform(ctx_state, ctx_data);
        i = 0;
        while(i < 56){
        	ctx_data[i] = 0x00;
        	i += 1;
        }
    }

    // Append to the padding the total message's length in bits and transform.
    
    datalen_aux[0] = 0;
    datalen_aux[1] = ctx_datalen;
    ctx_bitlen += datalen_aux[u64 0] * 8;
    ctx_data[u64 7] = ctx_bitlen;
    
    sha256_transform(ctx_state, ctx_data);

    // Since this implementation uses little endian byte ordering and SHA uses big endian,
    // reverse all the bytes when copying the final state to the output hash.

    i = 0;
    while(i < 4){
        hash[i] = ctx_state[i] & 0xff;
        hash[i + 4]  = (ctx_state[i + 4]) & 0xff;
        hash[i + 8]  = (ctx_state[i + 8]) & 0xff;
        hash[i + 12] = (ctx_state[i + 12]) & 0xff;
        hash[i + 16] = (ctx_state[i + 16]) & 0xff;
        hash[i + 20] = (ctx_state[i + 20]) & 0xff;
        hash[i + 24] = (ctx_state[i + 24]) & 0xff;
        hash[i + 28] = (ctx_state[i + 28]) & 0xff;

        i += 1;
    }

    return hash;
}


/*****************
*                *
*       H3       *
*                *
*****************/

fn H3(stack u8[32] y, reg u64 a, inline int s, stack u8[128] es) -> stack u8[128] {


	stack u8[32] hash; // unsigned char hash[SHA256_DIGEST_LENGTH];
	
	stack u8[64] ctx_data;
	stack u32 ctx_datalen;
	stack u64 ctx_bitlen;
	stack u8[32] ctx_state;

	inline int i, bitTracker;
	reg u8 b1, b2;


	sha256_init(ctx_state, ctx_datalen, ctx_bitlen);

	ctx_state, ctx_datalen, ctx_bitlen = sha256_update5(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, y, 20);

	ctx_state, ctx_datalen, ctx_bitlen = sha256_update6(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, a, 12288);

	ctx_state, ctx_datalen, ctx_bitlen = sha256_update7(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, a, 12288);

	hash = sha256_final1(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash);


	//Pick bits from hash
	i = 0;
	bitTracker = 0;
	while(i < s) {
		if(bitTracker >= 256) { //Generate new hash
			sha256_init(ctx_state, ctx_datalen, ctx_bitlen);
			ctx_state, ctx_datalen, ctx_bitlen = sha256_update5(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash, 32);
			hash = sha256_final1(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash);
			bitTracker = 0;
		}

		b1 = GETBIT_EXTENDED(hash, bitTracker);
		b2 = GETBIT_EXTENDED(hash, bitTracker);

		if(b1 == 0) {
			if(b2 == 0) {
				es[i] = 0;
				bitTracker += 2;
				i += 1;
			} else {
				es[i] = 1;
				bitTracker += 2;
				i += 1;
			}
		} else {
			if(b2 == 0) {
				es[i] = 2;
				bitTracker += 2;
				i += 1;
			} else {
				bitTracker += 2;
			}
		}
	}

	return es;
}


/*****************
*                *
*     Prove      *
*                *
*****************/

fn prove(stack u8[128] es, reg u64 keys_shares, reg u64 rs, reg u64 views, reg u64 zs, inline int mpcRounds) -> reg u64 {

	inline int i, j, player0, player1;

	i = 0;
	while(i < mpcRounds){

		player0 = es[i];
		player1 = (es[i] + 1) % 3;

		/* Copy both players keys */
		j = 0;
		while(j < 2){
			(u8)[zs + i * 391 + j] = [keys_shares + player0 * 2 * mpcRounds + i * 2 + j];
			(u8)[zs + i * 391 + 2 + j] = [keys_shares + player1 * 2 * mpcRounds + i * 2 + j];

			j += 1;
		}
		
		/* Copy player's 1 view */
		j = 0;
		while(j < 8){
			[zs + i * 391 + 4 + j] = [views + player0 * 8 * mpcRounds + i * 8 + j];
			j += 1;
		}

		j = 0;
		while(j < 185){
			[zs + i * 391 + 12 + j] = [views + 384 + player0 * 185 * mpcRounds + i * 185 + j];
			j += 1;
		}

		/* Copy player's 2 view */
		j = 0;
		while( j < 8){
			[zs + i * 391 + 197 + j] = [views + player1 *8 * mpcRounds + i * 8 + j];
			j += 1;
		}

		j = 0;
		while(j < 185){
			[zs + i * 391 + 205 + j] = [views + 384 + player1 * 185 * mpcRounds + i * 185 + j];
			j += 1;
		}

		j = 0;
		while(j < 4){

			//Passar como cópia de 64 bits

			(u8)[zs + i * 3128 + 3120 + j] = (u8)[rs + player0 * 4 * mpcRounds + i * 4 + j];
			(u8)[zs + i * 3128 + 3124 + j] = (u8)[rs + player1 * 4 * mpcRounds + i * 4 + j];

			j += 1;
		}

	}

	return zs;
}


/*********************************************************************
*                                                                    *
*     This ZKBoo version is running on 128 rounds. If you decide to  *
*   increase the number of rounds, please multiply the stack arrays  *
*   needed in it by the number of MPC rounds divided by 128.         *
*                                                                    *
*********************************************************************/


fn preparationZKBoo(reg u64 rs, reg u64 randomValues, reg u64 keys_shares, reg u64 zs, reg u64 views, reg u64 a){

	
	/****************************************/
	/*  Allocate space for ZKBoo variables  */
	/*                                      */
    /*	- Keys and key shares;              */
    /*	- Views and random value arrays;    */
    /*  - Tracking variables;               */
    /*  - Commit and challenge arrays;      */
    /*  - Proofs array;                     */
    /*                                      */
	/****************************************/



	stack u8[16] k0, k1, k2;

	inline int i, j, mpcRounds, numBytes, countY;

	stack u8[32] finalHash;
	stack u8[128] es;


	/**************************************/
	/*      Initialize ZKBoo values       */
	/**************************************/

	mpcRounds = 128;
	numBytes = 16;
	countY = 0;
	

	/************************/
	/*  Process MPC rounds  */
	/************************/

	i = 0;

	while(i <  mpcRounds){

		views, countY, a = commits( numBytes*8, keys_shares, randomValues, views, countY, a, i, mpcRounds);

		a = H(keys_shares, views, rs, a, mpcRounds);

		i += 1;

	}
	
	
	/************************/
	/*  Generate Challenge  */
	/************************/
	
	j = 0;
	while(j<32){
		finalHash[j] = (u8)[a + j] ^ (u8)[a + 4096 + j] ^ (u8)[a + 8192 + j];
		j += 1;
	}

	es = H3(finalHash, a, mpcRounds, es);                 // CHECKED
	

	/***********************/
	/*   Assemble proofs   */
	/***********************/

	zs = prove(es, keys_shares, rs, views, zs, mpcRounds);    // CHECKED
}


/***************************************************
*                                                  *
* This function receives arrays and values with    *
* random bytes used by the ZKBoo scheme.           *
*                                                  *
*	- Public Key                                   *
* 	- Keys_Shares( Keys[768], Shares[768] )        *
*	- Randomness                                   *
*   - Proofs                                       *
*	- Views( Views_x[3072], Views_y[71040] )       *
*	- A( A_yp[1536], A_h[1536] )                   *
*                                                  *
***************************************************/

export fn zkboo(reg u64 rs, reg u64 randomValues, reg u64 keys_shares, reg u64 proofs, reg u64 views, reg u64 a){

	preparationZKBoo(rs, randomValues, keys_shares, proofs, views, a);
}
