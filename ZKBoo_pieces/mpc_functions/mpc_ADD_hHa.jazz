
fn GETBIT(stack u8[12] aux, reg u8 bit_idx, stack u8 base_idx) -> stack u8 {

	inline u8 selectedBit;
	stack u8 byte_idx, total_idx;

	total_idx = bit_idx + base_idx;

	byte_idx = total_idx / 8;
	total_idx -= (total_idx / 8);

	selectedBit = aux[(int)byte_idx];
	selectedBit >>= total_idx; 
	selectedBit &= 0x01;

	return selectedBit;	
}


fn GETBIT_u32(stack u32 x, reg u8 bit_idx, reg u8 t) -> stack u8 {

	stack u8[4] aux;
	stack u8 res;

	aux[u32 0] = ((x >> (bit_idx)) & 0x01);
	
	t = aux[3];

	return t;	
}


fn getBits(stack u8[12] array_r, stack u8[12] array_c, reg u8 i, stack u8 idx0, stack u8 idx1) -> stack u8, stack u8, stack u8 {

	reg u8 t0, t1, t2;
	stack u32 word0, word1, word2;

	t0 = 0;
	t1 = 0;
	t2 = 0;

	word0 = array_r[u32 (int)idx0];
	word1 = array_c[u32 (int)idx1];
	word2 = array_r[u32 (int)idx1];


	t0 = GETBIT_u32(word0, i, t0);
	t1 = GETBIT_u32(word1, i, t1);
	t2 = GETBIT_u32(word2, i, t2);

	return t0, t1, t2;
}



fn SETBIT_u32(stack u8[12] x, stack u8 bit_idx, reg u8 bit, stack u8 idx) -> stack u8[12] {

	reg u32 a;
	reg u8 aux_bit;

	aux_bit = 1;

	bit &= aux_bit;

	a = 1;
	a <<= bit_idx;

	if (bit == 1){
		x[u32 (int)idx] = x[u32 (int)idx] | a;
	} else{
		a ^= 0xFF;
		x[u32 (int)idx] &= a; 
	}
	
	return x;
}


fn mpc_xor(stack u8[12] x, stack u8[12] y, stack u8[12] z) -> stack u8[12] {
	
	z[u32 0] = x[u32 0] ^ y[u32 0];
	z[u32 1] = x[u32 1] ^ y[u32 1];
	z[u32 2] = x[u32 2] ^ y[u32 2];

	return z;
}

fn mpc_xor_hHa(stack u8[60] hHa, stack u8[12] y, stack u8[12] z, reg u64 pos_hHa) -> stack u8[12] {
	
	reg u8 i;

	i=0;

	while(i < 4){
		z[(int)i] = hHa[(int)pos_hHa * 4 + (int)i] ^ y[(int)i];
		z[4 + (int)i] = hHa[20 + (int)pos_hHa * 4 + (int)i] ^ y[4 + (int)i];
		z[8 + (int)i] = hHa[40 + (int)pos_hHa * 4 + (int)i] ^ y[8 + (int)i];

		i += 1;
	}

	return z;
}


fn mpc_ADD_hHa(stack u8[60] x, stack u8[12] y, stack u8[60] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, reg u64 pos_hHa, inline int mpcRounds) -> stack u8[60], reg u64, reg u64, reg u64 {
	
	stack u8[12] c, r, aux, aux2;
	reg u8 i, j;
	stack u8 base_idx, bit_idx, idx0, idx1, player;

	reg u8[3] a, b;

	reg u8 t, t0, t1, t2;

	reg u64 pos_views, idx;
	
	i = 0;
	while(i < 3){
		j = 0;
		while(j < 4){
			c[(int)i*4+(int)j] = 0;
			j += 1;
		}
		i += 1;
	}

	i = 0;

	while(i < 3){
		r[(int)i * 4] = [randomness + (int)i * 16 * mpcRounds + randCount];
		r[(int)i * 4 + 1] = [randomness + (int)i * 16 * mpcRounds + randCount + 1];
		r[(int)i * 4 + 2] = [randomness + (int)i * 16 * mpcRounds + randCount + 2];
		r[(int)i * 4 + 3] = [randomness + (int)i * 16 * mpcRounds + randCount + 3];

		i += 1;
	}

	randCount += 4;

	i = 0;

	while(i < 31){

		bit_idx = i + 1;
		aux = mpc_xor_hHa(x, c, aux, pos_hHa);
		aux2 = mpc_xor(y, c, aux2);
		
		j = 0;
		
		while(j < 3){

			base_idx = j * 32;

			t = GETBIT(aux,i, base_idx);
			a[(int)j] = t;

			t = GETBIT(aux2,i, base_idx);
			b[(int)j] = t;

			j += 1;
		}


		/* Set first word */

		idx0 = 1;
		idx1 = 0;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = ( t0 ^ (a[0] & b[1]) ^ (a[1] & b[0]) ) ^ (a[0]&b[0]) ^ t1  ^ t2;

		player = 0;

		c = SETBIT_u32(c, bit_idx, t, player);


		/* Set second word */

		idx0 = 2;
		idx1 = 1;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = ( t0 ^ (a[1] & b[2]) ^ (a[2] & b[1]) ) ^ (a[1]&b[1]) ^ t1  ^ t2;

		player = 1;

		c = SETBIT_u32(c, bit_idx, t, player);
		

		/* Set third word */

		idx0 = 0;
		idx1 = 2;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = ( t0 ^ (a[2]&b[0]) ^ (a[0]&b[2]) ) ^ (a[2]&b[2]) ^ t1  ^ t2;

		player = 2;

		c = SETBIT_u32(c, bit_idx, t, player);

		i += 1;
	}

	idx = 0;

	while(idx < 3){

		z[20 * (int)i + (int)pos_hHa * 4] = x[20 * (int)i + (int)pos_hHa * 4] ^ y[(int)i * 4] ^ c[(int)i * 4];
		z[20 * (int)i + (int)pos_hHa * 4 + 1] = x[20 * (int)i + (int)pos_hHa * 4 + 1] ^ y[(int)i * 4 + 1] ^ c[(int)i * 4 + 1];
		z[20 * (int)i + (int)pos_hHa * 4 + 2] = x[20 * (int)i + (int)pos_hHa * 4 + 2] ^ y[(int)i * 4 + 2] ^ c[(int)i * 4 + 2];
		z[20 * (int)i + (int)pos_hHa * 4 + 3] = x[20 * (int)i + (int)pos_hHa * 4 + 3] ^ y[(int)i * 4 + 3] ^ c[(int)i * 4 + 3];


		pos_views = 768 + idx * 365 * mpcRounds + countY;

		(u32)[views + pos_views] = c[u32 (int)idx];

		idx += 1;

	}

	countY += 1;

	return z, randCount, countY, views;
}

export 
fn test(reg u64 views){

	stack u8[60] x, z;
	stack u8[12] y;
	reg u64 randomness, randCount, countY, pos_hHa;
	inline int mpcRounds;

	mpcRounds = 128;
	randomness = 0;
	randCount = 0;
	countY = 0;
	pos_hHa = 0;

	x, randCount, countY, views = mpc_ADD_hHa(z, y, x, randomness, randCount, views, countY, pos_hHa, mpcRounds);

}