
fn GETBIT_u32(reg u32 x, reg u8 bit_idx, reg u8 t) -> reg u8 {

	stack u8[4] aux;

	aux[u32 0] = ((x >> (bit_idx)) & 0x01);
	
	t = aux[3];

	return t;	
}


fn getBits(reg u8[12] array_r, reg u8[12] array_c, reg u8 i, reg u8 idx0, reg u8 idx1) -> reg u8,reg u8, reg u8 {

	reg u8 t0, t1, t2;
	reg u32 word0, word1, word2;

	t0 = 0;
	t1 = 0;
	t2 = 0;

	word0 = array_r[u32 (int)idx0];
	word1 = array_c[u32 (int)idx1];
	word2 = array_r[u32 (int)idx1];


	t0 = GETBIT_u32(word0, i, t0);
	t1 = GETBIT_u32(word1, i, t1);
	t2 = GETBIT_u32(word2, i, t2);

	return t0, t1, t2;
}

fn SETBIT_u32(reg u8[12] x, reg u8 bit_idx, reg u8 bit, reg u8 idx) -> reg u8[12] {

	reg u32 a;
	reg u32[1] aux;
	reg u8 bit_aux;

	bit_aux = 1;
	bit_aux &= bit;

	a = 1;
	a = a << bit_idx;
	
	if (bit_aux == 1){
		x[u32 (int)idx] |= a;
	} else{
		a ^= 0xFF;
		x[u32 (int)idx] &= a; 
	}
	
	return x;
}

fn mpc_words(reg u8[12] x, reg u8[12] y, reg u8[12] z, reg u8 i) -> reg u32, reg u32 {


	reg u32 a, b, c;
	reg u32 word_a, word_b;

	a = x[u32 (int)i];
	b = y[u32 (int)i];
	c = z[u32 (int)i];

	word_a = a ^ c;
	word_b = b ^ c;

	return word_a, word_b;
}



fn mpc_ADD(reg u8[12] x, reg u8[12] y, reg u8[12] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, reg u64 mpc_idx, reg u64 mpcRounds) -> reg u8[12], reg u64, reg u64, reg u64 {
	
	reg u8[12] c, r;
	reg u64 i, j;

	reg u8[3] a, b;

	reg u8 t, t0, t1, t2, idx0, idx1, bit_idx, player;

	reg u32 word, word_a, word_b, word0, word1;

	reg u64 pos_views, temp, temp_pos, two, storage_u64;

	reg u32[2] aux;


	two = 2;
	i = 0;

	while(i < 3){
		j = 0;

		while(j < 4){
			c[(int)i*4+(int)j] = 0;
			j += 1;
		}
		i += 1;
	}

	i = 0;
	
	while(i < 3){
		r[(int)i * 4] = [randomness + (int)i * 1472 * mpcRounds + randCount];
		r[(int)i * 4 + 1] = [randomness + (int)i * 1472 * mpcRounds + randCount + 1];
		r[(int)i * 4 + 2] = [randomness + (int)i * 1472 * mpcRounds + randCount + 2];
		r[(int)i * 4 + 3] = [randomness + (int)i * 1472 * mpcRounds + randCount + 3];

		i += 1;
	}
	

	randCount += 4;

	i = 0;
	
	while(i < 31){

		j = 0;
		bit_idx = i + 1;
		
		while(j < 3){
			word_a, word_b = mpc_words(x, y, c, j);
			t = GETBIT_u32(word_a,i,t);
			t1 = GETBIT_u32(word_b,i,t1);
			a[(int)j] = t;
			b[(int)j] = t1;
			j += 1;
		}
			

		// Set first word

		idx0 = 1;
		idx1 = 0;
		
		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = ( t0 ^ (a[0] & b[1]) ^ (a[1] & b[0]) ) ^ (a[0]&b[0]) ^ t1  ^ t2;


		player = 0;
		//c = SETBIT_u32(c, bit_idx, t, player);
		

		// Set second word
		
		idx0 = 2;
		idx1 = 1;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = ( t0 ^ (a[1] & b[2]) ^ (a[2] & b[1]) ) ^ (a[1]&b[1]) ^ t1  ^ t2;

		player = 1;
		//c = SETBIT_u32(c, bit_idx, t, player);
		

		// Set third word

		idx0 = 0;
		idx1 = 2;
		
		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = ( t0 ^ (a[2]&b[0]) ^ (a[0]&b[2]) ) ^ (a[2]&b[2]) ^ t1  ^ t2;

		player = 2;
		//c = SETBIT_u32(c, bit_idx, t, player);

		i += 1;
		
	}
	
		
	i = 0;
	temp_pos = mpc_idx * 185; // player's current view.y

	while(i < 3){

		z[(int)i * 4] = x[(int)i * 4] ^ y[(int)i * 4] ^ c[(int)i * 4];
		z[(int)i * 4 + 1] = x[(int)i * 4 + 1] ^ y[(int)i * 4 + 1] ^ c[(int)i * 4 + 1];
		z[(int)i * 4 + 2] = x[(int)i * 4 + 2] ^ y[(int)i * 4 + 2] ^ c[(int)i * 4 + 2];
		z[(int)i * 4 + 3] = x[(int)i * 4 + 3] ^ y[(int)i * 4 + 3] ^ c[(int)i * 4 + 3];

		pos_views = i * 185;			// Current player views.y
		pos_views *= mpcRounds;
		pos_views += temp_pos;
		pos_views += 3072;				// view.x of the 3 players times mpcRound 

		temp = countY;
		temp >>= 1;

		pos_views += temp;				// current pointer inside view.y

		temp = countY;
		temp = temp % two;


		if(temp == 0){
			
			aux[0] = c[u32 (int)i];

			storage_u64 = aux[u64 0];

		} else {
			
			aux[1] = c[u32 (int)i];

			storage_u64 = [views + (int)pos_views];

			storage_u64 ^= aux[u64 0];
			
		}

		[views + (int)pos_views] = storage_u64;

		i += 1;

	}
	
	countY += 1;

	return z, randCount, countY, views;
}


export 
fn test(reg u64 views){

	reg u8[12] x, y, z;
	reg u64 randomness, randCount, countY;
	reg u64 mpc_idx, mpcRounds;

	mpcRounds = 128;
	randomness = 0;
	randCount = 0;
	countY = 0;
	mpc_idx = 0;

	z, randCount, countY, views = mpc_ADD(x, y, z, randomness, randCount, views, countY, mpc_idx, mpcRounds);

}