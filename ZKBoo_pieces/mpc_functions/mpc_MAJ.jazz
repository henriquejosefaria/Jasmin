fn mpc_xor(reg u8[12] x, reg u8[12] y, reg u8[12] z) -> reg u8[12] {
	
	z[u32 0] = x[u32 0] ^ y[u32 0];
	z[u32 1] = x[u32 1] ^ y[u32 1];
	z[u32 2] = x[u32 2] ^ y[u32 2];

	return z;
}


fn mpc_AND(reg u8[12] x, reg u8[12] y, reg u8[12] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, reg u64 mpc_idx, reg u64 mpcRounds) -> reg u8[12], reg u64, reg u64, reg u64 {

	stack u8[12] r;
	reg u64 i, pos_randomness, pos_r, pos_views, temp_pos, temp, storage_u64, two;
	reg u32 temp0, temp1, temp2, z_aux;
	reg u32[2] aux;

	two = 2;

	i = 0;

	while(i < 3){

		pos_randomness = i * 16;
		pos_randomness *= mpcRounds;
		pos_randomness += randCount;

		pos_r = i * 4;

		r[(int)pos_r] = [randomness + (int)pos_randomness];
		r[(int)pos_r + 1] = [randomness + (int)pos_randomness + 1];
		r[(int)pos_r + 2] = [randomness + (int)pos_randomness + 2];
		r[(int)pos_r + 3] = [randomness + (int)pos_randomness + 3];

		i += 1;
	}

	randCount += 4;



	temp0 = x[u32 0];
	temp0 &= y[u32 1];

	temp1 = x[u32 1];
	temp1 &= y[u32 0];

	temp2 = x[u32 0];
	temp2 &= y[u32 0];
	
	temp0 ^= temp1;
	temp0 ^= temp2;

	temp1 = r[u32 0];
	temp2 = r[u32 1];

	temp0 ^= temp1;
	temp0 ^= temp2;

	z[u32 0] = temp0;


	temp0 = x[u32 1];
	temp0 &= y[u32 2];

	temp1 = x[u32 2];
	temp1 &= y[u32 1];

	temp2 = x[u32 1];
	temp2 &= y[u32 1];
	
	temp0 ^= temp1;
	temp0 ^= temp2;

	temp1 = r[u32 1];
	temp2 = r[u32 2];

	temp0 ^= temp1;
	temp0 ^= temp2;

	z[u32 1] = temp0;


	temp0 = x[u32 2];
	temp0 &= y[u32 0];

	temp1 = x[u32 0];
	temp1 &= y[u32 2];

	temp2 = x[u32 2];
	temp2 &= y[u32 2];
	
	temp0 ^= temp1;
	temp0 ^= temp2;

	temp1 = r[u32 2];
	temp2 = r[u32 0];

	temp0 ^= temp1;
	temp0 ^= temp2;

	z[u32 2] = temp0;


	i = 0;
	

	temp_pos = mpc_idx * 185; // player's current view.y

	while(i < 3){

		aux[0] = 0;
		aux[1] = 0;
		storage_u64 = 0;

		pos_views = i * mpcRounds;		// which player info do we need (player * mpcRounds * view.y_size)
		pos_views *= 185;				
		pos_views += 3072;				// view.x of the 3 players times mpcRounds
		pos_views += temp_pos;			// player's current view.y 

		temp = countY;
		temp >>= 1;

		pos_views += temp;				// current pointer inside view.y

		temp = countY;
		temp = temp % two;


		if(temp == 0){
			
			aux[0] = z[u32 (int)i];

			storage_u64 = aux[u64 0];

		} else {
			
			aux[1] = z[u32 (int)i];

			storage_u64 = [views + (int)pos_views];

			storage_u64 ^= aux[u64 0];
			
		}

		[views + (int)pos_views] = storage_u64;
		
		i += 1;
	}
	
	countY += 1;

	return z, randCount, countY, views;
}

fn mpc_MAJ(reg u8[12] a, reg u8[12] b, reg u8[12] c, reg u8[12] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, reg u64 mpc_idx, reg u64 mpcRounds) -> reg u8[12], reg u64, reg u64, reg u64 {
	
	reg u8[12] t0, t1, aux;


	t0 = mpc_xor(a, b, t0);
	t1 = mpc_xor(a, c, t1);
	z, randCount, countY, views = mpc_AND(t0, t1, z, randomness, randCount, views, countY, mpc_idx, mpcRounds);
	aux = z;
	z = mpc_xor(aux, a, z);

	return z, randCount, countY, views;
}

export 
fn test(reg u64 views){

	reg u8[12] a, b, c, z;
	reg u64 randomness, randCount, countY;
	reg u64 mpc_idx, mpcRounds;

	mpcRounds = 128;
	randomness = 0;
	randCount = 0;
	countY = 0;
	mpc_idx = 0;

	z, randCount, countY, views = mpc_MAJ(a, b, c, z, randomness, randCount, views, countY, mpc_idx, mpcRounds);

}
