
fn GETBIT(reg u8[12] aux, reg u8 bit_idx, stack u8 base_idx) -> reg u8 {

	reg u8 selectedBit;
	stack u8 byte_idx, total_idx;

	total_idx = bit_idx + base_idx;

	byte_idx = total_idx / 8;
	total_idx -= (total_idx / 8);

	selectedBit = aux[(int)byte_idx];
	selectedBit >>= total_idx; 
	selectedBit &= 0x01;

	return selectedBit;	
}

fn GETBIT_u32(reg u32 x, reg u8 bit_idx, reg u8 t) -> reg u8 {

	stack u8[4] aux;
	stack u8 res;

	aux[u32 0] = ((x >> (bit_idx)) & 0x01);
	
	t = aux[3];

	return t;	
}

fn getBits(reg u8[12] array_r, reg u8[12] array_c, reg u8 i, stack u8 idx0, stack u8 idx1) -> reg u8, reg u8, reg u8 {

	reg u8 t0, t1, t2;
	reg u32 word0, word1, word2;

	t0 = 0;
	t1 = 0;
	t2 = 0;

	word0 = array_r[u32 (int)idx0];
	word1 = array_c[u32 (int)idx1];
	word2 = array_r[u32 (int)idx1];


	t0 = GETBIT_u32(word0, i, t0);
	t1 = GETBIT_u32(word1, i, t1);
	t2 = GETBIT_u32(word2, i, t2);

	return t0, t1, t2;
}


fn SETBIT_u32(reg u8[12] x, stack u8 bit_idx, reg u8 bit, stack u8 idx) -> reg u8[12] {

	reg u32 a;
	reg u8 aux_bit;

	aux_bit = 1;

	bit &= aux_bit;

	a = 1;
	a <<= bit_idx;

	if (bit == 1){
		x[u32 (int)idx] = x[u32 (int)idx] | a;
	} else{
		a ^= 0xFF;
		x[u32 (int)idx] &= a; 
	}
	
	return x;
}

fn mpc_xor_k(reg u8[4] k, reg u8[12] y, reg u8[12] z) -> reg u8[12] {
	
	reg u8 i;

	i=0;

	while(i < 4){
		z[(int)i] = k[(int)i] ^ y[(int)i];
		z[4 + (int)i] = k[(int)i] ^ y[4 + (int)i];
		z[8 + (int)i] = k[(int)i] ^ y[8 + (int)i];

		i += 1;
	}

	return z;
}

fn mpc_xor(reg u8[12] x, reg u8[12] y, reg u8[12] z) -> reg u8[12] {
	
	z[u32 0] = x[u32 0] ^ y[u32 0];
	z[u32 1] = x[u32 1] ^ y[u32 1];
	z[u32 2] = x[u32 2] ^ y[u32 2];

	return z;
}

fn mpc_xor_three(reg u8[12] x, reg u8[12] y, reg u8[4] k,  reg u64 i) -> reg u8[12] {
	
	reg u32 aux_x, aux_y;
	stack u32 aux_k; 

	aux_x = x[u32 (int)i];
	aux_y = y[u32 (int)i];
	aux_k = k[u32 (int)i];

	aux_k = aux_x ^ aux_y ^ aux_k;

	x[u32 (int)i] = aux_k;
	
	return x;
}


fn mpc_ADD_K(reg u8[12] x, reg u8[4] k, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, inline int mpcRounds) -> reg u8[12], reg u64, reg u64, reg u64 {

	reg u8[12] c, r, aux, aux2;
	stack u8 bit_idx, base_idx, idx0, idx1, player;

	inline u32 xor_aux;

	reg u8[3] a, b;
	reg u8 i, j, t, t0, t1, t2;

	reg u64 pos_views, idx;

	i = 0;

	while(i < 3){
		j = 0;
		while(j < 4){
			c[(int)i*4+(int)j] = 0;
			j += 1;
		}
		i += 1;
	}

	i = 0;

	while(i < 3){
		r[(int)i * 4] = [randomness + (int)i * 16 * mpcRounds + randCount];
		r[(int)i * 4 + 1] = [randomness + (int)i * 16 * mpcRounds + randCount + 1];
		r[(int)i * 4 + 2] = [randomness + (int)i * 16 * mpcRounds + randCount + 2];
		r[(int)i * 4 + 3] = [randomness + (int)i * 16 * mpcRounds + randCount + 3];

		i += 1;
	}

	randCount += 4;

	i  =0;
	
	while(i < 31){

		bit_idx = i + 1;
		aux = mpc_xor(x, c, aux);
		aux2 = mpc_xor_k(k, c, aux2);


		j = 0;

		while(j < 3){

			base_idx = j * 32;

			t = GETBIT(aux,i, base_idx);
			a[(int)j] = t;

			t = GETBIT(aux2,i, base_idx);
			b[(int)j] = t;

			j += 1;
		}

		/* Set first word */

		idx0 = 1;
		idx1 = 0;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = ( t0 ^ (a[0] & b[1]) ^ (a[1] & b[0]) ) ^ (a[0]&b[0]) ^ t1  ^ t2;

		player = 0;

		c = SETBIT_u32(c, bit_idx, t, player);


		/* Set second word */

		idx0 = 2;
		idx1 = 1;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = ( t0 ^ (a[1] & b[2]) ^ (a[2] & b[1]) ) ^ (a[1]&b[1]) ^ t1  ^ t2;

		player = 1;

		c = SETBIT_u32(c, bit_idx, t, player);
		

		/* Set third word */

		idx0 = 0;
		idx1 = 2;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = ( t0 ^ (a[2]&b[0]) ^ (a[0]&b[2]) ) ^ (a[2]&b[2]) ^ t1  ^ t2;

		player = 2;

		c = SETBIT_u32(c, bit_idx, t, player);

		i += 1;
		
	}

	idx = 0;
	
	while(idx < 3){
		
		x = mpc_xor_three(x,c,k,idx);
		
		pos_views = 768 + idx * 365 * mpcRounds + countY;

		(u32)[views + pos_views] = c[u32 (int)idx];

		idx += 1;

	}

	countY += 1;

	return x, randCount, countY, views;

}

export 
fn test(reg u64 views){

	reg u8[12] x;
	reg u8[4] k;
	reg u64 randomness, randCount, countY;
	inline int mpcRounds;

	mpcRounds = 128;
	randomness = 0;
	randCount = 0;
	countY = 0;

	x, randCount, countY, views = mpc_ADD_K(x, k, randomness, randCount, views, countY, mpcRounds);

}