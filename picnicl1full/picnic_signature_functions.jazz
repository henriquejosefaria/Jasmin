

inline
fn global_getBit(reg u64 array, reg u64 bitNumber) -> reg u8 {
	
	reg u64 aux, tmp;
	reg u8 bit;

	aux = bitNumber;
	aux >>= 3;
	bit = (u8)[array + (int)aux];

	aux = bitNumber;
	aux &= 7;
	tmp = 7;
	tmp -= aux;
	while(tmp > 0){
		bit >>= 1;
		tmp -= 1;
	}

	bit &= 1;

	return bit;
}




export
fn xor_three(reg u64 player2, reg u64 privateKey, reg u64 player0, reg u64 player1, reg u64 bytes) {

	reg u64 i, j;
	reg u8 length;
	reg u32 t32;
	reg u8 t;

	length = (u8)[bytes + 0];
	
	i = 0;
	j = -4;
	while(i < length){
		j += 4;
		t32 = (u32)[privateKey + (int)j];
		t32 ^= (u32)[player0 + (int)j];
		t32 ^= (u32)[player1 + (int)j];

		(u32)[player2 + (int)j] = t32;
		i += 4;
		
	}
	
	while(j < length){
		t = (u8)[privateKey + (int)j];
		t ^= (u8)[player0 + (int)j];
		t ^= (u8)[player1 + (int)j];

		(u8)[player2 + (int)j] = t;
		j += 1;
	}
}

/*###############################################################
#                                                               #
#                          XOR_ARRAY                            # 
#                                                               #
###############################################################*/

export
fn xor_array(reg u64 out, reg u64 in1, reg u64 in2, reg u64 bytesLength) {

	reg u64 i;
	reg u32 t, length;

	length = (u32)[bytesLength + 0];
	length *= 4;

	i = 0;
	while(i < length){

		t = (u32)[in1 + (int)i];
		t ^= (u32)[in2 + (int)i];

		(u32)[out + (int)i] = t;

		i += 4;
	}
}

/*###############################################################
#                                                               #
#                           GET_BIT                             # 
#                                                               #
###############################################################*/


export
fn jazz_getBit(reg u64 array, reg u64 bitNumber, reg u64 out){

	reg u64 byte, bit, i;
	reg u8 chosenBit;
	stack u64 out_s;


	i = 8;
	bit = (u64)[bitNumber + 0];
	byte = bit;
	out_s = out;
	byte = byte / i;
	out = out_s;

	chosenBit = (u8)[array + (int)byte];

	byte = bit;
	byte = byte % i;
	byte -= 7;

	while(byte < 0){
		chosenBit >>= 1;
		byte += 1;
	}

	chosenBit &= 0x01;

	(u8)[out + 0] = chosenBit;
}


/*###############################################################
#                                                               #
#                           SET_BIT                             # 
#                                                               #
###############################################################*/

export
fn jazz_setBit(reg u64 array, reg u64 bitNumber, reg u64 val){

	reg u64 byte, bit, i, aux;
	reg u8 chosenBit, t;

	stack u64 val_s;

	byte = (u64)[bitNumber + 0];
	byte = byte >> 3;
	chosenBit = (u8)[array + (int)byte];

	i = 7;
	byte = (u64)[bitNumber + 0];
	byte &= 7;
	i -= byte; 
	byte = i;


	t = 1;
	while(i > 0){
		t <<= 1;
		i -= 1;
	}

	t ^= 0xff;
	chosenBit &= t;


	t = (u8)[val + 0];

	while(byte > 0){
		t <<= 1;
		byte -= 1;
	} 

	chosenBit |= t;

	byte = (u64)[bitNumber + 0];
	byte = byte >> 3;

	(u8)[array + (int) byte] = chosenBit;
}

/*###############################################################
#                                                               #
#                     GET_BIT_FROM_ARRAY                        # 
#                                                               #
###############################################################*/


export
fn getBitFromWordArray(reg u64 array, reg u64 bitNumber, reg u64 out){

	reg u64 byte, bit, i;
	reg u8 chosenBit;
	stack u64 out_s;


	
	bit = (u64)[bitNumber + 0];
	byte = bit;
	byte >>= 3;

	chosenBit = (u8)[array + (int)byte];

	i = 7;
	byte = bit;
	byte &= 7;
	i -= byte;

	while(i > 0){
		chosenBit >>= 1;
		i -= 1;
	}

	chosenBit &= 1;

	(u8)[out + 0] = chosenBit;
}


inline
fn jazz_getBitFromWordArray(reg u64 array, reg u64 bitNumber) -> reg u8 {

	reg u64 byte, i;
	reg u8 chosenBit;

	byte = bitNumber;
	byte >>= 3;

	chosenBit = (u8)[array + (int)byte];
	
	byte = bitNumber;
	byte &= 7;
	i = 7;
	i -= byte;

	while(i > 0){
		chosenBit >>= 1;
		i -= 1;
	}

	chosenBit &= 1;

	return chosenBit;
}


inline
fn jazz_my_setBit(reg u64 array, reg u64 bitNumber, reg u32 val) {

	reg u64 byte, bit, i;
	reg u8 chosenBit, t;

	byte = bitNumber;
	byte = byte >> 3;
	chosenBit = (u8)[array + (int)byte];

	i = 7;
	byte = bitNumber;
	byte &= 7;
	i -= byte; 
	byte = i;

	t = 1;
	while(i > 0){
		t <<= 1;
		i -= 1;
	}

	t ^= 0xff;
	chosenBit &= t;

	t = val;

	while(byte > 0){
		t <<= 1;
		byte -= 1;
	}

	chosenBit |= t;

	byte = bitNumber;
	byte >>= 3;
	(u8)[array + (int)byte] = chosenBit;

}

inline
fn parity32(reg u32 x) -> reg u32{

	reg u32 y, y1;

	//y = x ^ (x >> 1);

	y = x;
	y1 = x;
	y1 >>= 1;
	y ^= y1;


	// y ^= (y >> 2);
	y1 = y;
	y1 >>= 2;
	y ^= y1;


	//y ^= (y >> 4);
	y1 = y;
	y1 >>= 4;
	y ^= y1;

	// y ^= (y >> 8);
	y1 = y;
	y1 >>= 8;
	y ^= y1;

	// y ^= (y >> 16);
	y1 = y;
	y1 >>= 16;
	y ^= y1;

	return y;

}

/*###############################################################
#                                                               #
#                         MATRIX_MUL                            # 
#                                                               #
###############################################################*/


export 
fn jazz_matrix_mul(reg u64 output, reg u64 state, reg u64 matrix, reg u64 stateSizeBits_s, reg u64 stateSizeWords_s, reg u64 wholeWords_s){

	reg u64 i, j, index, aux;
	reg u64 stateSizeBits, stateSizeWords, wholeWords;
	reg u32 prod, prod1, prod2, tmp;

	reg u8 bit, bit_aux;

	stack u8[4] tmp_aux;
	stack u32[1] tmp_aux2;

	stateSizeWords = [stateSizeWords_s + 0];
	stateSizeBits = [stateSizeBits_s + 0];
	wholeWords = [wholeWords_s + 0];
	wholeWords *= 4;                           // is used as u32

	aux = 0;
	i=0;
	while(i < stateSizeBits){

		prod = 0;
		j = 0;
		while(j < wholeWords){

			// index = i * params->stateSizeWords + j;

			index = i;			
			index *= stateSizeWords;
			index *= 4;
			index += j;
			
			prod1 = (u32)[state + (int)j];
			prod2 = (u32)[matrix + (int)index];
			prod1 &= prod2;
			prod ^= prod1;

			j += 4;
		}
		
		
		j = [wholeWords_s + 0];
		j *= 32;
		while(j < stateSizeBits){
			index = i;
			index *= stateSizeWords;
			index *= 32;
			index += j;
			
			bit = jazz_getBitFromWordArray(state, j);
			bit_aux = jazz_getBitFromWordArray(matrix, index);
			bit &= bit_aux;

			tmp_aux2[u8 3] = bit; 
			prod ^= tmp_aux2[0];

			j += 1;
		}
		
		tmp = parity32(prod);
		
		// this operation is out of the function parity32() cause it caused the function
		// to have weird values; Fixed when the operation was placed outside the function!! 
		tmp &= 1;
		jazz_my_setBit(output, i, tmp);	

		aux += 4;
		i += 1;
	}
}




inline
fn inline_setBit(reg u64 array, reg u64 bitNumber, reg u8 val){

	reg u64 byte, bit, i, aux;
	reg u8 chosenBit, t;

	stack u64 val_s;

	byte = bitNumber;
	byte = byte >> 3;
	chosenBit = (u8)[array + (int)byte];

	i = 7;
	byte = bitNumber;
	byte &= 7;
	i -= byte; 
	byte = i;


	t = 1;
	while(i > 0){
		t <<= 1;
		i -= 1;
	}

	t ^= 0xff;
	chosenBit &= t;


	t = val;

	while(byte > 0){
		t <<= 1;
		byte -= 1;
	} 

	chosenBit |= t;

	byte = bitNumber;
	byte = byte >> 3;

	(u8)[array + (int) byte] = chosenBit;
}

inline
fn my_setBits(reg u64 state, reg u64 bitNumber, reg u8 a_s, reg u8 b_s, reg u8 c_s){

	reg u8 a, b, c, t0, t1, t2, i;
	reg u64 aux;

	a = a_s;
	b = b_s;
	c = c_s;


	// a ^ (b & c);
	t0 = a;
	t1 = b;
	t1 &= c;
	t0 ^= t1;

	aux = bitNumber;

	inline_setBit(state, aux, t0);


	// a ^ b ^ (a & c);
	t0 = a;
	t0 ^= b;
	t1 = a;
	t1 &= c;
	t0 ^= t1;

	aux -= 1;

	inline_setBit(state, aux, t0);


	// a ^ b ^ c ^ (a & b);
	t0 = a;
	t0 ^= b;
	t0 ^= c;
	t1 = a;
	t1 &= b;
	t0 ^= t1;


	aux -= 1;

	inline_setBit(state, aux, t0);	
}

inline
fn my_getBits(reg u64 state, reg u64 bitNumber) -> reg u8, reg u8, reg u8{


	reg u8 a1, b1, c1;
	reg u64 aux, tmp;

	aux = bitNumber;
	aux >>= 3;
	a1 = (u8)[state + (int)aux];

	aux = bitNumber;
	aux &= 7;
	tmp = 7;
	tmp -= aux;
	while(tmp > 0){
		a1 >>= 1;
		tmp -= 1;
	}

	a1 &= 1;


	aux = bitNumber;
	aux -= 1;
	aux >>= 3;
	b1 = (u8)[state + (int)aux];

	aux = bitNumber;
	aux -= 1;
	aux &= 7;
	tmp = 7;
	tmp -= aux;
	while(tmp > 0){
		b1 >>= 1;
		tmp -= 1;
	}

	b1 &= 1;

	
	aux = bitNumber;
	aux -= 2;
	aux >>= 3;
	c1 = (u8)[state + (int)aux];

	aux = bitNumber;
	aux -= 2;
	aux &= 7;
	tmp = 7;
	tmp -= aux;
	while(tmp > 0){
		c1 >>= 1;
		tmp -= 1;
	}

	c1 &= 1;
	
	return a1, b1, c1;
}

/*###############################################################
#                                                               #
#                       SUBSTITUTION                            # 
#                                                               #
###############################################################*/

export
fn jazz_substitution(reg u64 state, reg u64 boxes){

	reg u64 i, bitNumber, nBoxes;
	reg u8 a, b, c;

	nBoxes = [boxes + 0];
	nBoxes *= 3;

	i=0;

	while(i < nBoxes){

		bitNumber = i;
		bitNumber += 2;

		a,b,c = my_getBits(state, bitNumber);

		bitNumber = i;
		bitNumber += 2;

		my_setBits(state, bitNumber, a, b, c);
		
		i += 3;
	}
}







/*#################################################################################################
#                                                                                                 #
#                                         MPC FUNCTIONS                                           # 
#                                                                                                 #
#################################################################################################*/





/*###############################################################
#                                                               #
#                      MPC_AND_GET_BIT                          # 
#                                                               #
###############################################################*/


export
fn jazz_and_getBit(reg u64 rand0, reg u64 rand1, reg u64 rand2, reg u64 randPos, reg u64 out){

	reg u64 bitNumber;
	reg u8 a, b, c;

	bitNumber = [randPos + 0];

	a = global_getBit(rand0, bitNumber);
	b = global_getBit(rand1, bitNumber);
	c = global_getBit(rand2, bitNumber);

	(u8)[out + 0] = a;
	(u8)[out + 1] = b;
	(u8)[out + 2] = c;	
}


/*
export
fn jazz_and_getBit(reg u64 rand0, reg u64 rand1, reg u64 rand2, reg u64 randPos, reg u64 out){

	reg u64 bitNumber, byte, rest, tmp;
	reg u8 bit0, bit1, bit2;

	bitNumber = [randPos + 0];

	byte = bitNumber;
	byte >>= 3;
	bit0 = (u8)[rand0 + (int)byte];

	rest = bitNumber;
	rest &= 7;
	tmp = 7;
	tmp -= rest;

	rest = tmp;

	while(tmp > 0){
		bit0 >>= 1;
		tmp -= 1;
	}

	bit0 &= 1;

	bit1 = (u8)[rand1 + (int)byte];

	tmp = rest;
	while(tmp > 0){
		bit1 >>= 1;
		tmp -= 1;
	}

	bit2 = (u8)[rand2 + (int)byte];

	while(rest > 0){
		bit2 >>= 1;
		rest -= 1;
	}

	(u8)[out + 0] = bit0;
	(u8)[out + 1] = bit1;
	(u8)[out + 2] = bit2;	
}

*/

/*###############################################################
#                                                               #
#                          MPC_AND                              # 
#                                                               #
###############################################################*/

/*
export
fn jazz_mpc_AND(reg u64 in1, reg u64 in2, reg u64 out, reg u64 r){

	reg u8 t, t0, t1;
	reg u64 i, j, aux;

	i=0;
	j = 1;
	aux = 0;
	while(i < 3){

		// j = (i + 1) % 3
		if(i == 2){
			j = 0;
		}
		
        // in1[i] & in2[(i + 1) % 3]

		t = (u8)[in1 + (int)i];
		t0 = (u8)[in2 + (int)j];
		t &= t0;

		
		// in1[(i + 1) % 3] & in2[i]

		t0 = (u8)[in1 + (int)j];
		t1 = (u8)[in2 + (int)i];
		t0 &= t1;
		t ^= t0;

		// in1[i] & in2[i]

		t0 = (u8)[in1 + (int)i];
		t1 = (u8)[in2 + (int)i];
		t0 &= t1;
		t ^= t0;


		// r[i]

		t0 = (u8)[r + (int)i];
		t ^= t0;


		// r[(i + 1) % 3]

		t0 = (u8)[r + (int)j];
		t ^= t0;

		(u8)[out + (int)i] = t;

		i += 1;
		j += 1;
	}	
}
*/

export
fn jazz_mpc_AND(reg u64 in1, reg u64 in2, reg u64 out, reg u64 r){

	reg u8 t, t0, t1;

	// i = 0

	t = (u8)[in1 + 0];
	t0 = (u8)[in2 + 1];
	t &= t0;


	t0 = (u8)[in1 + 1];
	t1 = (u8)[in2 + 0];
	t0 &= t1;
	t ^= t0;


	t0 = (u8)[in1 + 0];
	t1 = (u8)[in2 + 0];
	t0 &= t1;
	t ^= t0;


	t0 = (u8)[r + 0];
	t ^= t0;


	t0 = (u8)[r + 1];
	t ^= t0;

	(u8)[out + 0] = t;



	// i = 1

	t = (u8)[in1 + 1];
	t0 = (u8)[in2 + 2];
	t &= t0;


	t0 = (u8)[in1 + 2];
	t1 = (u8)[in2 + 1];
	t0 &= t1;
	t ^= t0;


	t0 = (u8)[in1 + 1];
	t1 = (u8)[in2 + 1];
	t0 &= t1;
	t ^= t0;


	t0 = (u8)[r + 1];
	t ^= t0;


	t0 = (u8)[r + 2];
	t ^= t0;

	(u8)[out + 1] = t;



	// i = 2

	t = (u8)[in1 + 2];
	t0 = (u8)[in2 + 0];
	t &= t0;


	t0 = (u8)[in1 + 0];
	t1 = (u8)[in2 + 2];
	t0 &= t1;
	t ^= t0;


	t0 = (u8)[in1 + 2];
	t1 = (u8)[in2 + 2];
	t0 &= t1;
	t ^= t0;


	t0 = (u8)[r + 2];
	t ^= t0;


	t0 = (u8)[r + 0];
	t ^= t0;

	(u8)[out + 2] = t;	
}




/*###############################################################
#                                                               #
#                      MPC_AND_SET_BIT                          # 
#                                                               #
###############################################################*/

export
fn jazz_and_setBit(reg u64 rand0, reg u64 rand1, reg u64 rand2, reg u64 randPos, reg u64 r){

	reg u64 bit;
	reg u8 r0, r1, r2;

	bit = (u64)[randPos + 0];

	/* Bit 0 */

	r0 = (u8)[r + 0];
	inline_setBit(rand0, bit, r0);

	/* Bit 1 */

	r1 = (u8)[r + 1];
	inline_setBit(rand1, bit, r1);

	/* Bit 2 */

	r2 = (u8)[r + 2];
	inline_setBit(rand2, bit, r2);

	//bit += 1;
	//[randPos + 0] = bit;
}


/*###############################################################
#                                                               #
#                        MPC_GET_BIT                            # 
#                                                               #
###############################################################*/


export
fn jazz_mpc_getBit(reg u64 rand0, reg u64 rand1, reg u64 rand2, reg u64 randPos, reg u64 out){

	reg u64 bitNumber;
	reg u8 a, b, c;

	bitNumber = [randPos + 0];

	a, b, c = my_getBits(rand0, bitNumber);
	(u8)[out + 0] = a;
	(u8)[out + 3] = b;
	(u8)[out + 6] = c;

	a, b, c = my_getBits(rand1, bitNumber);
	(u8)[out + 1] = a;
	(u8)[out + 4] = b;
	(u8)[out + 7] = c;

	a, b, c = my_getBits(rand2, bitNumber);
	(u8)[out + 2] = a;
	(u8)[out + 5] = b;
	(u8)[out + 8] = c;
}

/*###############################################################
#                                                               #
#                   MPC_SET_BIT_PRECOMPUTE                      # 
#                                                               #
###############################################################*/

export
fn jazz_mpc_setBit_precompute(reg u64 in1, reg u64 in2, reg u64 out){

	/*   
	          0   1   2   3   4   5   6   7   8
		in1: [a0, a1, a2, b0, b1, b2, c0, c1, c2]

		      0      1    2    3    4    5    6    7    8
		in2: [bc0 , bc1, bc2, ca0, ca1, ca2, ab0, ab1, ab2]
	*/

	reg u8 t, t0;

	// aux = a[j] ^ (bc[j]);

	t = (u8)[in1 + 0];			// a

	t0 = (u8)[in2 + 0];			// bc
	t ^= t0;

	(u8)[out + 0] = t;



	t = (u8)[in1 + 1];			// a

	t0 = (u8)[in2 + 1];			// bc
	t ^= t0;

	(u8)[out + 1] = t;



	t = (u8)[in1 + 2];			// a

	t0 = (u8)[in2 + 2];			// bc
	t ^= t0;

	(u8)[out + 2] = t;




	// aux = a[j] ^ b[j] ^ (ca[j]);

	t = (u8)[in1 + 0];			// a
	t0 = (u8)[in1 + 3];			// b
	t ^= t0;

	t0 = (u8)[in2 + 3];			// ca
	t ^= t0;

	(u8)[out + 3] = t;



	t = (u8)[in1 + 1];			// a
	t0 = (u8)[in1 + 4];			// b
	t ^= t0;

	t0 = (u8)[in2 + 4];			// ca
	t ^= t0;

	(u8)[out + 4] = t;



	t = (u8)[in1 + 2];			// a
	t0 = (u8)[in1 + 5];			// b
	t ^= t0;

	t0 = (u8)[in2 + 5];			// ca
	t ^= t0;

	(u8)[out + 5] = t;




	// aux = a[j] ^ b[j] ^ c[j] ^ (ab[j]);

	t = (u8)[in1 + 0];			// a
	t0 = (u8)[in1 + 3];			// b
	t ^= t0;
	t0 = (u8)[in1 + 6];			// c
	t ^= t0;

	t0 = (u8)[in2 + 6];			// ca
	t ^= t0;

	(u8)[out + 6] = t;


	t = (u8)[in1 + 1];			// a
	t0 = (u8)[in1 + 4];			// b
	t ^= t0;
	t0 = (u8)[in1 + 7];			// c
	t ^= t0;

	t0 = (u8)[in2 + 7];			// ab
	t ^= t0;

	(u8)[out + 7] = t;


	t = (u8)[in1 + 2];			// a
	t0 = (u8)[in1 + 5];			// b
	t ^= t0;
	t0 = (u8)[in1 + 8];			// c
	t ^= t0;

	t0 = (u8)[in2 + 8];			// ca
	t ^= t0;

	(u8)[out + 8] = t;
	
}

/*###############################################################
#                                                               #
#                        MPC_SET_BIT                            # 
#                                                               #
###############################################################*/


export
fn jazz_mpc_setBit(reg u64 array0, reg u64 array1, reg u64 array2, reg u64 pos, reg u64 in){

	reg u64 i, j, bitNumber;
	reg u8 t;

	bitNumber = [pos + 0];

	i = 0;
	j = 0;
	while(i < 3){
		
		t = (u8)[in + (int)j];

		inline_setBit(array0, bitNumber, t);

		j += 1;
		t = (u8)[in + (int)j];

		inline_setBit(array1, bitNumber, t);

		j += 1;
		t = (u8)[in + (int)j];

		inline_setBit(array2, bitNumber, t);

		bitNumber -= 1;
		j += 1;
		i += 1;
	}
}
























/*#################################################################################################
#                                                                                                 #
#                                    MPC VERIFY FUNCTIONS                                         # 
#                                                                                                 #
#################################################################################################*/








/*###############################################################
#                                                               #
#                     MPC_GET_BIT VERIFY                        # 
#                                                               #
###############################################################*/

export
fn jazz_mpc_getBit_verify(reg u64 rand0, reg u64 rand1, reg u64 randPos, reg u64 out){

	reg u64 bitNumber;
	reg u8 a, b, c;

	bitNumber = [randPos + 0];

	a, b, c = my_getBits(rand0, bitNumber);
	(u8)[out + 0] = a;
	(u8)[out + 2] = b;
	(u8)[out + 4] = c;

	a, b, c = my_getBits(rand1, bitNumber);
	(u8)[out + 1] = a;
	(u8)[out + 3] = b;
	(u8)[out + 5] = c;
}




/*###############################################################
#                                                               #
#                   MPC_AND_GET_BIT VERIFY                      # 
#                                                               #
###############################################################*/


export
fn jazz_and_getBit_verify(reg u64 rand0, reg u64 rand1, reg u64 randPos, reg u64 out){

	reg u64 bitNumber;
	reg u8 a, b;

	bitNumber = [randPos + 0];

	a = global_getBit(rand0, bitNumber);
	b = global_getBit(rand1, bitNumber);

	(u8)[out + 0] = a;
	(u8)[out + 1] = b;	
}

/*###############################################################
#                                                               #
#                       MPC_AND_VERIFY                          # 
#                                                               #
###############################################################*/

export
fn jazz_mpc_AND_verify(reg u64 in1, reg u64 in2, reg u64 out, reg u64 r){

	reg u8 t, t0, t1;

	// i = 0

	t = (u8)[in1 + 0];
	t0 = (u8)[in2 + 1];
	t &= t0;


	t0 = (u8)[in1 + 1];
	t1 = (u8)[in2 + 0];
	t0 &= t1;
	t ^= t0;


	t0 = (u8)[in1 + 0];
	t1 = (u8)[in2 + 0];
	t0 &= t1;
	t ^= t0;


	t0 = (u8)[r + 0];
	t ^= t0;


	t0 = (u8)[r + 1];
	t ^= t0;

	(u8)[out + 0] = t;



	// i = 1

	t = (u8)[in1 + 1];
	t0 = (u8)[in2 + 2];
	t &= t0;


	t0 = (u8)[in1 + 2];
	t1 = (u8)[in2 + 1];
	t0 &= t1;
	t ^= t0;


	t0 = (u8)[in1 + 1];
	t1 = (u8)[in2 + 1];
	t0 &= t1;
	t ^= t0;


	t0 = (u8)[r + 1];
	t ^= t0;


	t0 = (u8)[r + 2];
	t ^= t0;

	(u8)[out + 1] = t;
}


/*###############################################################
#                                                               #
#                   MPC_AND_SET_BIT VERIFY                      # 
#                                                               #
###############################################################*/


export
fn jazz_and_setBit_verify(reg u64 array0, reg u64 array1, reg u64 randPos, reg u64 out){

	reg u64 bitNumber;
	reg u8 a;

	bitNumber = [randPos + 0];

	a = (u8)[out + 0];

	inline_setBit(array0, bitNumber, a);


	a = global_getBit(array1, bitNumber);

	(u8)[out + 1] = a;	
}


/*###############################################################
#                                                               #
#                   MPC_SET_BIT_PRECOMPUTE                      # 
#                                                               #
###############################################################*/

export
fn jazz_mpc_setBit_precompute_verify(reg u64 in1, reg u64 in2, reg u64 out){


	reg u8 t, t0;

	// aux = a[j] ^ (bc[j]);

	t = (u8)[in1 + 0];			// a

	t0 = (u8)[in2 + 0];			// bc
	t ^= t0;

	(u8)[out + 0] = t;



	t = (u8)[in1 + 1];			// a

	t0 = (u8)[in2 + 1];			// bc
	t ^= t0;

	(u8)[out + 1] = t;




	// aux = a[j] ^ b[j] ^ (ca[j]);

	t = (u8)[in1 + 0];			// a
	t0 = (u8)[in1 + 2];			// b
	t ^= t0;

	t0 = (u8)[in2 + 2];			// ca
	t ^= t0;

	(u8)[out + 2] = t;



	t = (u8)[in1 + 1];			// a
	t0 = (u8)[in1 + 3];			// b
	t ^= t0;

	t0 = (u8)[in2 + 3];			// ca
	t ^= t0;

	(u8)[out + 3] = t;




	// aux = a[j] ^ b[j] ^ c[j] ^ (ab[j]);

	t = (u8)[in1 + 0];			// a
	t0 = (u8)[in1 + 2];			// b
	t ^= t0;
	t0 = (u8)[in1 + 4];			// c
	t ^= t0;

	t0 = (u8)[in2 + 4];			// ab
	t ^= t0;

	(u8)[out + 4] = t;


	t = (u8)[in1 + 1];			// a
	t0 = (u8)[in1 + 3];			// b
	t ^= t0;
	t0 = (u8)[in1 + 5];			// c
	t ^= t0;

	t0 = (u8)[in2 + 5];			// ab
	t ^= t0;

	(u8)[out + 5] = t;
}

/*###############################################################
#                                                               #
#                     MPC_SET_BIT_VERIFY                        # 
#                                                               #
###############################################################*/


export
fn jazz_mpc_setBit_verify(reg u64 array0, reg u64 array1, reg u64 pos, reg u64 in){

	reg u64 i, j, bitNumber;
	reg u8 t;

	bitNumber = [pos + 0];

	i = 0;
	j = 0;
	while(i < 3){
		
		t = (u8)[in + (int)j];

		inline_setBit(array0, bitNumber, t);

		j += 1;
		t = (u8)[in + (int)j];

		inline_setBit(array1, bitNumber, t);

		bitNumber -= 1;
		j += 1;
		i += 1;
	}
}



