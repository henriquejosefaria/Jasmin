/****************************
*                           *
*  Sha1 auxiliar functions  *
*                           *
****************************/



inline
fn GETBIT_u32_v2(reg u8 x, reg u64 bit_idx) -> reg u8 {

    while(bit_idx > 0){
        x = x >> 1;
        bit_idx -= 1;
    }

    x &= 0x01; 
    
    return x;   
}

inline
fn GETBIT_EXTENDED(stack u32[8] aux, stack u64 bit_idx) -> reg u8 {

    reg u8 selectedBit;
    reg u64 bit_aux;
    reg u64 byte_aux;
    
    bit_aux = bit_idx;
    byte_aux = 0;

    while(bit_aux >= 8){
        byte_aux += 1;
        bit_aux -= 8;
    }

    selectedBit = aux[u8 (int)byte_aux];

    selectedBit = GETBIT_u32_v2(selectedBit, bit_aux);

    return  selectedBit;    
}

inline
fn GETBIT_u32(reg u32 x, reg u64 bit_idx) -> reg u32 {
    
    reg u64 aux;

    aux = bit_idx;

    while(aux > 0){
        x = x >> 1;
        aux -= 1;
    }

    x &= 0x01; 
    
    return x;   
}

inline
fn GETBIT_u32_left(reg u32 x, reg u64 bit_idx) -> reg u32 {
    
    reg u64 aux;

    aux = bit_idx;

    while(aux > 0){
        x = x >> 1;
        aux -= 1;
    }

    x &= 1; 
    
    return x;   
}


inline
fn LEFTROTATE(reg u32 x, reg u64 n) -> reg u32 {

    reg u32 aux0, aux1;
    reg u64 n1;

    aux0 = x;
    aux1 = x;

    n1 = n;

    while(n1 > 0){
        aux0 <<= 1;
        n1 -= 1;
    }

    n1 = 32;
    n1 -= n;

    while(n1 > 0){

        aux1 = aux1 >> 1;

        n1 -= 1;
    }

    aux0 |= aux1;
    
    return aux0;
}


inline
fn mpc_XOR2(stack u32[2] x, stack u32[2] y, stack u32[2] z) -> stack u32[2] {
    
    reg u32 aux;

    aux = x[0];
    aux ^= y[0];
    z[0] = aux;

    aux = x[1];
    aux ^= y[1];
    z[1] = aux;

    return z;
}

inline
fn mpc_XOR_w(stack u32[160] w, reg u64 j) -> stack u32[160]{
    
    reg u32 aux; 
    reg u64 pos_w;

    stack u32[2] temp;
    
    /* 1ยบ XOR */

    pos_w = j;
    pos_w -= 3;
    aux = w[(int)pos_w];

    pos_w = j;
    pos_w -= 8;
    aux ^= w[(int)pos_w];

    temp[0] = aux;


    pos_w = j;
    pos_w -= 3;
    pos_w += 80;
    aux = w[(int)pos_w];

    pos_w = j;
    pos_w -= 8;
    pos_w += 80;
    aux ^= w[(int)pos_w];

    temp[1] = aux;


    /* 2ยบ XOR */

    pos_w = j;
    pos_w -= 14;
    aux = w[(int)pos_w];

    aux ^= temp[0];

    temp[0] = aux;


    pos_w = j;
    pos_w -= 14;
    pos_w += 80;
    aux = w[(int)pos_w];

    aux ^= temp[1];

    temp[1] = aux;


    /* 3ยบ XOR */

    pos_w = j;
    pos_w -= 16;
    aux = w[(int)pos_w];

    aux ^= temp[0];

    temp[0] = aux;


    pos_w = j;
    pos_w -= 16;
    pos_w += 80;
    aux = w[(int)pos_w];

    aux ^= temp[1];

    temp[1] = aux;


    /* LEFT ROTATE */

    aux = temp[0];
    pos_w = 1;

    aux = LEFTROTATE(aux, pos_w);

    pos_w = j;

    w[(int)pos_w] = aux;


    aux = temp[0];
    pos_w = 1;

    aux = LEFTROTATE(aux, pos_w);
    
    pos_w = j;
    pos_w += 80;
    w[(int)pos_w] = aux;

    return w;
}

inline
fn mpc_LEFTROTATE2(stack u32[2] x, reg u64 i, stack u32[2] z) -> stack u32[2] {

    reg u32 res;

    res = x[0];
    res = LEFTROTATE(res,i);
    z[0] = res;

    res = x[1];
    res = LEFTROTATE(res,i);
    z[1] = res;

    return z;
}

inline
fn mpc_LEFTROTATE2_5(stack u32[2] a, stack u32[2] temp) -> stack u32[2] {
    
    reg u32 storage_u32, storage_aux; 
    
    storage_u32 = a[0];
    storage_aux = a[0];
    storage_u32 = storage_u32 << 5;
    storage_aux = storage_aux >> 27;
    storage_u32 |= storage_aux;
    temp[0] = storage_u32;

    storage_u32 = a[1];
    storage_aux = a[1];
    storage_u32 = storage_u32 << 5;
    storage_aux = storage_aux >> 27;
    storage_u32 |= storage_aux;
    temp[1] = storage_u32;

    return temp;
}

inline
fn mpc_LEFTROTATE_w(stack u32[2] x, reg u64 i, stack u32[160] w, reg u64 pos_w) -> stack u32[160] {
    
    reg u32 storage_u32, x_0;
    reg u64 n;

    storage_u32 = x[0];
    n = i;
    while(n > 0){
        storage_u32 <<= 1;
        n -= 1;
    }

    n = 32;
    n -= i;

    x_0 = x[0];

    while(n > 0){
        x_0 >>= 1;

        n -= 1;
    }
    
    storage_u32 |= x_0;

    w[(int)pos_w] = storage_u32;

    return w;
}

inline
fn w_to_temp(stack u32[2] temp, stack u32[160] w, reg u64 pos_w) -> stack u32[2]{

    reg u32 aux0, aux1;

    aux0 = w[(int)pos_w - 3];
    aux1 = w[(int)pos_w - 8];

    temp[0] = aux0;
    temp[0] ^= aux1;


    aux0 = w[(int)pos_w - 14];

    temp[0] ^= aux0;


    aux0 = w[(int)pos_w - 16];

    temp[0] ^= aux0;


    return temp;
}

/******************************
*                             *
*  SHA256 auxiliar functions  *
*                             *
******************************/



fn ROTLEFT(reg u32 a, reg u8 b) -> reg u32{

    a = ((a << b) | (a >> (32 - b)));
    return a;
} 

fn ROTRIGHT(reg u32 a, reg u8 b) -> stack u32 {

    a = ((a >> b) | (a << (32 - b)));
    return a;
}

fn ROTRIGHT_2(reg u32 a) -> stack u32 {

    reg u32 a_aux;

    a_aux = a;

    a >>= 2;
    a_aux <<= 30;

    a |= a_aux;

    return a;
}

fn ROTRIGHT_13(reg u32 a) -> stack u32 {

    reg u32 a_aux;

    a_aux = a;

    a >>= 13;
    a_aux <<= 19;

    a |= a_aux;

    return a;
}

fn ROTRIGHT_22(reg u32 a) -> stack u32 {

    reg u32 a_aux;

    a_aux = a;

    a >>= 22;
    a_aux <<= 10;

    a |= a_aux;

    return a;
}

fn ROTRIGHT_6(reg u32 a) -> stack u32 {

    reg u32 a_aux;

    a_aux = a;

    a >>= 6;
    a_aux <<= 26;

    a |= a_aux;

    return a;
}

fn ROTRIGHT_11(reg u32 a) -> stack u32 {

    reg u32 a_aux;

    a_aux = a;

    a >>= 11;
    a_aux <<= 21;

    a |= a_aux;

    return a;
}

fn ROTRIGHT_25(reg u32 a) -> stack u32 {

    reg u32 a_aux;

    a_aux = a;

    a >>= 25;
    a_aux <<= 7;

    a |= a_aux;

    return a;
}


inline
fn EP0(stack u32 x) -> reg u32{

    reg u32 res, res1, res2;
    stack u32 r,r1,r2;


    res = x;
    res = ROTRIGHT_2(res);
    r = res;

    res1 = x;
    res1 = ROTRIGHT_13(res1);
    r1 = res1;


    res2 = x;
    res2 = ROTRIGHT_22(res2);
    r2 = res2;
    
    res = r;
    res1 = r1;
    res ^= res1;
    res2 = r2;
    res ^= res2;

    return res;
}

inline
fn EP1(stack u32 x) -> reg u32{

    reg u32 res, res1, res2;

    res = x;
    res = ROTRIGHT_6(res);

    res1 = x;
    res1 = ROTRIGHT_11(res1);
    
    res2 = x;
    res2 = ROTRIGHT_25(res2);

    res ^= res1;
    res ^= res2;

    return res;
} 


fn ROTRIGHT_7(reg u32 a) -> reg u32 {

    reg u32 a_aux;

    a_aux = a;

    a >>= 7;
    a_aux <<= 25;

    a ^= a_aux;

    return a;
}

fn ROTRIGHT_18(reg u32 a) -> reg u32 {

    reg u32 a_aux;

    a_aux = a;

    a >>= 18;
    a_aux <<= 14;

    a ^= a_aux;

    return a;
}

fn ROTRIGHT_17(reg u32 a) -> reg u32 {

    reg u32 a1, a2;

    a1 = a;
    a1 >>= 17;

    a2 = a;
    a2 <<= 15;

    a1 |= a2;

    return a1;
}

fn ROTRIGHT_19(reg u32 a) -> reg u32 {

    reg u32 a1, a2;

    a1 = a;
    a1 >>= 19;

    a2 = a;
    a2 <<= 13;

    a1 |= a2;

    return a1;
}

inline
fn SIG0(reg u32 x) -> reg u32 {

    reg u32 x0, x1;

    x0 = x;
    x0 = ROTRIGHT_7(x0);

    x1 = x;
    x1 = ROTRIGHT_18(x1);

    x >>= 3;

    x0 ^= x1;
    x0 ^= x;

    return x0;
}

inline
fn SIG1(reg u32 x) -> reg u32{
    reg u32 x0, x1, x2;

    x0 = x;
    x0 = ROTRIGHT_17(x0);
    
    x1 = x;
    x1 = ROTRIGHT_19(x1);

    x2 = x;
    x2 = (x2 >> 10); 

    x0 ^= x1;
    x0 ^= x2;

    return x0;
}

inline
fn CH(stack u32 x, stack u32 y, stack u32 z) -> reg u32{
    
    reg u32 t0, t1;

    t0 = x;
    t0 &= y;

    t1 = x;
    t1 ^= 0xFFFFFFFF;
    t1 &= z;

    t0 ^= t1;

    return t0;
}

inline
fn MAJ(stack u32 x, stack u32 y, stack u32 z) -> reg u32{

    reg u32 t0, t1, tx, ty, tz;

    t0 = x;
    ty = y;
    t0 = t0 & ty;

    t1 = x;
    tz = z;
    t1 &= tz;
    t0 ^= t1;

    t1 = y;
    tz = z;
    t1 &= tz;
    t0 ^= t1;

    return t0;
}

inline
fn initializeK(stack u32[64] k) -> stack u32[64]{
    k[0] = 0x428a2f98;
    k[1] = 0x71374491;
    k[2] = 0xb5c0fbcf;
    k[3] = 0xe9b5dba5;
    k[4] = 0x3956c25b;
    k[5] = 0x59f111f1;
    k[6] = 0x923f82a4;
    k[7] = 0xab1c5ed5;
    k[8] = 0xd807aa98;
    k[9] = 0x12835b01;
    k[10] = 0x243185be;
    k[11] = 0x550c7dc3;
    k[12] = 0x72be5d74;
    k[13] = 0x80deb1fe;
    k[14] = 0x9bdc06a7;
    k[15] = 0xc19bf174;
    k[16] = 0xe49b69c1;
    k[17] = 0xefbe4786;
    k[18] = 0x0fc19dc6;
    k[19] = 0x240ca1cc;
    k[20] = 0x2de92c6f;
    k[21] = 0x4a7484aa;
    k[22] = 0x5cb0a9dc;
    k[23] = 0x76f988da;
    k[24] = 0x983e5152;
    k[25] = 0xa831c66d;
    k[26] = 0xb00327c8;
    k[27] = 0xbf597fc7;
    k[28] = 0xc6e00bf3;
    k[29] = 0xd5a79147;
    k[30] = 0x06ca6351;
    k[31] = 0x14292967;
    k[32] = 0x27b70a85;
    k[33] = 0x2e1b2138;
    k[34] = 0x4d2c6dfc;
    k[35] = 0x53380d13;
    k[36] = 0x650a7354;
    k[37] = 0x766a0abb;
    k[38] = 0x81c2c92e;
    k[39] = 0x92722c85;
    k[40] = 0xa2bfe8a1;
    k[41] = 0xa81a664b;
    k[42] = 0xc24b8b70;
    k[43] = 0xc76c51a3;
    k[44] = 0xd192e819;
    k[45] = 0xd6990624;
    k[46] = 0xf40e3585;
    k[47] = 0x106aa070;
    k[48] = 0x19a4c116;
    k[49] = 0x1e376c08;
    k[50] = 0x2748774c;
    k[51] = 0x34b0bcb5;
    k[52] = 0x391c0cb3;
    k[53] = 0x4ed8aa4a;
    k[54] = 0x5b9cca4f;
    k[55] = 0x682e6ff3;
    k[56] = 0x748f82ee;
    k[57] = 0x78a5636f;
    k[58] = 0x84c87814;
    k[59] = 0x8cc70208;
    k[60] = 0x90befffa;
    k[61] = 0xa4506ceb;
    k[62] = 0xbef9a3f7;
    k[63] = 0xc67178f2;

    return k;
}

inline
fn dbl_int_add(stack u32[2] ctx_bitlen, reg u64 c) -> stack u32[2] {

    reg u32 a, b;
    
    a = ctx_bitlen[0];
    
    b = 0xffffffff;
    b -= c;

    if(a > b){
        a = ctx_bitlen[1];
        a += 1; 
        ctx_bitlen[1] = a;
    } else {
        a += c;
        ctx_bitlen[0] = a;
    }

    return ctx_bitlen;
}

inline
fn compute_t1(stack u32 e, stack u32 f, stack u32 g, stack u32 h, stack u32[64] k, stack u32[64] m, reg u64 i) -> reg u32{

    reg u32 t, t1;

    t1 = h;
        
    t = EP1(e);
    t1 += t;

    t = CH(e,f,g);
    t1 += t;

    t = k[(int)i];
    t1 += t;
    
    t = m[(int)i];
    t1 += t;

    return t1;
}

inline
fn compute_t2(stack u32 a, stack u32 b, stack u32 c) -> reg u32{
    
    reg u32 t, t2;


    t2 = EP0(a);
    
    t = MAJ(a, b, c); 
    t2 += t;
    

    return t2;
}

inline
fn sha256_transform(stack u32[8] ctx_state, stack u8[64] ctx_data) -> stack u32[8], stack u8[64]
{
    stack u32 a, b, c, d, e, f, g, h;
    reg u32 t0, t1, t2, temp;

    stack u32[64] m;

    reg u32 sig0, sig1;

    reg u64 i, j,z;

    inline int idx;

    reg u8 t8;

    stack u32[64] k;
    k = initializeK(k);
    

    /* IGUAL!! */
    i = 0;
    z = 0;
    while(i < 16){

        t0 = ctx_data[u32 (int)i];

        t0 = #BSWAP_32(t0);

        m[(int)i] = t0;

        i += 1;
    }
    

    /* IGUAL */
    z = 0;
    while(i < 64){

        j = i;
        j -= 2;
        temp = m[(int)j];
        temp = SIG1(temp);
        m[(int)i] = temp;

        j = i;
        j -= 7;
        temp =  m[(int)j];
        m[(int)i] += temp;

        j = i;
        j -= 15;
        temp = m[(int)j];
        temp = SIG0(temp);
        m[(int)i] += temp;

        j = i;
        j -= 16;
        temp =  m[(int)j];
        m[(int)i] += temp;
        
        i += 1;
    } 
    

    temp = ctx_state[0];
    a = temp;
    temp = ctx_state[1];
    b = temp;
    temp = ctx_state[2];
    c = temp;
    temp = ctx_state[3];
    d = temp;
    temp = ctx_state[4];
    e = temp;
    temp = ctx_state[5];
    f = temp;
    temp = ctx_state[6];
    g = temp;
    temp = ctx_state[7];
    h = temp;

    
    i = 0;
    j = 0;
    while(i < 64){

        t1 = compute_t1(e, f, g, h, k, m, i);
        t2 = compute_t2(a,b,c);
        
        t0 = g;
        h = t0;

        t0 = f;
        g = t0;

        t0 = e;
        f = t0;

        t0 = d;
        t0 += t1;
        e = t0;


        t0 = c;
        d = t0;

        t0 = b;
        c = t0;

        t0 = a;
        b = t0;

        t0 = t1;
        t0 += t2;
        a = t0;

        j += 4;
        i += 1;
    }

    temp = ctx_state[0];
    temp += a;
    ctx_state[0] = temp;

    temp = ctx_state[1];
    temp += b;
    ctx_state[1] = temp;

    temp = ctx_state[2];
    temp += c;
    ctx_state[2] = temp;

    temp = ctx_state[3];
    temp += d;
    ctx_state[3] = temp;

    temp = ctx_state[4];
    temp += e;
    ctx_state[4] = temp;

    temp = ctx_state[5];
    temp += f;
    ctx_state[5] = temp;

    temp = ctx_state[6];
    temp += g;
    ctx_state[6] = temp;

    temp = ctx_state[7];
    temp += h;
    ctx_state[7] = temp;
    
    return ctx_state, ctx_data;
}





/*********************
*                    *
*   H Aux Functions  *
*                    *
*********************/

inline
fn sha256_update1(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u8[16] data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u8 t;
    stack u64 i_aux;
    reg u64 c;

    i = 0;
    while(i < len){

        t = data[(int)i];
        i_aux = i;

        temp = ctx_datalen;
        ctx_data[(int)temp] = t;
        temp += 1;
        ctx_datalen = temp;

        if(ctx_datalen == 64){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            c = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,c);
            ctx_datalen = 0;
        }
        
        i = i_aux;
        i += 1;
    }
    
    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}


inline
fn sha256_update2(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u8[64] data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u8 t;
    stack u64 i_aux;

    i = 0;
    while(i < len){
        i_aux = i;
        t = data[(int)i];

        temp = ctx_datalen;
        ctx_data[(int)temp] = t;
        temp += 1;
        ctx_datalen = temp;

        if(ctx_datalen == 64){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,temp);
            ctx_datalen = 0;
        }

        i = i_aux;
        i += 1;
    }
    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}

inline
fn sha256_update3(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u8[1480] data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u8 t;
    stack u64 i_aux;
    reg u32 c;

    i = 0;
    while(i < len){
        t = data[(int)i];

        temp = ctx_datalen;
        ctx_data[(int)temp] = t;
        temp += 1;
        ctx_datalen = temp;

        if(ctx_datalen == 64){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,temp);
            ctx_datalen = 0;
        }

        i += 1;
    }
    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}


inline
fn sha256_update4(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u8[4] data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u8 t;
    stack u64 i_aux;

    i = 0;
    while(i < len){
        t = data[(int)i];
        i_aux = i;
        
        temp = ctx_datalen;
        ctx_data[(int)temp] = t;
        temp += 1;
        ctx_datalen = temp;
        
        if(temp == 64){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,temp);
            ctx_datalen = 0;
        }

        i = i_aux;
        i += 1;
    }

    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}

inline
fn sha256_final1(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u32[8] hash) -> stack u32[8], stack u8[64], stack u32[8]
{
    reg u64 i, temp;
    reg u32 value;
    reg u32 stored_value;
    reg u64 a_temp;
    stack u64 i_aux;
    reg u8 t8;

    // Pad whatever data is left in the buffer.
    

    i = ctx_datalen;

    if (i < 56) {
        ctx_data[(int)i] = 0x80;
        i += 1;
        while (i < 56){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
    }    
    else {
        ctx_data[(int)i] = 0x80;
        i += 1;
        while (i < 64){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
        ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);

        i = 0;
        while(i < 56){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
    }


    // Append to the padding the total message's length in bits and transform.
    

    temp = ctx_datalen;
    temp *= 8;
    ctx_bitlen = dbl_int_add(ctx_bitlen, temp);

    value = ctx_bitlen[0];
    value = #BSWAP_32(value);
    ctx_data[u32 15] = value;

    value = ctx_bitlen[1];
    value = #BSWAP_32(value);
    ctx_data[u32 14] = value;
    
    ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);

    
    i = 0;
    while(i < 8){

        value = ctx_state[(int)i];

        value = #BSWAP_32(value);

        hash[(int)i] = value;

        i += 1;
    }
    

    return ctx_state, ctx_data, hash;
}


/*****************
*                *
*   H - SHA256   *
*                *
*****************/

inline
fn H(reg u64 zs, stack u32[8] hash_p1, stack u32[8] hash_p2, reg u64 mpc_round) -> stack u32[8], stack u32[8] {

    stack u64 ctx_datalen;
    stack u32[2] ctx_bitlen;
    stack u32[8] ctx_state;
    stack u8[64] ctx_data;


    stack u8[16] k_p1, k_p2;
    stack u8[64] view_x_p1, view_x_p2;
    stack u8[1480] view_y_p1, view_y_p2;
    stack u8[4] rs_p1, rs_p2;

    reg u64 i, temp_zs;

    reg u8 t;

    /* Copy Players' shares */

    temp_zs = mpc_round * 3128;                 // mpc_round * 782 + 0 (player)  <= u32

    i = 0;
    while(i < 16){

        t = (u8)[zs + (int)temp_zs];
        k_p1[(int)i] = t;

        temp_zs += 1;
        i += 1;
    }

    i = 0;
    while(i < 16){

        t = (u8)[zs + (int)temp_zs];
        k_p2[(int)i] = t;

        temp_zs += 1;
        i += 1;
    }


    /* Copy Players' Views */

    i = 0;
    while(i < 64){

        t = (u8)[zs + (int)temp_zs];
        view_x_p1[(int)i] = t;

        temp_zs += 1;
        i += 1;
    }

    i = 0;
    while(i < 1480){

        t = (u8)[zs + (int)temp_zs];
        view_y_p1[(int)i] = t;

        temp_zs += 1;
        i += 1;
    }

    i = 0;
    while(i < 64){

        t = (u8)[zs + (int)temp_zs];
        view_x_p2[(int)i] = t;

        temp_zs += 1;
        i += 1;
    }

    i = 0;
    while(i < 1480){

        t = (u8)[zs + (int)temp_zs];
        view_y_p2[(int)i] = t;

        temp_zs += 1;
        i += 1;
    }


    /* Copy Players' Rs */

    i = 0;
    while(i < 4){

        t = (u8)[zs + (int)temp_zs];
        rs_p1[(int)i] = t;

        temp_zs += 1;
        i += 1;
    }
    
    i = 0;
    while(i < 4){

        t = (u8)[zs + (int)temp_zs];
        rs_p2[(int)i] = t;

        temp_zs += 1;
        i += 1;
    }

    /* Hash Player1's info */

    ctx_datalen = 0;
    ctx_bitlen[0] = 0;
    ctx_bitlen[1] = 0;
    ctx_state[0] = 0x6a09e667;
    ctx_state[1] = 0xbb67ae85;
    ctx_state[2] = 0x3c6ef372;
    ctx_state[3] = 0xa54ff53a;
    ctx_state[4] = 0x510e527f;
    ctx_state[5] = 0x9b05688c;
    ctx_state[6] = 0x1f83d9ab;
    ctx_state[7] = 0x5be0cd19;

    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update1(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, k_p1, 16);
    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update2(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, view_x_p1, 64);
    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update3(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, view_y_p1, 1480);
    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update4(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, rs_p1, 4);
    ctx_state, ctx_data, hash_p1 = sha256_final1(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash_p1);



    /* Hash Player2's info */

    ctx_datalen = 0;
    ctx_bitlen[0] = 0;
    ctx_bitlen[1] = 0;
    ctx_state[0] = 0x6a09e667;
    ctx_state[1] = 0xbb67ae85;
    ctx_state[2] = 0x3c6ef372;
    ctx_state[3] = 0xa54ff53a;
    ctx_state[4] = 0x510e527f;
    ctx_state[5] = 0x9b05688c;
    ctx_state[6] = 0x1f83d9ab;
    ctx_state[7] = 0x5be0cd19;

    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update1(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, k_p2, 16);
    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update2(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, view_x_p2, 64);
    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update3(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, view_y_p2, 1480);
    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update4(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, rs_p2, 4);
    ctx_state, ctx_data, hash_p2 = sha256_final1(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash_p2);


    return hash_p1, hash_p2;
}



/*********************
*                    *
*  H3 Aux Functions  *
*                    *
*********************/


inline
fn sha256_update5(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u8[32] data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u8 t;
    stack u64 i_aux;
    
    i = 0;
    while(i < len){
        t = data[(int)i];
        i_aux = i;
        
        temp = ctx_datalen;
        ctx_data[(int)temp] = t;
        temp += 1;
        ctx_datalen = temp;
        
        if(ctx_datalen == 64){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,temp);
            ctx_datalen = 0;
        }

        i = i_aux;
        i += 1;
    }
    

    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}

inline
fn sha256_update6(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u8[26112] data, stack u64 len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u8 t;
    stack u64 i_aux;

    i = 0;
    while(i < len){
        t = data[(int)i];
        i_aux = i;
        
        temp = ctx_datalen;
        ctx_data[(int)temp] = t;
        temp += 1;
        ctx_datalen = temp;
        
        if(temp == 64){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,temp);
            ctx_datalen = 0;
        }

        i = i_aux;
        i += 1;
    }

    
    temp = ctx_datalen;
    while(temp < 64){
        ctx_data[(int)temp] = 0;
        temp += 1;
    }
    

    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}


inline
fn sha256_final2(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u32[8] hash) -> stack u8[64], stack u32[8]
{
    reg u64 i, temp;
    reg u64 j;
    reg u32 t, value, stored_value;


    // Pad whatever data is left in the buffer.

    i = ctx_datalen;

    if (i < 56) {
        ctx_data[(int)i] = 0x80;
        i += 1;
        while (i < 56){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
    }    
    else {
        ctx_data[(int)i] = 0x80;
        i += 1;
        while (i < 64){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
        ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);

        i = 0;
        while(i < 56){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
    }


    // Append to the padding the total message's length in bits and transform.
    

    temp = ctx_datalen;
    temp *= 8;
    ctx_bitlen = dbl_int_add(ctx_bitlen, temp);

    value = ctx_bitlen[0];
    value = #BSWAP_32(value);
    ctx_data[u32 15] = value;

    value = ctx_bitlen[1];
    value = #BSWAP_32(value);
    ctx_data[u32 14] = value;
    
    ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);


    // Since this implementation uses little endian byte ordering and SHA uses big endian,
    // reverse all the bytes when copying the final state to the output hash.

    i = 0;
    while(i < 8){

        value = ctx_state[(int)i];

        value = #BSWAP_32(value);

        hash[(int)i] = value;

        i += 1;
    }

    return ctx_data, hash;
}

/*****************
*                *
*       H3       *
*                *
*****************/

inline
fn H3(stack u32[8] y, reg u64 a, stack u64 s, stack u64[136] es) -> stack u64[136] {


    stack u32[8] hash; // unsigned char hash[SHA256_DIGEST_LENGTH];
    
    stack u8[64] ctx_data;
    stack u64 ctx_datalen;
    stack u32[2] ctx_bitlen;
    stack u32[8] ctx_state;

    reg u64 i, j, z, es_aux, temp, temp_as, temp_a;
    reg u64 bitTracker;
    reg u8 b1, b2;
    reg u32 j_aux;

    stack u64 bitTracker_aux;

    stack u64 len;

    reg u8 t;
    reg u32 t32;

    reg u64 counter;
    stack u64 counter_s;


    stack u8[32] hash_s;
    stack u8[26112] a_s; // 192 * mpcRounds

    ctx_datalen = 0;
    ctx_bitlen[0] = 0;
    ctx_bitlen[1] = 0;
    ctx_state[0] = 0x6a09e667;
    ctx_state[1] = 0xbb67ae85;
    ctx_state[2] = 0x3c6ef372;
    ctx_state[3] = 0xa54ff53a;
    ctx_state[4] = 0x510e527f;
    ctx_state[5] = 0x9b05688c;
    ctx_state[6] = 0x1f83d9ab;
    ctx_state[7] = 0x5be0cd19;

    counter_s = 0;

    i = 0;
    while(i < 20){
        t = y[u8 (int)i];
        hash_s[(int)i] = t;
        i += 1;
    }

    i = 0;
    while(i < 64){
        ctx_data[(int)i] = 0;
        i += 1;
    }


    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update5(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash_s, 20); 
    
    i = 0;
    while(i < s){

        j = 0;
        while(j < 3){

            /* a.yp */

            temp_as = i * 192;

            temp = j * 32;
            temp_as += temp;


            temp_a = s * 32;
            temp_a *= j;

            temp = i * 32;
            temp_a += temp;

            z = 0;
            while(z < 32){
                t = (u8)[a + (int) temp_a];
                a_s[(int) temp_as] = t;

                temp_as += 1;
                temp_a += 1;
                z += 1;
            }
            

            /* a.h */

            temp_as = i * 192;

            temp = 3 * 32;
            temp_as += temp;

            temp = j * 32;
            temp_as += temp;


            temp_a = s * 32;
            temp_a *= 3;

            temp = s * 32;
            temp *= j;
            temp_a += temp;

            temp = i * 32;
            temp_a += temp;

            z = 0;
            while(z < 32){
                t = (u8)[a + (int) temp_a];
                a_s[(int) temp_as] = t;

                temp_as += 1;
                temp_a += 1;
                z += 1;
            }

            j += 1;
        }
        
        i += 1;
    }
    
    i = 192 * s;
    len = i;

    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update6(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, a_s, len);
    
    ctx_data, hash = sha256_final2(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash);

    
    //Pick bits from hash
    i = 0;
    bitTracker_aux = 0;
    bitTracker = bitTracker_aux;
    while(i < s) {

        if(bitTracker_aux >= 256) { //Generate new hash

            ctx_datalen = 0;
            ctx_bitlen[0] = 0;
            ctx_bitlen[1] = 0;
            ctx_state[0] = 0x6a09e667;
            ctx_state[1] = 0xbb67ae85;
            ctx_state[2] = 0x3c6ef372;
            ctx_state[3] = 0xa54ff53a;
            ctx_state[4] = 0x510e527f;
            ctx_state[5] = 0x9b05688c;
            ctx_state[6] = 0x1f83d9ab;
            ctx_state[7] = 0x5be0cd19;

            j = 0;
            while(j < 32){
                t = hash[u8 (int)j];
                hash_s[(int)j] = t;
                j += 1;
            }

            ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update5(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash_s, 32);
            ctx_data, hash = sha256_final2(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash);

            bitTracker = 0;
        }
        bitTracker_aux = bitTracker;
        
        b1 = GETBIT_EXTENDED(hash, bitTracker_aux);
        bitTracker = bitTracker_aux;
        bitTracker += 1;
        bitTracker_aux = bitTracker;
        b2 = GETBIT_EXTENDED(hash, bitTracker_aux);
        
        if(b1 == 0) {
            if(b2 == 0) {
                es[(int)i] = 0;
                i += 1;
            } else {
                es[(int)i] = 1;
                i += 1;
            }
        } 
        else {
            if(b2 == 0) {
                es[(int)i] = 2;
                i += 1;
            }
        }

        bitTracker = bitTracker_aux;
        bitTracker += 1;                // alredy added 1 priviously!!
    }
    
    return es;
}






/*************************
*                        *
*    Verify functions    *
*                        *
*************************/





inline
fn mpc_ADD_verify(stack u32[2] x, stack u32[2] y, stack u32[2] z, reg u64 zs, stack u32[200192] randomness_p1, stack u32[200192] randomness_p2, stack u64 randCount, stack u64 countY, reg u64 mpc_round, stack u64 success, reg u64 as) -> stack u32[2], stack u64, stack u64, stack u64 {

    stack u32[2] r;

    reg u32[2] a, b;

    reg u32 t0, t1, t2;

    reg u64 count, temp_zs, i, i_plus;


    count = mpc_round * 368;
    count += randCount;

    t0 = randomness_p1[(int)count];
    r[0] = t0;

    t0 = randomness_p2[(int)count];
    r[1] = t0;

    count = randCount;
    count += 1;
    randCount = count;
    

    temp_zs = mpc_round * 3128;
    temp_zs += 32;
    temp_zs += 64;
    temp_zs += countY;

    i = 0;
    while(i < 31){

        // Player 1's view.y

        t0 = x[0];
        t1 = (u32)[zs + (int)temp_zs];
        t0 ^= t1;

        t0 = GETBIT_u32_left(t0,i);
        a[0] = t0;
        
        (u32)[as + 0] = t0; 

        t0 = y[0];
        t1 = (u32)[zs + (int)temp_zs];
        t0 ^= t1;

        t0 = GETBIT_u32_left(t0,i);
        b[0] = t0;

        (u32)[as + 4] = t0; 

        
        // Player 2's view.y

        temp_zs = mpc_round * 3128;
        temp_zs += 32;
        temp_zs += 64;
        temp_zs += 1480;
        temp_zs += 64;
        temp_zs += countY;

        t0 = x[1];
        t1 = (u32)[zs + (int)temp_zs];
        t0 ^= t1;

        t0 = GETBIT_u32_left(t0,i);
        a[1] = t0;

        (u32)[as + 8] = t0; 


        t0 = y[1];
        t1 = (u32)[zs + (int)temp_zs];
        t0 ^= t1;

        t0 = GETBIT_u32_left(t0,i);
        b[1] = t0;
        
        (u32)[as + 12] = t0; 


        temp_zs = mpc_round * 3128;
        temp_zs += 32;
        temp_zs += 64;
        temp_zs += countY;

        t0 = a[0];
        t0 &= b[1];

        //(u32)[as + 0] = t0;
        
        
        t1 = a[1];
        t1 &= b[0];
        t0 ^= t1;

        //(u32)[as + 4] = t0;
        

        t1 = r[1];
        t1 = GETBIT_u32_left(t1,i);
        t0 ^= t1;

        //(u32)[as + 8] = t0;
        

        t1 = a[0];
        t1 &= b[0];
        t0 ^= t1;
        
        //(u32)[as + 12] = t0;

        t1 = (u32)[zs + (int)temp_zs];
        t1 = GETBIT_u32_left(t1, i);
        t0 ^= t1;

        //(u32)[as + 16] = t0;
        

        t1 = r[0];
        t1 = GETBIT_u32_left(t1,i);
        t0 ^= t1;

        //(u32)[as + 20] = t0;
       

        t1 = (u32)[zs + (int)temp_zs];
        i_plus = i;
        i_plus += 1;
        t1 = GETBIT_u32_left(t1, i_plus);
        
        //(u32)[as + 24] = t1;

        if(t1 != t0){
            //(u64)[as + 28] = i;
            success = 1;

            i = 31;
        }
        


        i += 1;
    }

    temp_zs = mpc_round * 3128;
    temp_zs += 32;
    temp_zs += 64;
    temp_zs += countY;

    t0 = x[0];
    t0 ^= y[0];
    t1 = (u32)[zs + (int)temp_zs];
    t0 ^= t1;
    z[0] = t0;

    temp_zs = mpc_round * 3128;
    temp_zs += 32;
    temp_zs += 64;
    temp_zs += 1480;
    temp_zs += 64;
    temp_zs += countY;

    t0 = x[1];
    t0 ^= y[1];
    t1 = (u32)[zs + (int)temp_zs];
    t0 ^= t1;
    z[1] = t0;

    count = countY;
    count += 4;
    countY = count;

    return z, randCount, countY, success;
}


inline
fn mpc_AND_verify(stack u32[2] x, stack u32[2] y, stack u32[2] z, reg u64 zs, stack u32[200192] randomness_p1, stack u32[200192] randomness_p2, stack u64 randCount, stack u64 countY, reg u64 mpc_round, stack u64 success, reg u64 a) -> stack u32[2], stack u64, stack u64, stack u64  {

    stack u32[2] r;

    reg u32 t0, t1;
    reg u64 count;


    count = mpc_round * 368;  // we will access a u32 array so 1472 => 
    count += randCount;

    t0 = randomness_p1[(int)count];
    r[0] = t0;

    t0 = randomness_p2[(int)count];
    r[1] = t0;

    count = randCount;
    count += 1;
    randCount = count;


    t0 = x[0];
    t0 &= y[1];

    t1 = x[1];
    t1 &= y[0];
    t0 ^= t1;

    t1 = x[0];
    t1 &= y[0];
    t0 ^= t1;

    t0 ^= r[0];

    t0 ^= r[1];


    count = mpc_round * 3128;
    count += 32;
    count += 64;
    count += countY;

    t1 = (u32)[zs + (int)count]; 
    
    if(t1 != t0) {
        (u64)[a + 0] = 0;
        (u32)[a + 8] = t0;
        (u32)[a + 12] = t1;
        success = 1;
    }


    z[0] = t0;

    count = mpc_round * 3128;
    count += 32;
    count += 64;
    count += 1480;
    count += 64;
    count += countY;        // Get the P2 view.y position by summing P1's view.y and P2's view.x and view.y

    t0 = (u32)[zs + (int)count];
    z[1] = t0;


    count = countY;
    count += 4;
    countY = count;

    return z, randCount, countY, success;
}


inline
fn mpc_MAJ_verify(stack u32[2] a, stack u32[2] b, stack u32[2] c, stack u32[2] z, reg u64 zs, stack u32[200192] randomness_p1, stack u32[200192] randomness_p2, stack u64 randCount, stack u64 countY, reg u64 mpc_round, stack u64 success, reg u64 a_s) -> stack u32[2], stack u64, stack u64, stack u64 {
    
    stack u32[2] t0;
    stack u32[2] t1;

    t0 = mpc_XOR2(a, b, t0);
    t1 = mpc_XOR2(a, c, t1);

    z, randCount, countY, success = mpc_AND_verify(t0, t1, z, zs, randomness_p1, randomness_p2, randCount, countY, mpc_round, success, a_s);

    z = mpc_XOR2(z, a, z);

    return z, randCount, countY, success;
}




/*****************
*                *
*  Reconstruct   *
*                *
*****************/


inline
fn reconstruct(reg u64 a, stack u32[8] y, stack u64 mpcRounds) -> stack u32[8]{

    reg u64 temp, temp_aux;
    reg u64 i, j;
    reg u8 a_aux;

    temp_aux = 32;
    temp_aux *= mpcRounds;

    j = 0;
    i = 0;
    while(j<32){
        temp = j;

        a_aux = (u8)[a + (int)temp];

        temp += temp_aux;

        a_aux ^= (u8)[a + (int)temp];

        temp += temp_aux;

        a_aux ^= (u8)[a + (int)temp];

        y[u8(int)j] = a_aux;
        
        j += 1;
    }

    return y;   
}

/*****************
*                *
*     Verify     *
*                *
*****************/


inline 
fn verify(reg u64 a, stack u64[136] es, reg u64 zs, reg u64 mpc_round, stack u64 mpcRounds, stack u64 success, stack u32[200192] randomness_p1, stack u32[200192] randomness_p2, reg u64 randomness_player1) -> stack u64 {
    
    stack u32[8] hash_p1, hash_p2;
    stack u32[5] result;
    stack u32[4] rand;
    stack u32[160] w;

    reg u64 i, j;
    stack u64 randCount, countY, a_s, zs_s, i_s;

    reg u64 player, temp_aux, temp_zs, temp_a, temp_w, pos_w;
    reg u64 n;

    reg u32 storage_u32, k;

    stack u32[2] va, vb, vc, vd, ve, f, temp, temp1, w_aux;
    stack u32[5] hA;
    stack u32[2] hHa;

    reg u8 t, mem;

    stack u64 random_player1_s;

    hA[0] = 0x67452301;
    hA[1] = 0xEFCDAB89;
    hA[2] = 0x98BADCFE;
    hA[3] = 0x10325476;
    hA[4] = 0xC3D2E1F0;


    hash_p1, hash_p2 = H(zs, hash_p1, hash_p2, mpc_round);

    // Compare Player1 hash 

    player = es[(int)mpc_round];

    temp_a = player;
    temp_a *= mpcRounds;
    temp_a *= 32;

    temp_aux = mpcRounds * 32;      // A.yp => A.h
    temp_aux *= 3;
    temp_a += temp_aux;             

    temp_aux = mpc_round * 32;
    temp_a += temp_aux;


    i = 0;
    while(i < 32){

        t = hash_p1[u8 (int)i];

        mem = (u8)[a + (int)temp_a];

        if( t != mem){
            (u8)[a + 0] = 0;
            success = 1;
        }

        temp_a += 1;
        i += 1;
    }

    // Compare Player2 hash

    player += 1;
    if(player == 3){
        player = 0;
    }

    temp_a = player;
    temp_a *= mpcRounds;
    temp_a *= 32;

    temp_aux = mpcRounds * 32;      // A.yp => A.h
    temp_aux *= 3;
    temp_a += temp_aux;             

    temp_aux = mpc_round * 32;
    temp_a += temp_aux;

    i = 0;
    while(i < 32){

        t = hash_p2[u8 (int)i];
        mem = (u8)[a + (int)temp_a];

        if( t != mem){
            (u8)[a + 1] = 1;
            success = 1;
        }

        temp_a += 1;
        i += 1;
    }


    // Compare Player1 transcript

    player = es[(int)mpc_round];


    temp_zs = mpc_round * 3128;                 // mpc_round * 3128 + 0 (player)  <= u8

    temp_zs += 32;
    temp_zs += 64;
    temp_zs += 1460;


    temp_a = 32 * mpcRounds;
    temp_a *= player;

    temp_aux = mpc_round * 32;
    temp_a += temp_aux;

    i=0;
    while(i < 20){

        t = (u8)[a + (int)temp_a];

        mem = (u8)[zs + (int) temp_zs];

        if(t != mem){
            (u8)[a + 2] = 2;
            success = 1;
        }

        temp_zs += 1;
        temp_a += 1;
        i += 1;
    }

    // Compare Player2 transcript

    player += 1;
    if(player == 3){
        player = 0;
    }

    // update pos to the next player's ys
    temp_zs += 64;
    temp_zs += 1460;


    temp_a = 32 * mpcRounds;
    temp_a *= player;

    temp_aux = mpc_round * 32;
    temp_a += temp_aux;

    i=0;
    while(i < 20){

        t = (u8)[a + (int)temp_a];

        mem = (u8)[zs + (int) temp_zs];

        if(t != mem){
            (u8)[a + 3] = 3;
            success = 1;
        }

        temp_zs += 1;
        temp_a += 1;
        i += 1;
    }
    
    a_s = a;

    i=0;
    while(i < 160){
        w[(int)i] = 0;
        i += 1;
    }


    // Get Player 1 view.x 

    player = es[(int)mpc_round];

    temp_zs = mpc_round * 3128;
    temp_zs += 32;

    i = 0;
    while(i < 16){

        storage_u32 = (u32)[zs + (int)temp_zs];
        storage_u32 = #BSWAP_32(storage_u32);
        w[(int)i] = storage_u32;

        temp_zs += 4;
        i += 1;
    }


    // Get Player 2 view.x 

    player += 1;
    if(player == 3){
        player = 0;
    }

    temp_zs = mpc_round * 3128;
    temp_zs += 32;
    temp_zs += 64;
    temp_zs += 1480;

    temp_w = 80;

    i = 0;
    while(i < 16){
        storage_u32 = (u32)[zs + (int)temp_zs];
        storage_u32 = #BSWAP_32(storage_u32);
        w[(int)temp_w] = storage_u32;

        temp_zs += 4;
        temp_w += 1;
        i += 1;
    }

    j = 16;
    while(j < 80){
        i = 0;
        while(i < 2){
            pos_w = i;
            pos_w *= 80;
            pos_w += j;

            temp = w_to_temp(temp, w, pos_w);

            n = 1;
            w = mpc_LEFTROTATE_w(temp,n,w,pos_w);

            i += 1;
        }
        j += 1;
    }
    
    /*
        i = 0;
        while(i < 100){
            t = w[u8 (int)i]; 
            (u8)[a + (int)i] = t;

            i += 1;
        }

        j = 80 * 4;
        i = 100;
        while(i < 200){
            t = w[u8 (int)j]; 
            (u8)[a + (int)i] = t;

            j += 1;
            i += 1;
        }
    */
    
    
    // uint32_t a[2] = { hA[0],hA[0] };
    
    storage_u32 = hA[0];
    va[0] = storage_u32;
    va[1] = storage_u32;

    // uint32_t b[2] = { hA[1],hA[1] };

    storage_u32 = hA[1];
    vb[0] = storage_u32;
    vb[1] = storage_u32;

    // uint32_t c[2] = { hA[2],hA[2] };

    storage_u32 = hA[2];
    vc[0] = storage_u32;
    vc[1] = storage_u32;


    // uint32_t d[2] = { hA[3],hA[3] };

    storage_u32 = hA[3];
    vd[0] = storage_u32;
    vd[1] = storage_u32;


    // uint32_t e[2] = { hA[4],hA[4] };

    storage_u32 = hA[4];
    ve[0] = storage_u32;
    ve[1] = storage_u32;
    

    random_player1_s = randomness_player1;
    
    randCount = 0;
    countY = 0;
    i = 0;
    
    while(i < 80){
        i_s = i;
        if(i_s <= 19){

            f = mpc_XOR2(vc,vd,f);
            
            f, randCount, countY, success = mpc_AND_verify(vb, f, f, zs, randomness_p1, randomness_p2, randCount, countY, mpc_round, success, a);
            
            f = mpc_XOR2(vd,f,f);

            k = 0x5A827999;
        } 
        if(i_s > 19){
            if(i_s <= 39) {

                f = mpc_XOR2(vb,vc,f);
                f = mpc_XOR2(vd,f,f);
                k = 0x6ED9EBA1;

            }
            if(i_s > 39){
                if(i_s <= 59) {
                    
                    f, randCount, countY, success = mpc_MAJ_verify(vb, vc, vd, f, zs, randomness_p1, randomness_p2, randCount, countY, mpc_round, success, a);

                    k = 0x8F1BBCDC;

                } else {

                    f = mpc_XOR2(vb,vc,f);
                    f = mpc_XOR2(vd,f,f);
                    k = 0xCA62C1D6;
                }
            }
        }
            
        temp = mpc_LEFTROTATE2_5(va,temp);


        temp, randCount, countY, success = mpc_ADD_verify(f, temp, temp, zs, randomness_p1, randomness_p2, randCount, countY, mpc_round, success, a);
            
        
        temp, randCount, countY, success = mpc_ADD_verify(ve, temp, temp, zs, randomness_p1, randomness_p2, randCount, countY, mpc_round, success, a);

        temp1[0] = k;
        temp1[1] = k;

                 
        temp, randCount, countY, success = mpc_ADD_verify(temp,temp1,temp, zs, randomness_p1, randomness_p2, randCount, countY, mpc_round, success, a);
                
        i = i_s;

        storage_u32 = w[(int)i];
        w_aux[0] = storage_u32;
        j = i;
        j += 80;
        storage_u32 = w[(int)j];
        w_aux[1] = storage_u32;

        temp, randCount, countY, success = mpc_ADD_verify(w_aux,temp,temp, zs, randomness_p1, randomness_p2, randCount, countY, mpc_round, success, a);
        
        
        storage_u32 = vd[0];
        ve[0] = storage_u32;

        storage_u32 = vd[1];
        ve[1] = storage_u32;


        storage_u32 = vc[0];
        vd[0] = storage_u32;

        storage_u32 = vc[1];
        vd[1] = storage_u32;


        n = 30;
        vc = mpc_LEFTROTATE2(vb,n,vc);


        storage_u32 = va[0];
        vb[0] = storage_u32;

        storage_u32 = va[1];
        vb[1] = storage_u32;


        storage_u32 = temp[0];
        va[0] = storage_u32;

        storage_u32 = temp[1];
        va[1] = storage_u32;

        i += 1;
    }

    
    
    storage_u32 = hA[0];
    hHa[0] = storage_u32;
    hHa[1] = storage_u32;

    temp, randCount, countY, success = mpc_ADD_verify(hHa, va, hHa, zs, randomness_p1, randomness_p2, randCount, countY, mpc_round, success, a);


    storage_u32 = hA[1];
    hHa[0] = storage_u32;
    hHa[1] = storage_u32;

    temp, randCount, countY, success = mpc_ADD_verify(hHa, vb, hHa, zs, randomness_p1, randomness_p2, randCount, countY, mpc_round, success, a);


    storage_u32 = hA[2];
    hHa[0] = storage_u32;
    hHa[1] = storage_u32;

    temp, randCount, countY, success = mpc_ADD_verify(hHa, vc, hHa, zs, randomness_p1, randomness_p2, randCount, countY, mpc_round, success, a);


    storage_u32 = hA[3];
    hHa[0] = storage_u32;
    hHa[1] = storage_u32;

    temp, randCount, countY, success = mpc_ADD_verify(hHa, vd, hHa, zs, randomness_p1, randomness_p2, randCount, countY, mpc_round, success, a);


    storage_u32 = hA[4];
    hHa[0] = storage_u32;
    hHa[1] = storage_u32;

    temp, randCount, countY, success = mpc_ADD_verify(hHa, ve, hHa, zs, randomness_p1, randomness_p2, randCount, countY, mpc_round, success, a);

    return success;
}


/***************************************************
*                                                  *
* This function receives arrays and values with    *
* random bytes used by the ZKBoo scheme.           *
*                                                  *
*   - Public Key                                   *
*   - Keys_Shares( Keys[768], Shares[768] )        *
*   - Randomness                                   *
*   - Proofs                                       *
*   - Views( Views_x[3072], Views_y[71040] )       *
*   - A( A_yp[12288], A_h[12288] )                 *
*                                                  *
***************************************************/


/***************************************************
*                                                  *
* This function receives arrays and values with    *
* random bytes used by the ZKBoo scheme.           *
*                                                  *
*   - A( A_yp[12288], A_h[12288] )  (u8)           *
*   - Proofs                                       *
*                                                  *
***************************************************/


export 
fn zkboo_decrypt(reg u64 proofs, reg u64 a, reg u64 randomness_player1, reg u64 randomness_player2, reg u64 success_reg){

    stack u32[8] y;
    stack u64 mpcRounds, success;
    stack u64[136] es;
    stack u32[200192] randomness_p1, randomness_p2;
    reg u64 pos_randomness;

    reg u64 i, j, z;
    reg u8 t;

    mpcRounds = 136;

    i = 0;
    pos_randomness = 0;
    while(i < mpcRounds){

        j = 0;
        while(j < 1472){

            t = (u8)[randomness_player1 + (int) pos_randomness];
            randomness_p1[u8(int) pos_randomness] = t;

            
            t = (u8)[randomness_player2 + (int) pos_randomness];
            randomness_p2[u8(int) pos_randomness] = t; 


            pos_randomness += 1;
            j+= 1;
        }
        
        i += 1;
    }

    
    y = reconstruct(a, y, mpcRounds);
    
    es = H3(y, a, mpcRounds, es);
    
    
    success = 0;
    i = 0;
    while(i < mpcRounds){

        success = verify(a, es, proofs, i, mpcRounds, success, randomness_p1, randomness_p2, randomness_player1);

        i += 1;
    }
    

    (u64)[success_reg + 0] = success; 
}