/****************************
*                           *
*  Sha1 auxiliar functions  *
*                           *
****************************/



inline
fn GETBIT_EXTENDED(stack u32[8] aux, stack u32 bit_idx) -> reg u32 {

	reg u32 selectedBit;
	reg u32 byte_idx, bit_aux;

	
	byte_idx =  bit_idx / 32;
	bit_idx = bit_idx;

	selectedBit = aux[(int) byte_idx];
    byte_idx *= 32;
    bit_idx -= byte_idx;

	selectedBit = selectedBit >> bit_idx; 
	selectedBit &= 0x01;

	selectedBit = 0;

	return  selectedBit;	
}


inline
fn GETBIT_u32(reg u32 x, reg u64 bit_idx) -> reg u32 {

	reg u32 n;

	n = bit_idx;

	while(n > 0){
		x >>= 1;
		n -= 1;
	}

	x &= 0x01; 
	
	return x;	
}

inline
fn getBits(stack u32[3] array_r, stack u32[3] array_c, reg u64 i, reg u64 idx0, reg u64 idx1) -> reg u32, reg u32, reg u32 {

	reg u32 word0, word1, word2;

	word0 = array_r[(int)idx0];
	word1 = array_c[(int)idx1];
	word2 = array_r[(int)idx1];


	word0 = GETBIT_u32(word0, i);
	word1 = GETBIT_u32(word1, i);
	word2 = GETBIT_u32(word2, i);

	return word0, word1, word2;
}

inline
fn SETBIT_u32(stack u32[3] x, reg u64 bit_idx, reg u32 bit, reg u64 idx) -> reg u32[3] {

	reg u32 a;
	reg u32 bit_aux;
	reg u64 aux;

	aux = bit_idx;

	bit_aux = 1;
	bit_aux &= bit;

	a = 1;

	while(aux > 0){
		a <<= 1;
		aux -= 1;
	}
	
	if (bit_aux == 1){
		x[(int)idx] |= a;
	} else{
		a ^= 0xFFFFFFFF;
		x[(int)idx] &= a; 
	}
	
	return x;
}

inline
fn LEFTROTATE(reg u32 x, reg u64 n) -> reg u32 {

	reg u32 aux0, aux1;
	reg u64 n1;

	aux0 = x;
	aux1 = x;

	n1 = n;

	while(n1 > 0){
		aux0 <<= 1;
		n1 -= 1;
	}

	n1 = 32;
	n1 -= n;

	while(n1 > 0){

		aux1 = aux1 >> 1;

		n1 -= 1;
	}

	aux0 |= aux1;
	
	return aux0;
}

inline
fn RIGHTSHIFT(stack u32[15] x, reg u64 i, stack u32[3] z, stack u64 pos_hHa) -> stack u32[3] {
	
	reg u32 x_aux;
	reg u64 j, pos;
	reg u64 i_aux;

	j = 0;
	while(j < 3){

		pos = pos_hHa;
		pos += j;

		x_aux = x[(int)pos];

		i_aux = i;
		while(i_aux > 0){
			x_aux >>= 1;

			i_aux -= 1;
		}
		

		z[(int)i] = x_aux;

		j += 1;
	}

	return z;
}

inline
fn mpc_LEFTROTATE(stack u32[3] x, reg u64 i, stack u32[3] z) -> stack u32[3] {

	reg u32 res;

	res = x[0];
	res = LEFTROTATE(res,i);
	z[0] = res;

	res = x[1];
	res = LEFTROTATE(res,i);
	z[1] = res;

	res = x[2];
	res = LEFTROTATE(res,i);
	z[2] = res;

	return z;
}

inline
fn mpc_LEFTROTATE_w(stack u32[3] x, reg u64 i, stack u32[240] w, reg u64 pos_w) -> stack u32[240] {
	
	reg u32 storage_u32, x_0;
	reg u64 n;

	storage_u32 = x[0];
	n = i;
	while(n > 0){
		storage_u32 <<= 1;
		n -= 1;
	}

	n = 32;
	n -= i;

	x_0 = x[0];

	while(n > 0){
		x_0 >>= 1;

		n -= 1;
	}
	
	storage_u32 |= x_0;

	w[(int)pos_w] = storage_u32;

	return w;
}




inline
fn set_word(reg u64 rs, reg u64 player0, reg u64 player1, stack u64 mpcRounds, reg u64 i, reg u64 pos, reg u64 zs) {

	reg u64 word, aux_word;
	reg u64 mem_pos;


	// We grab the first half of the u64 if pos == 0 else we grab the second half
	

	mem_pos = player0 * mpcRounds;
	mem_pos = (mem_pos + i);
	mem_pos = mem_pos >> 1;        // Divide by 2

	if(pos == 0){
		word = [rs + mem_pos];
		word &= 0xffffffff00000000;
	} else {
		word = [rs + mem_pos];
		word <<= 32;
	}



	mem_pos = player1 * mpcRounds;
	mem_pos = mem_pos + i;
	mem_pos = mem_pos >> 1;        // Divide by 2

	if(pos == 0){
		aux_word = [rs + mem_pos];
		aux_word >>= 32;
	} else {
		aux_word = [rs + mem_pos];
		aux_word &= 0x00000000ffffffff;
	}

	word += aux_word;

	mem_pos = i * 391;
	mem_pos += 390;

	[zs + mem_pos] = word;
}

inline
fn mpc_words(stack u32[3] x, stack u32[3] y, stack u32[3] z, reg u64 i) -> reg u32, reg u32 {


	reg u32 a, b, c;
	reg u32 word_a, word_b;

	a = x[(int)i];
	b = y[(int)i];
	c = z[(int)i];

	word_a = a ^ c;
	word_b = b ^ c;

	return word_a, word_b;
}

inline
fn mpc_words_w(stack u32[240] x, stack u32[3] y, stack u32[3] z, stack u64 pos_w, reg u64 j) -> reg u32, reg u32 {


	reg u32 a, b, c;
	reg u32 word_a, word_b;
	reg u64 pos;

	pos = j * 80;
	pos += pos_w;

	a = x[(int)pos];
	b = y[(int)j];
	c = z[(int)j];

	word_a = a ^ b;
	word_b = c ^ b;

	return word_a, word_b;
}

inline
fn mpc_words_hHa(stack u32[15] x, stack u32[3] y, stack u32[3] z, reg u64 pos_hHa, reg u64 i) -> reg u32, reg u32 {


	reg u32 a, b, c;
	reg u32 word_a, word_b;

	a = x[(int)pos_hHa];
	b = y[(int)i];
	c = z[(int)i];

	word_a = a ^ b;
	word_b = c ^ b;

	return word_a, word_b;
}

inline
fn mpc_words_k(stack u32[3] x, stack u32[3] y, stack u32 k, reg u64 j) -> reg u32, reg u32 {


	reg u32 a, b, c;
	reg u32 word_a, word_b;

	a = x[(int)j];
	b = y[(int)j];
	c = k;

	word_a = a ^ b;
	word_b = c ^ b;

	return word_a, word_b;
}

inline
fn mpc_xor(stack u32[3] x, stack u32[3] y, stack u32[3] z) -> stack u32[3] {
	
	reg u32 aux;

	aux = x[0];
	aux ^= y[0];
	z[0] = aux;

	aux = x[1];
	aux ^= y[1];
	z[1] = aux;

	aux = x[2];
	aux ^= y[2];
	z[2] = aux;

	return z;
}

inline
fn mpc_xor_w(stack u32[240] w, stack u32[3] y, stack u32[3] z, stack u64 pos_w) -> reg u32[3] {
	
	reg u64 pos;
	reg u32[3] z_aux;

	pos = pos_w;
	z_aux[0] = w[(int)pos];
	z_aux[0] ^= y[0];

	pos += 80;
	z_aux[1] = w[(int)pos];
	z_aux[1] ^= y[1];

	pos += 80;
	z_aux[2] = w[(int)pos];
	z_aux[2] ^= y[2];

	z[0] = z_aux[0];
	z[1] = z_aux[1];
	z[2] = z_aux[2];

	return z;
}

inline
fn mpc_xor_k(stack u32 k, stack u32[3] y, stack u32[3] z) -> stack u32[3] {

	reg u32 y_aux;

	y_aux = y[0];
	z[0] = k;
	z[0] ^= y_aux;

	y_aux = y[1];
	z[1] = k;
	z[1] ^= y_aux;

	y_aux = y[2];
	z[2] = k;
	z[2] ^= y_aux;

	return z;
}

inline
fn mpc_xor_hHa(stack u32[15] hHa, stack u32[3] y, stack u32[3] z, reg u64 pos_hHa) -> stack u32[3] {

	reg u64 pos;

	pos = pos_hHa;
	z[0] = hHa[(int)pos];
	z[0] ^= y[(int)0];

	pos += 5;
	z[1] = hHa[(int)pos];
	z[1] ^= y[(int)1];

	pos += 5;
	z[2] = hHa[(int)pos];
	z[2] ^= y[(int)2];

	return z;
}

inline
fn mpc_xor_three(stack u32[3] x, stack u32[3] y, stack u32 k,  reg u64 i) -> stack u32[3] {
	
	reg u32 aux_x, aux_y;

	aux_x = x[(int)i];
	aux_y = y[(int)i];

	aux_x ^= aux_y;
	aux_x ^= k;

	x[(int)i] = aux_x;
	
	return x;
}

inline
fn w_to_temp(stack u32[3] temp, stack u32[240] w, reg u64 pos_w) -> stack u32[3]{

	reg u32 aux0, aux1;

	aux0 = w[(int)pos_w - 3];
	aux1 = w[(int)pos_w - 8];

	temp[0] = aux0;
	temp[0] ^= aux1;


	aux0 = w[(int)pos_w - 14];

	temp[0] ^= aux0;


	aux0 = w[(int)pos_w - 16];

	temp[0] ^= aux0;


	return temp;
}














inline
fn mpc_ADD(stack u32[3] x, stack u32[3] y, stack u32[3] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, reg u64 mpc_idx, stack u64 mpcRounds) -> stack u32[3], reg u64, reg u64, reg u64 {
	
	stack u32[3] c, r;

	stack u32[3] a, b;

	reg u64 idx0, idx1, bit_idx, player;

	reg u64 i;
	reg u64 j;

	reg u32 t, t0, t1, t2;

	reg u32 word, word_a, word_b, word0, word1;

	reg u64 pos_rand, pos_views, temp, temp_pos;

	stack u32[3] aux_y;

	c[0] = 0;
	c[1] = 0;
	c[2] = 0;

	t = y[0];
	aux_y[0] = t;
	t = y[1];
	aux_y[1] = t;
	t = y[2];
	aux_y[2] = t;

	i = 0;
	
	while(i < 3){

		pos_rand = i;
		pos_rand *= 368;
		pos_rand *= mpcRounds;
		pos_rand += randCount;

		r[(int)i] = (u32)[randomness + (int)pos_rand];

		i += 1;
	}
	
	randCount += 1;

	i = 0;
	
	while(i < 31){

		j = 0;
		
		while(j < 3){
			t, t1 = mpc_words(x, y, c, j);

			t = GETBIT_u32(t,i);
			t1 = GETBIT_u32(t1,i);
			
			a[(int)j] = t;
			b[(int)j] = t1;
			j += 1;
		}
			

		// Set first word

		idx0 = 1;
		idx1 = 0;
		
		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[0];
		t &= b[1];
		t ^= t0;

		t0 = a[1];
		t0 &= b[0];
		t ^= t0;

		t0 = a[0];
		t0 &= b[0];
		t ^= t0;

		t ^= t1;
		t ^= t2;

		player = 0;
		bit_idx = i;
		bit_idx += 1;
		c = SETBIT_u32(c, bit_idx, t, player);
		


		// Set second word
		
		idx0 = 2;
		idx1 = 1;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[1];
		t &= b[2];
		t ^= t0;

		t0 = a[2];
		t0 &= b[1];
		t ^= t0;

		t0 = a[1];
		t0 &= b[1];
		t ^= t0;

		t ^= t1;
		t ^= t2;

		player = 1;
		bit_idx = i;
		bit_idx += 1;
		c = SETBIT_u32(c, bit_idx, t, player);
		


		// Set third word

		idx0 = 0;
		idx1 = 2;
		
		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[2];
		t &= b[0];
		t ^= t0;

		t0 = a[0];
		t0 &= b[2];
		t ^= t0;

		t0 = a[2];
		t0 &= b[2];
		t ^= t0;

		t ^= t1;
		t ^= t2;

		player = 2;
		bit_idx = i;
		bit_idx += 1;
		c = SETBIT_u32(c, bit_idx, t, player);

		i += 1;
	}
	
		
	i = 0;
	temp_pos = mpc_idx * 370; // player's current view.y

	while(i < 3){

		t = aux_y[(int)i];
		t ^= x[(int)i];
		t ^= c[(int)i];

		z[(int)i] = t;

		pos_views = i;
		pos_views *= 370;			// Current player views.y
		pos_views *= mpcRounds;
		pos_views += temp_pos;
		pos_views += 6144;				// view.x of the 3 players times mpcRound 

		pos_views += countY;				// current pointer inside view.y

		t = c[(int)i];

		(u32)[views + (int)pos_views] = t;


		i += 1;
	}
	
	countY += 1;

	return z, randCount, countY, views;
}

inline
fn mpc_ADD_W(stack u32[240] w, stack u32[3] y, stack u32[3] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, stack u64 pos_w, reg u64 mpc_idx, stack u64 mpcRounds) -> stack u32[3], reg u64, reg u64, reg u64 {
	
	stack u32[3] c, r, aux, aux2;

	stack u32[3] a, b;

	reg u64 i, j, idx;

	reg u64 idx0, idx1, bit_idx, player;

	reg u64 temp_pos;

	reg u32 t, t0, t1, t2, word_a, word_b;

	reg u64 pos_views, pos_rand, pos_aux, temp_pos;

	c[0] = 0;
	c[1] = 0;
	c[2] = 0;

	idx = 0;

	while(idx < 3){

		pos_rand = idx;
		pos_rand *= 368;
		pos_rand *= mpcRounds;
		pos_rand += randCount;

		r[(int)idx] = (u32)[randomness + (int)pos_rand];

		idx += 1;
	}

	randCount += 1;

	i  = 0;
	
	while(i < 31){

		j = 0;

		while(j < 3){

			t, t1 = mpc_words_w(w, c, y, pos_w, j);

			t = GETBIT_u32(t,i);
			a[(int)j] = t;

			t = GETBIT_u32(t1,i);
			b[(int)j] = t;

			j += 1;
		}
		

		/* Set first word */

		idx0 = 1;
		idx1 = 0;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[0];
		t &= b[1];
		t &= t0;

		t0 = a[1];
		t0 &= b[0];
		t ^= t0;

		t0 = a[0];
		t0 &= b[0];
		t ^= t0;

		t ^= t1;
		t ^= t2;

		player = 0;
		bit_idx = i;
		bit_idx += 1;
		c = SETBIT_u32(c, bit_idx, t, player);


		/* Set second word */

		idx0 = 2;
		idx1 = 1;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		

		t = a[1];
		t &= b[2];
		t &= t0;

		t0 = a[2];
		t0 &= b[1];
		t ^= t0;

		t0 = a[1];
		t0 &= b[1];
		t ^= t0;

		t ^= t1;
		t ^= t2;

		player = 1;
		bit_idx = i;
		bit_idx += 1;
		c = SETBIT_u32(c, bit_idx, t, player);
		

		/* Set third word */

		idx0 = 0;
		idx1 = 2;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		
		t = a[2];
		t &= b[0];
		t &= t0;

		t0 = a[0];
		t0 &= b[2];
		t ^= t0;

		t0 = a[2];
		t0 &= b[2];
		t ^= t0;

		t ^= t1;
		t ^= t2;

		player = 2;
		bit_idx = i;
		bit_idx += 1;
		c = SETBIT_u32(c, bit_idx, t, player);
		
		i += 1;	
	}
	

	idx = 0;
	temp_pos = mpc_idx * 370; // player's current view.y
	
	while(idx < 3){

		pos_aux = 80 * idx;
		pos_aux += pos_w;

		z[(int)i] ^= w[(int)pos_aux];
		z[(int)i] ^= c[(int)idx];
		
		pos_views = idx;
		pos_views *= 370;				// Current player views.y
		pos_views *= mpcRounds;
		pos_views += temp_pos;
		pos_views += 6144;				// view.x of the 3 players times mpcRound 

		pos_views += countY;			// current pointer inside view.y

		t = c[(int)idx];


		(u32)[views + pos_views] = t;

		idx += 1;

	}
	
	countY += 1;

	return y, randCount, countY, views;
}

inline
fn mpc_ADD_K(stack u32[3] x, stack u32 k, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, stack u64 mpcRounds) -> stack u32[3], reg u64, reg u64, reg u64 {

	stack u32[3] c, r, aux, aux2;
	reg u64 bit_idx, idx0, idx1, player;

	inline u32 xor_aux;

	stack u32[3] a, b;
	reg u64 i;
	reg u64 j;
	reg u32 t, t0, t1, t2, word_a, word_b;

	reg u64 pos_rand, pos_views, idx;

	c[0] = 0;
	c[1] = 0;
	c[2] = 0;

	i = 0;

	while(i < 3){

		pos_rand = i;
		pos_rand *= 4;
		pos_rand *= mpcRounds;
		pos_rand += randCount;

		r[(int)i] = (u32)[randomness + (int)pos_rand];

		i += 1;
	}

	randCount += 1;

	i  =0;
	
	while(i < 31){

		bit_idx = i;
		bit_idx += 1;

		j = 0;

		while(j < 3){

			t, t1 = mpc_words_k(x, c, k, j);

			t = GETBIT_u32(t,i);
			a[(int)j] = t;

			t1 = GETBIT_u32(t1,i);
			b[(int)j] = t;

			j += 1;
		}

		/* Set first word */

		idx0 = 1;
		idx1 = 0;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[0];
		t &= b[1];
		t ^= t0;

		t0 = a[1];
		t0 &= b[0];
		t ^= t0;

		t0 = a[0];
		t0 &= b[0];
		t ^= t0;

		t ^= t1;
		t ^= t2;

		player = 0;

		c = SETBIT_u32(c, bit_idx, t, player);



		/* Set second word */

		idx0 = 2;
		idx1 = 1;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[1];
		t &= b[2];
		t ^= t0;

		t0 = a[2];
		t0 &= b[1];
		t ^= t0;

		t0 = a[1];
		t0 &= b[1];
		t ^= t0;

		t ^= t1;
		t ^= t2;

		player = 1;

		c = SETBIT_u32(c, bit_idx, t, player);
		


		/* Set third word */

		idx0 = 0;
		idx1 = 2;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[2];
		t &= b[0];
		t ^= t0;

		t0 = a[0];
		t0 &= b[2];
		t ^= t0;

		t0 = a[2];
		t0 &= b[2];
		t ^= t0;

		t ^= t1;
		t ^= t2;

		player = 2;

		c = SETBIT_u32(c, bit_idx, t, player);

		i += 1;
		
	}

	idx = 0;
	
	while(idx < 3){
		
		x = mpc_xor_three(x,c,k,idx);
		
		pos_views = idx;
		pos_views *= 365;
		pos_views *= mpcRounds;
		pos_views += 768;
		pos_views += countY;

		t = c[(int)idx];

		(u32)[views + pos_views] = t;

		idx += 1;

	}

	countY += 1;

	return x, randCount, countY, views;
}

inline
fn mpc_ADD_hHa(stack u32[15] x, stack u32[3] y, stack u32[15] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, reg u64 pos_hHa, stack u64 mpcRounds) -> stack u32[15], reg u64, reg u64, reg u64 {
	
	stack u32[3] c, r, aux_x;
	reg u64 i, j;
	reg u64 bit_idx, idx0, idx1, player;

	stack u32[3] a, b;

	reg u32 t, t0, t1, t2, word_a, word_b;

	reg u64 pos_rand, pos_views, pos, idx;
	
	c[0] = 0;
	c[1] = 0;
	c[2] = 0;

	t = x[0];
	aux_x[0] = t;
	t = x[1];
	aux_x[1] = t;
	t = x[2];
	aux_x[2] = t;


	i = 0;

	while(i < 3){
		pos_rand = i;
		pos_rand *= 4;
		pos_rand *= mpcRounds;
		pos_rand += randCount;

		r[(int)i] = (u32)[randomness + (int)pos_rand];

		i += 1;
	}

	randCount += 1;

	i = 0;

	while(i < 31){
		
		j = 0;
		
		while(j < 3){

			t, t1 = mpc_words_hHa(x, c, y, pos_hHa, j);

			t = GETBIT_u32(t,i);
			t1 = GETBIT_u32(t1,i);

			a[(int)j] = t;
			b[(int)j] = t;

			j += 1;
		}


		/* Set first word */

		idx0 = 1;
		idx1 = 0;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[0];
		t &= b[1];
		t ^= t0;

		t0 = a[1];
		t0 &= b[0];
		t ^= t0;

		t0 = a[0];
		t0 &= b[0];
		t ^= t0;

		t ^= t1;
		t ^= t2;

		player = 0;
		bit_idx = i;
		bit_idx += 1;
		c = SETBIT_u32(c, bit_idx, t, player);


		/* Set second word */

		idx0 = 2;
		idx1 = 1;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[1];
		t &= b[2];
		t ^= t0;

		t0 = a[2];
		t0 &= b[1];
		t ^= t0;

		t0 = a[1];
		t0 &= b[1];
		t ^= t0;

		t ^= t1;
		t ^= t2;

		player = 1;
		bit_idx = i;
		bit_idx += 1;
		c = SETBIT_u32(c, bit_idx, t, player);
		

		/* Set third word */

		idx0 = 0;
		idx1 = 2;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[2];
		t &= b[0];
		t ^= t0;

		t0 = a[0];
		t0 &= b[2];
		t ^= t0;

		t0 = a[2];
		t0 &= b[2];
		t ^= t0;

		t ^= t1;
		t ^= t2;

		player = 2;
		bit_idx = i;
		bit_idx += 1;
		c = SETBIT_u32(c, bit_idx, t, player);

		i += 1;
	}

	idx = 0;

	while(idx < 3){

		pos = 5 * idx;
		pos += pos_hHa;

		t = aux_x[(int)i];
		t ^= y[(int)i];
		t ^= c[(int)i];

		z[(int)i] = t;
		
		pos_views = idx;
		pos_views *= 365;
		pos_views *= mpcRounds;
		pos_views += 768;
		pos_views += countY;

		t = c[(int)idx];

		(u32)[views + pos_views] = t;

		idx += 1;

	}

	countY += 1;

	return z, randCount, countY, views;
}

inline
fn mpc_AND(stack u32[3] x, stack u32[3] y, stack u32[3] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, reg u64 mpc_idx, stack u64 mpcRounds) -> stack u32[3], reg u64, reg u64, reg u64 {

	stack u32[3] r;
	reg u64 i, pos_randomness, pos_r, pos_views, temp_pos, temp;
	reg u32 temp0, temp1, temp2, z_aux;
	reg u32 aux_y;


	i = 0;

	while(i < 3){

		pos_randomness = i * 4;
		pos_randomness *= mpcRounds;
		pos_randomness += randCount;

		pos_r = i;

		r[(int)pos_r] = (u32)[randomness + (int)pos_randomness];

		i += 1;
	}

	randCount += 1;

	aux_y = y[0];

	temp0 = x[0];
	temp0 &= y[1];

	temp1 = x[1];
	temp1 &= y[0];

	temp2 = x[0];
	temp2 &= y[0];
	
	temp0 ^= temp1;
	temp0 ^= temp2;

	temp1 = r[0];
	temp2 = r[1];

	temp0 ^= temp1;
	temp0 ^= temp2;

	z[u32 0] = temp0;


	temp0 = x[1];
	temp0 &= y[2];

	temp1 = x[2];
	temp1 &= y[1];

	temp2 = x[1];
	temp2 &= y[1];
	
	temp0 ^= temp1;
	temp0 ^= temp2;

	temp1 = r[1];
	temp2 = r[2];

	temp0 ^= temp1;
	temp0 ^= temp2;

	z[u32 1] = temp0;


	temp0 = x[2];
	temp0 &= aux_y;

	temp1 = x[0];
	temp1 &= y[2];

	temp2 = x[2];
	temp2 &= y[2];
	
	temp0 ^= temp1;
	temp0 ^= temp2;

	temp1 = r[2];
	temp2 = r[0];

	temp0 ^= temp1;
	temp0 ^= temp2;

	z[2] = temp0;


	i = 0;
	

	temp_pos = mpc_idx * 370; // player's current view.y

	while(i < 3){

		pos_views = i;
		pos_views *= mpcRounds;			// which player info do we need (player * mpcRounds * view.y_size)
		pos_views *= 370;				
		pos_views += 6144;				// view.x of the 3 players times mpcRounds
		pos_views += temp_pos;			// player's current view.y 

		pos_views += countY;			// current pointer inside view.y

		/* Z => u32[3]; */

		temp0 = z[(int)i];

		(u32)[views + (int)pos_views] = temp0;
		
		i += 1;
	}
	
	countY += 1;

	return z, randCount, countY, views;
}

inline
fn mpc_MAJ(stack u32[3] a, stack u32[3] b, stack u32[3] c, stack u32[3] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, reg u64 mpc_idx, stack u64 mpcRounds) -> stack u32[3], reg u64, reg u64, reg u64 {
	
	stack u32[3] t0, t1;

	t0[0] = 0;
	t0[1] = 0;
	t0[2] = 0;

	t1[0] = 0;
	t1[1] = 0;
	t1[2] = 0;

	t0 = mpc_xor(a, b, t0);
	t1 = mpc_xor(a, c, t1);
	z, randCount, countY, views = mpc_AND(t0, t1, z, randomness, randCount, views, countY, mpc_idx, mpcRounds);
	z = mpc_xor(z, a, z);

	return z, randCount, countY, views;
}

/*************
*            *
*  MPC Sha1  *
*            *
*************/

inline
fn mpc_SHA1(stack u32[24] results, reg u64 inputs, stack u64 numBits, reg u64 randomness, reg u64 views, reg u64 countY, reg u64 mpc_idx, stack u64 mpcRounds) -> stack u32[24], reg u64, reg u64 {


	reg u64 chars;
	reg u64 temp_aux, temp_chunks, temp_inputs, temp_views, temp_w, pos_w, pos_results, pos_hHa;
	reg u64 randCount;
	reg u32 storage_u32, storage_aux;
	reg u8 storage_u8;

	stack u8[192] chunks; 						// u8 chunks[3][64]
	stack u32[240] w; 							// u32 W[80][3];
	


	stack u64 i, j;
	stack u32[3] temp;		 					// uint32_t temp[3]; 
	stack u32[3] t0,t1,t2;						// uint32_t t0[3];

	stack u32[3] a, b, c, d, e, f;
	stack u32 k;

	stack u32[5] hA;
	stack u32[15] hHa;

	reg u64 n;

	hA[0] = 0x67452301;
	hA[1] = 0xEFCDAB89;
	hA[2] = 0x98BADCFE;
	hA[3] = 0x10325476;
	hA[4] = 0xC3D2E1F0;

	temp[0] = 0;
	temp[1] = 0;
	temp[2] = 0;

	randCount = 0;

	/*  numBits is 128; 128 >> 3 = 16 bytes; */

	chars = numBits;
	chars = chars >> 3;
	
	i = 0;
	while(i < 3){

		temp_aux = i * 16;
		temp_aux *= mpcRounds;			// 16 is the size u8 of each share

		temp_inputs = 16;
		temp_inputs *= mpc_idx;		 	// set current player's round share
		temp_inputs += 6144;			// Set the players' shares beguining 
		temp_inputs += temp_aux;		// Add the player's shares beguining

		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[0] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[1] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[2] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[3] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[4] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[5] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[6] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[7] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[8] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[9] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[10] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[11] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[12] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[13] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[14] = storage_u8;

		temp_inputs += 1;
		storage_u8 = (u8)[inputs + (int)temp_inputs];
		chunks[15] = storage_u8;


		temp_chunks = i;
		temp_chunks *= 64;
		temp_chunks += chars;

		chunks[(int)temp_chunks] = 0x80;

		temp_chunks = i * 64;
		temp_chunks += 62;

		n = numBits;
		chunks[(int)temp_chunks] = n;
		chunks[(int)temp_chunks] >>= 8;

		temp_chunks += 1;

		n = numBits;
		chunks[(int)temp_chunks] = n;

		temp_chunks = i * 64;


		temp_aux = i;
		temp_aux *= mpcRounds;
		temp_aux *= 64;					// 8 is the size of each view.x

		temp_views = 64 * mpc_idx;	 	// Set current player's view.x	
		temp_views += temp_aux;

		j = 0;
		while(j < 64){

			storage_u8 = chunks[(int)temp_chunks];

			(u8)[views + (int)temp_views] = storage_u8;

			temp_views += 1;
			temp_chunks += 1;

			j += 1;
		}


		j = 0;
		while(j < 16){

			temp_chunks = i;
			temp_chunks *= 16;
			temp_chunks = j;

			storage_u32 = chunks[u32 (int)temp_chunks];

			temp_w = i;
			temp_w *= 80;
			temp_w += j;

			w[(int) temp_w] = storage_u32;

			j += 1;
		}

		i += 1;
	}
	
	
	j = 16;
	while(j < 80){
		i = 0;
		while(i < 3){
			pos_w = i;
			pos_w *= 80;
			pos_w += j;

			temp = w_to_temp(temp, w, pos_w);

			n = 1;
			w = mpc_LEFTROTATE_w(temp,n,w,pos_w);

			i += 1;
		}
		j += 1;
	}
	
	// uint32_t a[3] = { hA[0],hA[0],hA[0] };
	
	storage_u32 = hA[0];
	a[0] = storage_u32;
	a[1] = storage_u32;
	a[2] = storage_u32;

	// uint32_t b[3] = { hA[1],hA[1],hA[1] };

	storage_u32 = hA[1];
	b[0] = storage_u32;
	b[1] = storage_u32;
	b[2] = storage_u32;

	// uint32_t c[3] = { hA[2],hA[2],hA[2] };

	storage_u32 = hA[2];
	c[0] = storage_u32;
	c[1] = storage_u32;
	c[2] = storage_u32;


	// uint32_t d[3] = { hA[3],hA[3],hA[3] };

	storage_u32 = hA[3];
	d[0] = storage_u32;
	d[1] = storage_u32;
	d[2] = storage_u32;


	// uint32_t e[3] = { hA[4],hA[4],hA[4] };

	storage_u32 = hA[4];
	e[0] = storage_u32;
	e[1] = storage_u32;
	e[2] = storage_u32;


	j = 0;	
	while(j < 80){
		
		if(j <= 19){

			f = mpc_xor(c,d,f);

			f, randCount, countY, views = mpc_AND(b, f, f, randomness, randCount, views, countY, mpc_idx, mpcRounds);

			f = mpc_xor(d,f,f);

			k = 0x5A827999;
		}
		if(j <= 39) {

			mpc_xor(b,c,f);

			mpc_xor(d,f,f);

			k = 0x6ED9EBA1;
		}
		if(j <= 59) {

			f, randCount, countY, views = mpc_MAJ(b,c,d,f,randomness, randCount, views, countY, mpc_idx, mpcRounds);

			k = 0x8F1BBCDC;
		}
		else {
			mpc_xor(b,c,f);

			mpc_xor(d,f,f);

			k = 0xCA62C1D6;
		}
		
		n = 5;

		temp[0] = 0;
		temp[1] = 0;
		temp[2] = 0;

		temp = mpc_LEFTROTATE(a,n,temp);

		temp, randCount, countY, views = mpc_ADD(f, temp, temp, randomness, randCount, views, countY, mpc_idx, mpcRounds);
		temp, randCount, countY, views = mpc_ADD(e, temp, temp, randomness, randCount, views, countY, mpc_idx, mpcRounds);
		temp, randCount, countY, views = mpc_ADD_K(temp, k, randomness, randCount, views, countY, mpcRounds);
		temp, randCount, countY, views = mpc_ADD_W(w, temp, temp, randomness, randCount, views, countY, j, mpc_idx, mpcRounds);
		


		storage_u32 = d[0];
		e[0] = storage_u32;

		storage_u32 = d[1];
		e[1] = storage_u32;

		storage_u32 = d[2];
		e[2] = storage_u32;



		storage_u32 = c[0];
		d[0] = storage_u32;

		storage_u32 = c[1];
		d[1] = storage_u32;

		storage_u32 = c[2];
		d[2] = storage_u32;


		n = 30;
		c = mpc_LEFTROTATE(b, n, c);


		storage_u32 = a[0];
		b[0] = storage_u32;

		storage_u32 = a[1];
		b[1] = storage_u32;

		storage_u32 = a[2];
		b[2] = storage_u32;



		storage_u32 = temp[0];
		a[0] = storage_u32;

		storage_u32 = temp[1];
		a[1] = storage_u32;

		storage_u32 = temp[2];
		a[2] = storage_u32;
		

		j += 1;
	}
	
	i = 0;

	storage_u32 = hA[0];
	hHa[0] = storage_u32;
	storage_u32 = hA[0];
	hHa[1] = storage_u32;
	storage_u32 = hA[0];
	hHa[2] = storage_u32;

	storage_u32 = hA[1];
	hHa[3] = storage_u32;
	storage_u32 = hA[1];
	hHa[4] = storage_u32;
	storage_u32 = hA[1];
	hHa[5] = storage_u32;

	storage_u32 = hA[2];
	hHa[6] = storage_u32;
	storage_u32 = hA[2];
	hHa[7] = storage_u32;
	storage_u32 = hA[2];
	hHa[8] = storage_u32;

	storage_u32 = hA[3];
	hHa[9] = storage_u32;
	storage_u32 = hA[3];
	hHa[10] = storage_u32;
	storage_u32 = hA[3];
	hHa[11] = storage_u32;

	storage_u32 = hA[4];
	hHa[12] = storage_u32;
	storage_u32 = hA[4];
	hHa[13] = storage_u32;
	storage_u32 = hA[4];
	hHa[14] = storage_u32;
	
	n = 0;
	hHa, randCount, countY, views = mpc_ADD_hHa(hHa, a, hHa, randomness, randCount, views, countY, n, mpcRounds);

	n = 1;
	hHa, randCount, countY, views = mpc_ADD_hHa(hHa, b, hHa, randomness, randCount, views, countY, n, mpcRounds);

	n = 2;
	hHa, randCount, countY, views = mpc_ADD_hHa(hHa, c, hHa, randomness, randCount, views, countY, n, mpcRounds);

	n = 3;
	hHa, randCount, countY, views = mpc_ADD_hHa(hHa, d, hHa, randomness, randCount, views, countY, n, mpcRounds);

	n = 4;
	hHa, randCount, countY, views = mpc_ADD_hHa(hHa, e, hHa, randomness, randCount, views, countY, n, mpcRounds);
	
	i = 0;
	while(i < 5){

		n = 24;
		t0 = RIGHTSHIFT(hHa,n,t0,i);

		n = 16;
		t1 = RIGHTSHIFT(hHa,n,t1,i);

		n = 8;
		t2 = RIGHTSHIFT(hHa,n,t2,i);


		pos_results = i;
		pos_hHa = i;
		pos_hHa *= 3;

		storage_u32 = t0[0];
		storage_u32 &= 0xFF000000;

		storage_aux = t1[0];
		storage_aux &= 0x00FF0000;
		storage_u32 |= storage_aux;

		storage_aux = t2[0];
		storage_aux &= 0x0000FF00;
		storage_u32 |= storage_aux;

		storage_aux = hHa[(int)pos_hHa];
		storage_aux &= 0x000000FF;
		storage_u32 |= storage_aux;

		results[(int)pos_results] = storage_u32;



		pos_results += 8;
		pos_hHa += 1;

		storage_u32 = t0[1];
		storage_u32 &= 0xFF000000;

		storage_aux = t1[1];
		storage_aux &= 0x00FF0000;
		storage_u32 |= storage_aux;

		storage_aux = t2[1];
		storage_aux &= 0x0000FF00;
		storage_u32 |= storage_aux;

		storage_aux = hHa[(int)pos_hHa];
		storage_aux &= 0x000000FF;
		storage_u32 |= storage_aux;

		results[(int)pos_results] = storage_u32;



		pos_results += 8;
		pos_hHa += 1;

		storage_u32 = t0[2];
		storage_u32 &= 0xFF000000;

		storage_aux = t1[2];
		storage_aux &= 0x00FF0000;
		storage_u32 |= storage_aux;

		storage_aux = t2[2];
		storage_aux &= 0x0000FF00;
		storage_u32 |= storage_aux;

		storage_aux = hHa[(int)pos_hHa];
		storage_aux &= 0x000000FF;
		storage_u32 |= storage_aux;

		results[(int)pos_results] = storage_u32;
		
		i += 1;
	}
	

	return results, views, countY;
}

/***********************
*                      *
*  Commits & mpc_Sha1  *
*                      *
***********************/

inline
fn commits(stack u64 numBits, reg u64 keys_shares, reg u64 randomness, reg u64 views, reg u64 countY, reg u64 a, reg u64 mpc_idx, stack u64 mpcRounds) -> reg u64, reg u64, reg u64 {

	stack u32[24] hashes;
	
	stack u32[5] result1, result2, result3;

	reg u64 i, j, temp_views, temp, a_temp;
	reg u32 var;
	
	hashes, views, countY = mpc_SHA1(hashes, keys_shares, numBits, randomness, views, countY, mpc_idx, mpcRounds);

	j = 0;
	while(j <  5){

		i = 0;
		while(i < 3){
			temp_views = 370;
			temp_views *= mpcRounds;
			temp_views *= i;
			temp_views += countY;
			temp_views += 768;

			temp = i;
			temp *= 8;
			temp += j;

			var = hashes[(int) temp];

			(u32)[views + (int)temp_views] = var;

			i += 1;
		}

		countY += 1;
		j += 1;
	}

	temp = 370;
	temp *= mpcRounds;

	j = 5;
	while(j>0){

		a_temp = mpc_idx;
		a_temp *= 8;
		a_temp += j;

		temp_views = countY;
		temp_views += 768;
		temp_views -= j;

		(u32)[a + (int)a_temp] = (u32)[views + (int)temp_views];

		temp_views = countY;
		temp_views += 768;
		temp_views += temp;
		temp_views -= j;

		a_temp += 1024;

		(u32)[a + (int)a_temp] = (u32)[views + (int)temp_views];

		temp_views = countY;
		temp_views += 768;
		temp_views += temp;
		temp_views += temp;
		temp_views -= j;

		a_temp += 1024;

		(u32)[a + (int)a_temp] = (u32)[views + (int)temp_views];

		j -= 1;
	}

	return views, countY, a;
}















/******************************
*                             *
*  SHA256 auxiliar functions  *
*                             *
******************************/


fn ROTLEFT(reg u32 a, reg u8 b) -> reg u32{

	a = ((a << b) | (a >> (32 - b)));
	return a;
} 

fn ROTRIGHT(reg u32 a, reg u8 b) -> stack u32 {

	a = ((a >> b) | (a << (32 - b)));
	return a;
}

inline
fn ROTRIGHT_ep(reg u32 a, reg u8 b, reg u32 res) -> stack u32 {

    a = ((a >> b) | (a << (32 - b)));
    res ^= a;

    return res;
}

inline
fn EP0(reg u32 x, reg u32 res) -> reg u32{

    reg u32 aux, aux0, aux1, aux2;
    reg u8 b;

    aux = x;

    res = 0;
    b = 2;
    res = ROTRIGHT_ep(aux,b,res);

    b = 13;
    res = ROTRIGHT_ep(aux,b,res);

    b = 22;
    res = ROTRIGHT_ep(aux,b,res);

    return res;
}

inline
fn EP1(reg u32 x, reg u32 res) -> reg u32{

    reg u32 aux, aux0, aux1, aux2;
    reg u8 b;

    aux = x;

    res = 0;
    b = 6;
    res = ROTRIGHT_ep(aux,b,res);

    b = 11;
    res = ROTRIGHT_ep(aux,b,res);
    
    b = 25;
    res = ROTRIGHT_ep(aux,b,res);


    return res;
} 

inline
fn ROTRIGHT_sig(reg u32 a, reg u8 b, reg u32 aux) -> stack u32 {

    aux = ((a >> b) | (a << (32 - b)));
    return aux;
}

inline
fn SIG0(reg u32 x) -> reg u32 {

    reg u32 aux0, aux1, aux2;
    reg u8 b;


    b = 7;
    aux0 = ROTRIGHT_sig(x,b,aux0);

    b=18;
    aux1 = ROTRIGHT_sig(x,b,aux1);

    aux2 = x >> 3;

    x = aux0 ^ aux1 ^ aux2;

    return x;
}

inline
fn SIG1(reg u32 x) -> reg u32{
    reg u32 aux, aux0, aux1, aux2;
    reg u8 b;

    b = 17;
    aux0 = ROTRIGHT_sig(x,b,aux0);
    
    b = 19;
    aux1 = ROTRIGHT_sig(x,b,aux1);

    aux2 = (x >> 10); 

    x = aux0 ^ aux1 ^ aux2;

    return x;
}

inline
fn CH(stack u32 x, stack u32 y, stack u32 z) -> reg u32{
    
    reg u32 t0, t1;

    t0 = x;
    t0 &= y;

    t1 = x;
    t1 ^= 0xFFFFFFFF;
    t1 &= z;

    t0 ^= t1;

    return t0;
}

inline
fn MAJ(stack u32 x, stack u32 y, stack u32 z) -> reg u32{

    stack u32 t0, t1;

    t0 = x;
    t0 &= y;

    t1 = x;
    t1 &= z;
    t0 ^= t1;

    t1 = y;
    t1 &= z;
    t0 ^= t1;

    return t0;
}

inline
fn initializeK(stack u32[64] k) -> stack u32[64]{
    k[0] = 0x428a2f98;
    k[1] = 0x71374491;
    k[2] = 0xb5c0fbcf;
    k[3] = 0xe9b5dba5;
    k[4] = 0x3956c25b;
    k[5] = 0x59f111f1;
    k[6] = 0x923f82a4;
    k[7] = 0xab1c5ed5;
    k[8] = 0xd807aa98;
    k[9] = 0x12835b01;
    k[10] = 0x243185be;
    k[11] = 0x550c7dc3;
    k[12] = 0x72be5d74;
    k[13] = 0x80deb1fe;
    k[14] = 0x9bdc06a7;
    k[15] = 0xc19bf174;
    k[16] = 0xe49b69c1;
    k[17] = 0xefbe4786;
    k[18] = 0x0fc19dc6;
    k[19] = 0x240ca1cc;
    k[20] = 0x2de92c6f;
    k[21] = 0x4a7484aa;
    k[22] = 0x5cb0a9dc;
    k[23] = 0x76f988da;
    k[24] = 0x983e5152;
    k[25] = 0xa831c66d;
    k[26] = 0xb00327c8;
    k[27] = 0xbf597fc7;
    k[28] = 0xc6e00bf3;
    k[29] = 0xd5a79147;
    k[30] = 0x06ca6351;
    k[31] = 0x14292967;
    k[32] = 0x27b70a85;
    k[33] = 0x2e1b2138;
    k[34] = 0x4d2c6dfc;
    k[35] = 0x53380d13;
    k[36] = 0x650a7354;
    k[37] = 0x766a0abb;
    k[38] = 0x81c2c92e;
    k[39] = 0x92722c85;
    k[40] = 0xa2bfe8a1;
    k[41] = 0xa81a664b;
    k[42] = 0xc24b8b70;
    k[43] = 0xc76c51a3;
    k[44] = 0xd192e819;
    k[45] = 0xd6990624;
    k[46] = 0xf40e3585;
    k[47] = 0x106aa070;
    k[48] = 0x19a4c116;
    k[49] = 0x1e376c08;
    k[50] = 0x2748774c;
    k[51] = 0x34b0bcb5;
    k[52] = 0x391c0cb3;
    k[53] = 0x4ed8aa4a;
    k[54] = 0x5b9cca4f;
    k[55] = 0x682e6ff3;
    k[56] = 0x748f82ee;
    k[57] = 0x78a5636f;
    k[58] = 0x84c87814;
    k[59] = 0x8cc70208;
    k[60] = 0x90befffa;
    k[61] = 0xa4506ceb;
    k[62] = 0xbef9a3f7;
    k[63] = 0xc67178f2;

    return k;
}

inline
fn sha256_transform(stack u32[8] ctx_state, stack u32[16] ctx_data)
{
    reg u32 a, b, c, d, e, f, g, h, t1, t2, temp;

    stack u32[64] m;

    reg u32 sig0, sig1;

    reg u64 i, j;

    inline int idx;

    stack u32[64] k;
    k = initializeK(k);

    j = 0;
    i = 0;
    while(i < 16){

        m[(int)j] = (ctx_data[(int)j]);
        j += 1;
        i += 1;
    }

    while(i < 64){
        sig0 = m[(int)i - 15];
        sig1 = m[(int)i - 2];

        sig0 = SIG0(sig0);
        sig1 = SIG1(sig1);
        
        m[(int)i] = sig1;
        temp = m[(int)i - 7];
        m[(int)i] += temp;
        m[(int)i] += sig0;
        temp = m[(int)i - 16];
        m[(int)i] += temp;

        i += 1;
    } 

    a = ctx_state[0];
    b = ctx_state[1];
    c = ctx_state[2];
    d = ctx_state[3];
    e = ctx_state[4];
    f = ctx_state[5];
    g = ctx_state[6];
    h = ctx_state[7];
    
    i = 0;
    while(i < 64){

        sig0 = EP1(e,sig0);
        sig1 = CH(e,f,g);

        t1 = h;
        t1 += sig0;
        t1 += sig1;
        t1 += k[(int)i];
        t1 += m[(int)i];

        sig0 = EP0(a,sig0);
        sig1 = MAJ(a,b,c);

        t2 = sig0 + sig1;

        h = g;
        g = f;
        f = e;
        e = d;
        e += t1;
        d = c;
        c = b;
        b = a;
        a = t1;
        a += t2;

        i += 1;
    }

    ctx_state[0] += a;
    ctx_state[1] += b;
    ctx_state[2] += c;
    ctx_state[3] += d;
    ctx_state[4] += e;
    ctx_state[5] += f;
    ctx_state[6] += g;
    ctx_state[7] += h;
}

inline
fn sha256_init(stack u32[8] ctx_state, stack u32 ctx_datalen, stack u64 ctx_bitlen) 
{
    ctx_datalen = 0;
    ctx_bitlen = 0;
    ctx_state[0] = 0x6a09e667;
    ctx_state[1] = 0xbb67ae85;
    ctx_state[2] = 0x3c6ef372;
    ctx_state[3] = 0xa54ff53a;
    ctx_state[4] = 0x510e527f;
    ctx_state[5] = 0x9b05688c;
    ctx_state[6] = 0x1f83d9ab;
    ctx_state[7] = 0x5be0cd19;
}

inline
fn sha256_update1(stack u32[8] ctx_state, stack u32[16] ctx_data, stack u64 ctx_datalen, stack u64 ctx_bitlen, stack u32[4] data, inline int len) -> stack u64, stack u64
{
    reg u64 i;

    i = 0;

    while(i < len){

    	ctx_data[(int)ctx_datalen] = data[(int)i];
    	ctx_datalen += 1;

    	if(ctx_datalen == 16){
    		sha256_transform(ctx_state, ctx_data);
    		ctx_bitlen += 512;
    		ctx_datalen = 0;
    	}

    	i += 1;
    }

    return ctx_datalen, ctx_bitlen;
}

inline
fn sha256_update2(stack u32[8] ctx_state, stack u32[16] ctx_data, stack u64 ctx_datalen, stack u64 ctx_bitlen, stack u32[16] data, inline int len) -> stack u64, stack u64
{
    reg u64 i;

    i = 0;

    while(i < len){

    	ctx_data[(int)ctx_datalen] = data[(int)i];
    	ctx_datalen += 1;

    	if(ctx_datalen == 16){
    		sha256_transform(ctx_state, ctx_data);
    		ctx_bitlen += 512;
    		ctx_datalen = 0;
    	}
    	i += 1;
    }
    return ctx_datalen, ctx_bitlen;
}

inline
fn sha256_update3(stack u32[8] ctx_state, stack u32[16] ctx_data, stack u64 ctx_datalen, stack u64 ctx_bitlen, stack u32[370] data, inline int len) -> stack u64, stack u64
{
    reg u64 i;

    i = 0;

    while(i < len){

    	ctx_data[(int)ctx_datalen] = data[(int)i];
    	ctx_datalen += 1;

    	if(ctx_datalen == 16){
    		sha256_transform(ctx_state, ctx_data);
    		ctx_bitlen += 512;
    		ctx_datalen = 0;
    	}
    	i += 1;
    }
    return ctx_datalen, ctx_bitlen;
}

inline
fn sha256_update4(stack u32[8] ctx_state, stack u32[16] ctx_data, stack u64 ctx_datalen, stack u64 ctx_bitlen, stack u32[3] data, inline int len) -> stack u64, stack u64
{
    reg u64 i;

    i = 0;

    while( i < len){

        ctx_data[(int)ctx_datalen] = data[(int)i];
        ctx_datalen += 1;

        if(ctx_datalen == 16){
            sha256_transform(ctx_state, ctx_data);
            ctx_bitlen += 512;
            ctx_datalen = 0;
        }

        i += 1;
    }
    return ctx_datalen, ctx_bitlen;
}


inline
fn sha256_final1(stack u32[8] ctx_state, stack u32[16] ctx_data, stack u64 ctx_datalen, stack u64 ctx_bitlen, reg u64 a, reg u64 round_idx, reg u64 player_idx, stack u64 mpcRounds)
{
    reg u64 i, temp;
    reg u32 value;
    reg u64 addrs;

    i = ctx_datalen;


    // Pad whatever data is left in the buffer.
    if (ctx_datalen < 14) {
        ctx_data[(int)i] = 0x80000000;
        i += 1;
        while (i < 14){
            ctx_data[(int)i] = 0x00000000;
            i += 1;
        }
    }
    else {
        ctx_data[(int)i] = 0x80000000;
        i += 1;
        while (i < 16){
            ctx_data[(int)i] = 0x00000000;
            i += 1;
        }
        sha256_transform(ctx_state, ctx_data);

        i = 0;

        while(i < 14){
        	ctx_data[(int)i] = 0x00000000;
        	i += 1;
        }
    }

    // Append to the padding the total message's length in bits and transform.
    
    ctx_bitlen += ctx_datalen * 8;

    temp = ctx_bitlen;
    temp += ctx_bitlen >> 8;
    temp += ctx_bitlen >> 16;
    temp += ctx_bitlen >> 24;
    temp += ctx_bitlen >> 32;
    temp += ctx_bitlen >> 40;
    temp += ctx_bitlen >> 48;
    temp += ctx_bitlen >> 56;

    ctx_data[u64 7] = temp;
    
    sha256_transform(ctx_state, ctx_data);

    // Since this implementation uses little endian byte ordering and SHA uses big endian,
    // reverse all the bytes when copying the final state to the output hash.
    
    temp = player_idx;
    temp *= 8;
    temp *= mpcRounds;

    i = 0;
    while(i < 8){

        addrs = round_idx;
        addrs *= 4;
        addrs += temp;
        addrs += 384; 
        addrs += i;

        value = ctx_state[(int)i];

        (u32)[a + (int)addrs] = value;

        i += 1;
    } 
}

/*****************
*                *
*   H - SHA256   *
*                *
*****************/

inline
fn H(reg u64 keys_shares, reg u64 views, reg u64 rs, reg u64 a, stack u64 mpcRounds) -> reg u64 {

	reg u64 i, j, z, temp, keys_addrs, views_addrs, rs_addrs;

	stack u64 ctx_datalen;
	stack u64 ctx_bitlen;
	stack u32[8] ctx_state;
    stack u32[16] ctx_data;

	stack u32[4] keys_aux;
	stack u32[16] viewsX_aux;
	stack u32[370] viewsY_aux;
	stack u32[3] rs_aux;

	reg u8 data;
	reg u8 len;

	i = 0;

	while(i < mpcRounds){

		j = 0;

		while(j < 3){

			sha256_init(ctx_state, ctx_datalen, ctx_bitlen);

            temp = j;
            temp *= 4;
            temp *= mpcRounds;
			
            z = 0;
			while(z < 4){
                keys_addrs = i;
                keys_addrs *= 4;
                keys_addrs += temp;

				keys_aux[(int)z] = [keys_shares + (int)keys_addrs];
                
                z += 1;
            }

            temp = j;
            temp *= 16;
            temp *= mpcRounds;

            z = 0;
            while(z < 16){

                views_addrs = i;
                views_addrs *= 16;
                views_addrs += temp;
                views_addrs += z;

				viewsX_aux[(int)z] = [views + (int)views_addrs];

                z += 1;
            }

            temp = j;
            temp *= 3;
            temp*= mpcRounds;

            z = 0;
            while(z < 3){

                rs_addrs = i;
                rs_addrs *= 3;
                rs_addrs += temp;
                rs_addrs += z;

				rs_aux[(int)z] = [rs + (int)rs_addrs];

				z += 1;
			}

            temp = j;
            temp *= 370;
            temp *= mpcRounds;

			z = 0; 
			while(z < 370){

                views_addrs = i;
                views_addrs *= 370;
                views_addrs += temp;
                views_addrs += 6144;
                views_addrs += z;

				viewsY_aux[(int)z] = [views + (int) views_addrs];
				z += 1;
			} 

			ctx_datalen, ctx_bitlen = sha256_update1(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, keys_aux, 4);
			ctx_datalen, ctx_bitlen = sha256_update2(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, viewsX_aux, 16);
			ctx_datalen, ctx_bitlen = sha256_update3(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, viewsY_aux, 370);
			ctx_datalen, ctx_bitlen = sha256_update4(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, rs_aux, 3);
			sha256_final1(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, a, i, j, mpcRounds);

			j += 1;
		}

		i += 1;
	}

	return a;
}







inline
fn sha256_update5(stack u32[8] ctx_state, stack u32[16] ctx_data, stack u64 ctx_datalen, stack u64 ctx_bitlen, stack u32[8] data, inline int len) -> stack u64, stack u64
{
    reg u64 i;

    i = 0;
    while(i < len){

    	ctx_data[(int)ctx_datalen] = data[(int)i];
    	ctx_datalen += 1;

    	if(ctx_datalen == 16){
    		sha256_transform(ctx_state, ctx_data);
    		ctx_bitlen += 512;
    		ctx_datalen = 0;
    	}

    	i += 1;
    }

    return ctx_datalen, ctx_bitlen;
}

inline
fn sha256_update6(stack u32[8] ctx_state, stack u32[16] ctx_data, stack u64 ctx_datalen, stack u64 ctx_bitlen, reg u64 data, inline int len) -> stack u64, stack u64
{
    reg u64 i;

    i = 0;
    while(i < len){

        ctx_data[(int)ctx_datalen] = (u32)[data + i];
        ctx_datalen += 1;

        if(ctx_datalen == 16){
            sha256_transform(ctx_state, ctx_data);
            ctx_bitlen += 512;
            ctx_datalen = 0;
        }

        i += 1;
    }

    return ctx_datalen, ctx_bitlen;
}

inline
fn sha256_update7(stack u32[8] ctx_state, stack u32[16] ctx_data, stack u64 ctx_datalen, stack u64 ctx_bitlen, reg u64 data, inline int len) -> stack u64, stack u64
{
    reg u64 i;

    i = 0;
    while(i < len){

        ctx_data[(int)ctx_datalen] = (u32)[data + 384 + i];
        ctx_datalen += 1;

        if(ctx_datalen == 16){
            sha256_transform(ctx_state, ctx_data);
            ctx_bitlen += 512;
            ctx_datalen = 0;
        }

        i += 1;
    }

    return ctx_datalen, ctx_bitlen;
}

inline
fn sha256_final2(stack u32[8] ctx_state, stack u32[16] ctx_data, stack u64 ctx_datalen, stack u64 ctx_bitlen, stack u32[8] hash) -> stack u32[8]
{
    reg u64 i, temp;
    reg u64 j;
    reg u32 t;

    i = ctx_datalen;

    // Pad whatever data is left in the buffer.
    if (ctx_datalen < 14) {
        ctx_data[(int)i] = 0x80000000;
        i += 1;
        while (i < 14){
            ctx_data[(int)i] = 0x00000000;
            i += 1;
        }
    }
    else {
        ctx_data[(int)i] = 0x80000000;
        i += 1;
        while (i < 16){
            ctx_data[(int)i] = 0x00000000;
            i += 1;
        }
        sha256_transform(ctx_state, ctx_data);
        i = 0;
        while(i < 14){
        	ctx_data[(int)i] = 0x00000000;
        	i += 1;
        }
    }

    // Append to the padding the total message's length in bits and transform.

    ctx_bitlen += ctx_datalen * 8;

    temp = ctx_bitlen;
    temp += ctx_bitlen >> 8;
    temp += ctx_bitlen >> 16;
    temp += ctx_bitlen >> 24;
    temp += ctx_bitlen >> 32;
    temp += ctx_bitlen >> 40;
    temp += ctx_bitlen >> 48;
    temp += ctx_bitlen >> 56;

    ctx_data[u64 7] = temp;
    
    sha256_transform(ctx_state, ctx_data);

    // Since this implementation uses little endian byte ordering and SHA uses big endian,
    // reverse all the bytes when copying the final state to the output hash.

    i = 0;
    while(i < 8){

        t = ctx_state[(int)i];
    	hash[(int)i] = t;
        i += 1;

    }

    return hash;
}

/*****************
*                *
*       H3       *
*                *
*****************/

inline
fn H3(stack u32[8] y, reg u64 a, stack u64 s, stack u64[128] es) -> stack u64[128] {


	stack u32[8] hash; // unsigned char hash[SHA256_DIGEST_LENGTH];
	
	stack u32[16] ctx_data;
	stack u64 ctx_datalen;
	stack u64 ctx_bitlen;
	stack u32[8] ctx_state;

	reg u64 i, es_aux;
	stack u32 bitTracker;
	reg u32 b1, b2, bitTracker_aux;


	
	sha256_init(ctx_state, ctx_datalen, ctx_bitlen);

	ctx_datalen, ctx_bitlen = sha256_update5(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, y, 20);

	ctx_datalen, ctx_bitlen = sha256_update6(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, a, 3072);

	ctx_datalen, ctx_bitlen = sha256_update7(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, a, 3072);

	hash = sha256_final2(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash);

	
	//Pick bits from hash
	i = 0;
	bitTracker = 0;
    
	while(i < s) {
		
		if(bitTracker >= 256) { //Generate new hash
			sha256_init(ctx_state, ctx_datalen, ctx_bitlen);
			ctx_datalen, ctx_bitlen = sha256_update5(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash, 32);
			hash = sha256_final2(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash);
			bitTracker = 0;
		}
		
		b1 = GETBIT_EXTENDED(hash, bitTracker);
		bitTracker_aux = bitTracker;
		bitTracker_aux += 1;
		bitTracker = bitTracker_aux;
		b2 = GETBIT_EXTENDED(hash, bitTracker);
		
		
		if(b1 == 0) {
			if(b2 == 0) {
				es_aux = 0;
				es[(int)i] = es_aux;
				bitTracker_aux = bitTracker;
				bitTracker_aux += 1;
				bitTracker = bitTracker_aux;
				i += 1;
			} else {
				es_aux = 1;
				es[(int)i] = es_aux;
				bitTracker_aux = bitTracker;
				bitTracker_aux += 1;
				bitTracker = bitTracker_aux;
				i += 1;
			}
		} else {
			if(b2 == 0) {
				es_aux = 2;
				es[(int)i] = es_aux;
				bitTracker_aux = bitTracker;
				bitTracker_aux += 1;
				bitTracker = bitTracker_aux;
				i += 1;
			} else {
				bitTracker_aux = bitTracker;
				bitTracker_aux += 1;
				bitTracker = bitTracker_aux;
			}
		}
	}
	
	
	return es;
}

/*****************
*                *
*     Prove      *
*                *
*****************/

inline
fn prove(stack u64[128] es, reg u64 keys_shares, reg u64 rs, reg u64 views, reg u64 zs, stack u64 mpcRounds) {

	reg u64 i, j, player0, player1;
	reg u64 temp_zs, temp_keys_shares, x_player_view_offset, y_player_view_offset, temp_views, temp_aux;
	reg u64 pos0, pos1, round;

	pos0 = 0;
	pos1 = 1;
	i = 0;

	while(i < mpcRounds){

		player0 = es[(int)i];
		player1 = es[(int)i];
		player1 += 1;

		//player1 = player1 % 3;
		if(player1 == 3){
			player1 = 0;
		}


		/* Copy both players keys */

		temp_aux = i * 2;

		j = 0;
		while(j < 2){

			temp_zs = i * 391;					// i * 391 + 0 + j
			temp_zs += j;

			temp_keys_shares = player0 * 2;
			temp_keys_shares *= mpcRounds;
			temp_keys_shares += temp_aux;
			temp_keys_shares += j;

			[zs + temp_zs] = [keys_shares + temp_keys_shares];


			temp_zs += 2;						// i * 391 + 2 + j

			temp_keys_shares = player1 * 2;
			temp_keys_shares *= mpcRounds;
			temp_keys_shares += temp_aux;
			temp_keys_shares += j;

			[zs + temp_zs] = [keys_shares + temp_keys_shares];

			j += 1;
		}
		
		/* Copy player 1 view */


		x_player_view_offset = mpcRounds * 8;
		x_player_view_offset *= player0;


		temp_aux = 185 * 128;
		temp_aux = temp_aux * player0;

		y_player_view_offset = 3072;	 	// total views_x of the three players
		y_player_view_offset += temp_aux;	// offset to player0 views_y

		j = 0;
		while(j < 8){

			temp_zs = i * 391; 						// i * 391 + 4 + j
			temp_zs += 4;
			temp_zs += j;

			temp_views = i * 8;					// set current view_x
			temp_views += x_player_view_offset;
			temp_views += j;

			[zs + temp_zs] = [views + temp_views];
			j += 1;
		}

		j = 0;
		while(j < 185){
			temp_zs = i * 391; 						// i * 391 + 12 + j
			temp_zs += 12;
			temp_zs += j;

			temp_views = i * 185;
			temp_views += y_player_view_offset;
			temp_views += j;

			[zs + temp_zs] = [views + temp_views];
			j += 1;
		}

		/* Copy player 2 view */

		x_player_view_offset = mpcRounds * 8;
		x_player_view_offset *= player1;


		temp_aux = 185 * 128;
		temp_aux = temp_aux * player1;

		y_player_view_offset = 3072;	 	// total views_x of the three players
		y_player_view_offset += temp_aux;	// offset to player1 views_y


		j = 0;
		while( j < 8){
			temp_zs = i * 391; 						// i * 391 + 197 + j
			temp_zs += 197;
			temp_zs += j;

			temp_views = i * 8;
			temp_views += x_player_view_offset;
			temp_views += j;


			[zs + temp_zs] = [views + temp_views];
			j += 1;
		}

		j = 0;
		while(j < 185){
			temp_zs = i * 391; 						// i * 391 + 205 + j
			temp_zs += 205;
			temp_zs += j;

			temp_views = i * 185;
			temp_views += y_player_view_offset;
			temp_views += j;


			[zs + temp_zs] = [views + temp_views];
			j += 1;
		}

		round = i;
		round &= pos1; // 1 if i is impar and 0 otherwise

		if(round == 0){
			set_word(rs, player0, player1, mpcRounds, i, pos0, zs);
		}
		else{
			set_word(rs, player0, player1, mpcRounds, i, pos1, zs);
		}

		i += 1;
	}
}





/*********************************************************************
*                                                                    *
*     This ZKBoo version is running on 128 rounds. If you decide to  *
*   increase the number of rounds, please multiply the stack arrays  *
*   needed in it by the number of MPC rounds divided by 128.         *
*                                                                    *
*********************************************************************/

inline
fn preparationZKBoo(reg u64 rs, reg u64 randomValues, reg u64 keys_shares, reg u64 zs, reg u64 views, reg u64 a){

	
	/****************************************/
	/*  Allocate space for ZKBoo variables  */
	/*                                      */
    /*	- Keys and key shares;              */
    /*	- Views and random value arrays;    */
    /*  - Tracking variables;               */
    /*  - Commit and challenge arrays;      */
    /*  - Proofs array;                     */
    /*                                      */
	/****************************************/



	stack u8[16] k0, k1, k2;

	reg u64 i, j, countY;
	stack u64 mpcRounds, numBytes;
	reg u64  temp;



	stack u64 zs_s;

	stack u32[8] finalHash;
	stack u64[128] es;

	reg u32 a_aux;


	/**************************************/
	/*      Initialize ZKBoo values       */
	/**************************************/

	mpcRounds = 128;
	temp = 16 * 8;
	numBytes = temp;
	countY = 0;

	zs_s = zs;
	

	/************************/
	/*  Process MPC rounds  */
	/************************/
	
	i = 0;
	while(i < mpcRounds){

		views, countY, a = commits( numBytes, keys_shares, randomValues, views, countY, a, i, mpcRounds);

		a = H(keys_shares, views, rs, a, mpcRounds);

		i = i + 1;
	}
	
	
	/************************/
	/*  Generate Challenge  */
	/************************/
	
	j = 0;
	while(j<8){
		temp = j;

		a_aux = [a + (int)temp];

		temp += 1024;

		a_aux ^= [a + (int)temp];

		temp += 1024;

		a_aux ^= [a + (int)temp];

		temp = j;
		finalHash[(int)temp] = a_aux;
		j += 1;
	}

	es = H3(finalHash, a, mpcRounds, es);
	

	/***********************/
	/*   Assemble proofs   */
	/***********************/

	zs = zs_s;
	prove(es, keys_shares, rs, views, zs, mpcRounds);
}


/***************************************************
*                                                  *
* This function receives arrays and values with    *
* random bytes used by the ZKBoo scheme.           *
*                                                  *
*	- Public Key                                   *
* 	- Keys_Shares( Keys[768], Shares[768] )        *
*	- Randomness                                   *
*   - Proofs                                       *
*	- Views( Views_x[3072], Views_y[71040] )       *
*	- A( A_yp[12288], A_h[12288] )                 *
*                                                  *
***************************************************/

export fn zkboo_encrypt(reg u64 rs, reg u64 randomValues, reg u64 keys_shares, reg u64 proofs, reg u64 views, reg u64 a){

	preparationZKBoo(rs, randomValues, keys_shares, proofs, views, a);
}
















