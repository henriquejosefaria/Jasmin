/****************************
*                           *
*  Sha1 auxiliar functions  *
*                           *
****************************/

inline
fn GETBIT_u32_v2(reg u8 x, reg u64 bit_idx) -> reg u8 {

	while(bit_idx > 0){
		x = x >> 1;
		bit_idx -= 1;
	}

	x &= 0x01; 
	
	return x;	
}

inline
fn GETBIT_EXTENDED(stack u32[8] aux, stack u64 bit_idx) -> reg u8 {

	reg u8 selectedBit;
	reg u64 bit_aux;
	reg u64 byte_aux;
	
	bit_aux = bit_idx;
	byte_aux = 0;

	while(bit_aux >= 8){
		byte_aux += 1;
		bit_aux -= 8;
	}

	selectedBit = aux[u8 (int)byte_aux];

	selectedBit = GETBIT_u32_v2(selectedBit, bit_aux);

	return  selectedBit;	
}

inline
fn GETBIT_u32(reg u32 x, reg u64 bit_idx) -> reg u32 {
	
	reg u64 aux;

	aux = bit_idx;

	while(aux > 0){
		x = x >> 1;
		aux -= 1;
	}

	x &= 0x00000001; 
	
	return x;	
}

inline
fn GETBIT_u32_left(reg u32 x, reg u64 bit_idx) -> reg u32 {

	if(bit_idx == 0){
		x = x >> 0;
		x &= 0x01;
	}
	if(bit_idx == 1){
		x = x >> 1;
		x &= 0x01;
	}
	if(bit_idx == 2){
		x = x >> 2;
		x &= 0x01;
	}
	if(bit_idx == 3){
		x = x >> 3;
		x &= 0x01;
	}
	if(bit_idx == 4){
		x = x >> 4;
		x &= 0x01;
	}
	if(bit_idx == 5){
		x = x >> 5;
		x &= 0x01;
	}
	if(bit_idx == 6){
		x = x >> 6;
		x &= 0x01;
	}
	if(bit_idx == 7){
		x = x >> 7;
		x &= 0x01;
	}
	if(bit_idx == 8){
		x = x >> 8;
		x &= 0x01;
	}
	if(bit_idx == 9){
		x = x >> 9;
		x &= 0x01;
	}
	if(bit_idx == 10){
		x = x >> 10;
		x &= 0x01;
	}
	if(bit_idx == 11){
		x = x >> 11;
		x &= 0x01;
	}
	if(bit_idx == 12){
		x = x >> 12;
		x &= 0x01;
	}
	if(bit_idx == 13){
		x = x >> 13;
		x &= 0x01;
	}
	if(bit_idx == 14){
		x = x >> 14;
		x &= 0x01;
	}
	if(bit_idx == 15){
		x = x >> 15;
		x &= 0x01;
	}
	if(bit_idx == 16){
		x = x >> 16;
		x &= 0x01;
	}
	if(bit_idx == 17){
		x = x >> 17;
		x &= 0x01;
	}
	if(bit_idx == 18){
		x = x >> 18;
		x &= 0x01;
	}
	if(bit_idx == 19){
		x = x >> 19;
		x &= 0x01;
	}
	if(bit_idx == 20){
		x = x >> 20;
		x &= 0x01;
	}
	if(bit_idx ==21){
		x = x >>21;
		x &= 0x01;
	}
	if(bit_idx == 22){
		x = x >> 22;
		x &= 0x01;
	}
	if(bit_idx == 23){
		x = x >> 23;
		x &= 0x01;
	}
	if(bit_idx == 24){
		x = x >> 24;
		x &= 0x01;
	}
	if(bit_idx == 25){
		x = x >> 25;
		x &= 0x01;
	}
	if(bit_idx == 26){
		x = x >> 26;
		x &= 0x01;
	}
	if(bit_idx == 27){
		x = x >> 27;
		x &= 0x01;
	}
	if(bit_idx == 28){
		x = x >> 28;
		x &= 0x01;
	}
	if(bit_idx == 29){
		x = x >> 29;
		x &= 0x01;
	}
	if(bit_idx == 30){
		x = x >> 30;
		x &= 0x01;
	}
	if(bit_idx == 31){
		x = x >> 31;
		x &= 0x01;
	}
	
	return x;	
}

inline
fn GETBIT(stack u32[3] x, stack u32[3] y, reg u64 bit_idx) -> reg u32, reg u32, reg u32 {

	reg u32 t0, t1, t2;

	t0 = x[0];
	t0 ^= y[0];

	t1 = x[1];
	t1 ^= y[1];

	t2 = x[2];
	t2 ^= y[2];

	t0 = GETBIT_u32(t0, bit_idx);
	t1 = GETBIT_u32(t1, bit_idx);
	t2 = GETBIT_u32(t2, bit_idx);
	
	return t0, t1, t2;	
}


inline
fn getBits(stack u32[3] array_r, stack u32[3] array_c, reg u64 i, reg u64 idx0, reg u64 idx1) -> reg u32, reg u32, reg u32 {


	reg u32 word0, word1, word2;

	word0 = array_r[(int)idx0];
	word1 = array_c[(int)idx1];
	word2 = array_r[(int)idx1];


	word0 = GETBIT_u32(word0, i);
	word1 = GETBIT_u32(word1, i);
	word2 = GETBIT_u32(word2, i);

	return word0, word1, word2;
}

inline
fn SETBIT_u32(stack u32[3] x, reg u64 bit_idx, reg u32 bit, reg u64 idx) -> reg u32[3] {

	reg u32 a;
	reg u32 bit_aux, b_aux;
	reg u64 aux;

	aux = bit_idx;

	bit_aux = bit;

	a = 0x0001;

	while(aux > 0){
		a <<= 1;
		aux -= 1;
	}

	b_aux = x[(int)idx];
	
	if (bit_aux == 1){
		b_aux |= a;
	} else{
		a ^= 0xFFFFFFFF;
		b_aux &= a; 
	}

	x[(int)idx] = b_aux;
	
	return x;
}

inline
fn SETBIT_c(reg u32 x, reg u64 bit_idx, reg u32 bit) -> reg u32 {

	reg u32 x0;
	reg u64 idx;
	idx = bit_idx;

	x0 = 0x00000001;

	while(idx > 0){
		x0 <<= 1;
		idx -= 1;
	}

	bit &= 0x00000001;

	if(bit == 0x00000001){
		x |= x0;
	} else{
		x0 ^= 0xffffffff;
		x &= x0;
	}

	return x;
}

inline
fn set_Bit(reg u32 t1, reg u64 idx, reg u32 t0) -> reg u32 {

	reg u64 aux;
	reg u32 t2;

	aux = idx;
	t2 = 0x00000001;



	while(aux > 0){
		t2 <<= 1;
		aux -= 1;
	}

	if(t0 == (0x00000001)){
		t1 |= t2;
	} else{
		t2 ^= 0xffffffff;
		t1 &= t2;
	}

	return t1;
}

inline
fn add_simple(stack u32[3] a, stack u32[3] b, stack u32[3] r, stack u32[3] c, reg u64 idx, inline int i) -> reg u32 {
	
	reg u32 t, ta, tb, tr, tc, t_aux;

	if(i == 0){

		ta = a[0];
		tb = b[1];
		t = ta & tb;

		ta = a[1];
		tb = b[0];
		t_aux = ta & tb;

		t ^= t_aux;

		tr = r[1];
		tr = GETBIT_u32(tr, idx);
		t ^= tr;

		ta = a[0];
		tb = b[0];
		t_aux = ta & tb;

		t ^= t_aux;

		tc = c[0];
		tc = GETBIT_u32(tc, idx);
		t ^= tc;


		tr = r[0];
		tr = GETBIT_u32(tr, idx);
		t ^= tr;
	}
	if(i == 1){

		ta = a[1];
		tb = b[2];
		t = ta & tb;

		ta = a[2];
		tb = b[1];
		t_aux = ta & tb;

		t ^= t_aux;

		tr = r[2];
		tr = GETBIT_u32(tr, idx);
		t ^= tr;

		ta = a[1];
		tb = b[1];
		t_aux = ta & tb;

		t ^= t_aux;

		tc = c[1];
		tc = GETBIT_u32(tc, idx);
		t ^= tc;


		tr = r[1];
		tr = GETBIT_u32(tr, idx);
		t ^= tr;
	}
	if(i == 2){

		ta = a[2];
		tb = b[0];
		t = ta & tb;

		ta = a[0];
		tb = b[2];
		t_aux = ta & tb;

		t ^= t_aux;

		tr = r[0];
		tr = GETBIT_u32(tr, idx);
		t ^= tr;

		ta = a[2];
		tb = b[2];
		t_aux = ta & tb;

		t ^= t_aux;

		tc = c[2];
		tc = GETBIT_u32(tc, idx);
		t ^= tc;


		tr = r[2];
		tr = GETBIT_u32(tr, idx);
		t ^= tr;
	}

	return t;
}




inline
fn LEFTROTATE(reg u32 x, reg u64 n) -> reg u32 {

	reg u32 aux0, aux1;
	reg u64 n1;

	aux0 = x;
	aux1 = x;

	n1 = n;

	while(n1 > 0){
		aux0 <<= 1;
		n1 -= 1;
	}

	n1 = 32;
	n1 -= n;

	while(n1 > 0){

		aux1 >>= 1;

		n1 -= 1;
	}

	aux0 |= aux1;
	
	return aux0;
}

inline
fn RIGHTSHIFT(stack u32[15] x, reg u64 i, stack u32[3] z, stack u64 pos_hHa) -> stack u32[3] {
	
	reg u32 x_aux;
	reg u64 j, pos;
	reg u64 i_aux;

	pos = pos_hHa;
	j = 0;
	while(j < 3){

		x_aux = x[(int)pos];
		x_aux >>= i;

		z[(int)j] = x_aux;

		pos += 5;
		j += 1;
	}

	return z;
}

inline
fn mpc_RIGHTSHIFT_24(stack u32[3] hHa, stack u8[12] temp) -> stack u8[12]{
	reg u32 aux;

	aux = hHa[0];
	aux = aux >> 24;
	temp[u32 0] = aux;

	aux = hHa[1];
	aux = aux >> 24;
	temp[u32 1] = aux;

	aux = hHa[2];
	aux = aux >> 24;
	temp[u32 2] = aux;

	return temp;
}

inline
fn mpc_RIGHTSHIFT_16(stack u32[3] hHa, stack u8[12] temp) -> stack u8[12]{
	reg u32 aux;

	aux = hHa[0];
	aux = aux >> 16;
	temp[u32 0] = aux;

	aux = hHa[1];
	aux = aux >> 16;
	temp[u32 1] = aux;

	aux = hHa[2];
	aux = aux >> 16;
	temp[u32 2] = aux;

	return temp;
}

inline
fn mpc_RIGHTSHIFT_8(stack u32[3] hHa, stack u8[12] temp) -> stack u8[12]{
	reg u32 aux;

	aux = hHa[0];
	aux = aux >> 8;
	temp[u32 0] = aux;

	aux = hHa[1];
	aux = aux >> 8;
	temp[u32 1] = aux;

	aux = hHa[2];
	aux = aux >> 8;
	temp[u32 2] = aux;

	return temp;
}

inline
fn mpc_LEFTROTATE(stack u32[3] x, reg u64 i, stack u32[3] z) -> stack u32[3] {

	reg u32 res;

	res = x[0];
	res = LEFTROTATE(res,i);
	z[0] = res;

	res = x[1];
	res = LEFTROTATE(res,i);
	z[1] = res;

	res = x[2];
	res = LEFTROTATE(res,i);
	z[2] = res;

	return z;
}

inline
fn mpc_LEFTROTATE_5(stack u32[3] a, stack u32[3] temp) -> stack u32[3] {
	
	reg u32 storage_u32, storage_aux; 
	
	storage_u32 = a[0];
	storage_aux = a[0];
	storage_u32 = storage_u32 << 5;
	storage_aux = storage_aux >> 27;
	storage_u32 |= storage_aux;
	temp[0] = storage_u32;

	storage_u32 = a[1];
	storage_aux = a[1];
	storage_u32 = storage_u32 << 5;
	storage_aux = storage_aux >> 27;
	storage_u32 |= storage_aux;
	temp[1] = storage_u32;

	storage_u32 = a[2];
	storage_aux = a[2];
	storage_u32 = storage_u32 << 5;
	storage_aux = storage_aux >> 27;
	storage_u32 |= storage_aux;
	temp[2] = storage_u32;

	return temp;
}

inline
fn mpc_LEFTROTATE_30(stack u32[3] a, stack u32[3] temp) -> stack u32[3] {
	
	reg u32 storage_u32, storage_aux; 
	
	storage_u32 = a[0];
	storage_aux = a[0];
	storage_u32 = storage_u32 << 30;
	storage_aux = storage_aux >> 2;
	storage_u32 |= storage_aux;
	temp[0] = storage_u32;

	storage_u32 = a[1];
	storage_aux = a[1];
	storage_u32 = storage_u32 << 30;
	storage_aux = storage_aux >> 2;
	storage_u32 |= storage_aux;
	temp[1] = storage_u32;

	storage_u32 = a[2];
	storage_aux = a[2];
	storage_u32 = storage_u32 << 30;
	storage_aux = storage_aux >> 2;
	storage_u32 |= storage_aux;
	temp[2] = storage_u32;

	return temp;
}

inline
fn mpc_LEFTROTATE_w(stack u32[3] x, reg u64 i, stack u32[240] w, reg u64 pos_w) -> stack u32[240] {
	
	reg u32 storage_u32, x_0;
	reg u64 n;

	storage_u32 = x[0];
	n = i;
	while(n > 0){
		storage_u32 <<= 1;
		n -= 1;
	}

	n = 32;
	n -= i;

	x_0 = x[0];

	while(n > 0){
		x_0 >>= 1;

		n -= 1;
	}
	
	storage_u32 |= x_0;

	w[(int)pos_w] = storage_u32;

	return w;
}


inline
fn get_chunks(stack u8[192] chunks, stack u64 i, stack u64 j) -> reg u32{

	reg u32 storage_u32, storage;
	reg u8 storage_aux;
	reg u64 pos, pos_aux;
	stack u8[4] chunk;

	pos = i * 64;
	pos_aux = j * 4;
	pos += pos_aux;
	storage_aux = chunks[(int)pos];
	chunk[3] = storage_aux;

	pos += 1;
	storage_aux = chunks[(int)pos];
	chunk[2] = storage_aux;

	pos += 1;
	storage_aux = chunks[(int)pos];
	chunk[1] = storage_aux;

	pos += 1;
	storage_aux = chunks[(int)pos];
	chunk[0] = storage_aux;

	storage_u32 = chunk[u32 0];

	return storage_u32;
}


inline
fn set_word(reg u64 rs, reg u64 player0, reg u64 player1, stack u64 mpcRounds, reg u64 i, reg u64 pos, reg u64 zs) {

	reg u64 word, aux_word;
	reg u64 mem_pos;


	// We grab the first half of the u64 if pos == 0 else we grab the second half
	

	mem_pos = player0 * mpcRounds;
	mem_pos = (mem_pos + i);
	mem_pos = mem_pos >> 1;        // Divide by 2

	if(pos == 0){
		word = [rs + mem_pos];
		word &= 0xffffffff00000000;
	} else {
		word = [rs + mem_pos];
		word <<= 32;
	}



	mem_pos = player1 * mpcRounds;
	mem_pos = mem_pos + i;
	mem_pos = mem_pos >> 1;        // Divide by 2

	if(pos == 0){
		aux_word = [rs + mem_pos];
		aux_word >>= 32;
	} else {
		aux_word = [rs + mem_pos];
		aux_word &= 0x00000000ffffffff;
	}

	word += aux_word;

	mem_pos = i * 391;
	mem_pos += 390;

	[zs + mem_pos] = word;
}






inline
fn mpc_words(stack u32[3] x, stack u32[3] y, stack u32[3] z, reg u64 i) -> reg u32, reg u32 {


	reg u32 a, b, c;
	reg u32 word_a, word_b;

	a = x[(int)i];
	b = y[(int)i];
	c = z[(int)i];

	word_a = a ^ b;
	word_b = c ^ b;

	return word_a, word_b;
}

inline
fn mpc_words_w(stack u32[240] x, stack u32[3] y, stack u32[3] z, stack u64 pos_w, reg u64 j) -> reg u32, reg u32 {


	reg u32 a, b, c;
	reg u32 word_a, word_b;
	reg u64 pos;

	pos = j * 80;
	pos += pos_w;

	a = x[(int)pos];
	b = y[(int)j];
	c = z[(int)j];

	word_a = a ^ b;
	word_b = c ^ b;

	return word_a, word_b;
}

inline
fn mpc_words_hHa(stack u32[15] x, stack u32[3] y, stack u32[3] z, reg u64 pos_hHa, reg u64 i) -> reg u32, reg u32 {


	reg u32 a, b, c;
	reg u32 word_a, word_b;
	reg u64 aux;

	aux = pos_hHa;
	aux += i;
	a = x[(int)aux];
	b = y[(int)i];
	c = z[(int)i];

	word_a = a ^ b;
	word_b = c ^ b;

	return word_a, word_b;
}

inline
fn mpc_words_k(stack u32[3] x, stack u32[3] y, stack u32 k, reg u64 j) -> reg u32, reg u32 {


	reg u32 a, b, c;
	reg u32 word_a, word_b;

	a = x[(int)j];
	b = y[(int)j];
	c = k;

	word_a = a ^ b;
	word_b = c ^ b;

	return word_a, word_b;
}

inline
fn mpc_xor(stack u32[3] x, stack u32[3] y, stack u32[3] z) -> stack u32[3] {
	
	reg u32 aux;

	aux = x[0];
	aux ^= y[0];
	z[0] = aux;

	aux = x[1];
	aux ^= y[1];
	z[1] = aux;

	aux = x[2];
	aux ^= y[2];
	z[2] = aux;

	return z;
}

inline
fn mpc_xor_w(stack u32[240] w, stack u32[3] y, stack u32[3] z, stack u64 pos_w) -> reg u32[3] {
	
	reg u64 pos;
	reg u32[3] z_aux;

	pos = pos_w;
	z_aux[0] = w[(int)pos];
	z_aux[0] ^= y[0];

	pos += 80;
	z_aux[1] = w[(int)pos];
	z_aux[1] ^= y[1];

	pos += 80;
	z_aux[2] = w[(int)pos];
	z_aux[2] ^= y[2];

	z[0] = z_aux[0];
	z[1] = z_aux[1];
	z[2] = z_aux[2];

	return z;
}

inline
fn mpc_xor_k(stack u32 k, stack u32[3] y, stack u32[3] z) -> stack u32[3] {

	reg u32 y_aux;

	y_aux = y[0];
	z[0] = k;
	z[0] ^= y_aux;

	y_aux = y[1];
	z[1] = k;
	z[1] ^= y_aux;

	y_aux = y[2];
	z[2] = k;
	z[2] ^= y_aux;

	return z;
}

inline
fn mpc_xor_hHa(stack u32[15] hHa, stack u32[3] y, stack u32[3] z, reg u64 pos_hHa) -> stack u32[3] {

	reg u64 pos;

	pos = pos_hHa;
	z[0] = hHa[(int)pos];
	z[0] ^= y[(int)0];

	pos += 5;
	z[1] = hHa[(int)pos];
	z[1] ^= y[(int)1];

	pos += 5;
	z[2] = hHa[(int)pos];
	z[2] ^= y[(int)2];

	return z;
}

inline
fn mpc_xor_three(stack u32[3] x, stack u32[3] y, stack u32 k,  reg u64 i) -> stack u32[3] {
	
	reg u32 aux_x, aux_y;

	aux_x = x[(int)i];
	aux_y = y[(int)i];

	aux_x ^= aux_y;
	aux_x ^= k;

	x[(int)i] = aux_x;
	
	return x;
}

inline
fn w_to_temp(stack u32[3] temp, stack u32[240] w, reg u64 pos_w) -> stack u32[3]{

	reg u32 aux0, aux1;

	aux0 = w[(int)pos_w - 3];
	aux1 = w[(int)pos_w - 8];

	temp[0] = aux0;
	temp[0] ^= aux1;


	aux0 = w[(int)pos_w - 14];

	temp[0] ^= aux0;


	aux0 = w[(int)pos_w - 16];

	temp[0] ^= aux0;


	return temp;
}

inline
fn hHa_swap(stack u32[15] hHa, reg u64 idx) -> stack u32[15]{

	reg u8 aux0, aux1;
	reg u32 storage_u32;
	stack u8[4] temp;


	reg u64 i;

	i = idx;

	/* Player 0 */

	storage_u32 = hHa[(int)i];
	temp[u32 0] = storage_u32;

	aux0 = temp[0];
	aux1 = temp[3];

	temp[0] = aux1;
	temp[3] = aux0;

	aux0 = temp[1];
	aux1 = temp[2];

	temp[1] = aux1;
	temp[2] = aux0;

	storage_u32 = temp[u32 0];

	hHa[(int)i] = storage_u32;


	/* Player 1 */
	i += 5;

	storage_u32 = hHa[(int)i];
	temp[u32 0] = storage_u32;

	aux0 = temp[0];
	aux1 = temp[3];

	temp[0] = aux1;
	temp[3] = aux0;

	aux0 = temp[1];
	aux1 = temp[2];

	temp[1] = aux1;
	temp[2] = aux0;

	storage_u32 = temp[u32 0];

	hHa[(int)i] = storage_u32;

	/* Player 2 */
	i += 5;

	storage_u32 = hHa[(int)i];
	temp[u32 0] = storage_u32;

	aux0 = temp[0];
	aux1 = temp[3];

	temp[0] = aux1;
	temp[3] = aux0;

	aux0 = temp[1];
	aux1 = temp[2];

	temp[1] = aux1;
	temp[2] = aux0;

	storage_u32 = temp[u32 0];

	hHa[(int)i] = storage_u32;

	return hHa;
}



// X & z são iguais á versão no C
inline
fn mpc_ADD(stack u32[3] x, stack u32[3] y, stack u32[3] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, reg u64 mpc_idx, stack u64 mpcRounds) -> stack u32[3], reg u64, reg u64, reg u64 {

	stack u32[3] c, r, a, b;
	reg u32 t, t0, t1, t2, ta, tb, tc, tr;

	reg u64 i, j, bit_idx, idx0, idx1;
	reg u64 temp_views, temp, player;

	reg u8 t8;
	inline int debug;

	stack u32[3] x_aux, y_aux;

	t = x[0];
	x_aux[0] = t;
	t = x[1];
	x_aux[1] = t;
	t = x[2];
	x_aux[2] = t;

	t = y[0];
	y_aux[0] = t;
	t = y[1];
	y_aux[1] = t;
	t = y[2];
	y_aux[2] = t;



	c[0] = 0x00000000;
	c[1] = 0x00000000;
	c[2] = 0x00000000;


	i = 0;
	while(i < 3){
	
		j = mpcRounds * 1472;
		j *= i;

		temp = 1472 * mpc_idx;
		temp += j;
		temp += randCount;

		t = (u32)[randomness + (int)temp];

		r[(int)i] = t;

		i += 1;
	}
	randCount += 4;


	i = 0;
	while(i < 31){

		bit_idx = i;
		bit_idx += 1;

		
		j = 0;
		while(j < 3){

			t = x[(int)j];
			t ^= c[(int)j];
			t = GETBIT_u32_left(t,i); 

			a[(int)j] = t;


			t = y[(int)j];
			t ^= c[(int)j];
			t = GETBIT_u32_left(t,i);

			b[(int)j] = t;

			j += 1;
		}
		

		/* Player 0 */

		t = a[0];
		t &= b[1];

		ta = a[1];
		tb = b[0];
		t0 = ta & tb;
		t ^= t0;

		ta = a[0];
		tb = b[0];
		t0 = ta & tb;
		t ^= t0;

		tr = r[1];
		tr = GETBIT_u32_left(tr,i);
		t ^= tr;

		tc = c[0];
		tc = GETBIT_u32_left(tc,i);
		t ^= tc;

		tr = r[0];
		tr = GETBIT_u32_left(tr,i);
		t ^= tr;

		tc = c[0];
		tc = SETBIT_c(tc, bit_idx, t);
		c[0] = tc;


		/* Player 1 */

		t = a[1];
		t &= b[2];

		ta = a[2];
		tb = b[1];
		t0 = ta & tb;
		t ^= t0;

		ta = a[1];
		tb = b[1];
		t0 = ta & tb;
		t ^= t0;

		tr = r[2];
		tr = GETBIT_u32_left(tr,i);
		t ^= tr;

		tc = c[1];
		tc = GETBIT_u32_left(tc,i);
		t ^= tc;

		tr = r[1];
		tr = GETBIT_u32_left(tr,i);
		t ^= tr;

		tc = c[1];
		tc = SETBIT_c(tc, bit_idx, t);
		c[1] = tc;
		

		/* Player 2 */

		t = a[2];
		t &= b[0];

		ta = a[0];
		tb = b[2];
		t0 = ta & tb;
		t ^= t0;

		ta = a[2];
		tb = b[2];
		t0 = ta & tb;
		t ^= t0;

		tr = r[0];
		tr = GETBIT_u32_left(tr,i);
		t ^= tr;

		tc = c[2];
		tc = GETBIT_u32_left(tc,i);
		t ^= tc;

		tr = r[2];
		tr = GETBIT_u32_left(tr,i);
		t ^= tr;

		tc = c[2];
		tc = SETBIT_c(tc, bit_idx, t);
		c[2] = tc;

		i += 1;

	}
	
	
	i = 0;
	while(i < 3){

		t0 = x_aux[(int)i];
		t1 = y_aux[(int)i];
		t2 = c[(int)i];

		t0 ^= t1;
		t0 ^= t2;

		z[(int)i] = t0;


		temp_views = 64 * mpcRounds;
		temp_views *= 3;

		temp = mpcRounds * 1480;
		temp *= i;
		temp_views += temp;

		temp = mpc_idx * 1480;
		temp_views += temp; 

		temp_views += countY;

		t0 = c[(int)i];

		(u32)[views + (int)temp_views] = t0;

		i += 1;
	}
	
	countY += 4;

	return z, randCount, countY, views;
}

inline
fn mpc_ADD_W(stack u32[240] w, stack u32[3] y, stack u32[3] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, stack u64 pos_w, reg u64 mpc_idx, stack u64 mpcRounds) -> stack u32[3], reg u64, reg u64, reg u64 {
	
	stack u32[3] c, r, aux, aux2;

	stack u32[3] a, b;

	reg u64 i, j;

	reg u64 idx0, idx1, bit_idx, player;

	reg u64 temp_pos;

	reg u32 t, t0, t1, t2, ta, tb, tr, tc;

	reg u8 t8;

	reg u64 pos_views, pos_rand, pos_aux, temp, temp_views;

	c[0] = 0x00000000;
	c[1] = 0x00000000;
	c[2] = 0x00000000;

	i = 0;
	while(i < 3){

		pos_rand = i * 1472;
		pos_rand *= mpcRounds;

		temp = mpc_idx * 1472;
		pos_rand += temp;

		pos_rand += randCount;

		r[(int)i] = (u32)[randomness + (int)pos_rand];

		i += 1;
	}

	randCount += 4;
	
	i  = 0;
	while(i < 31){

		bit_idx = i;
		bit_idx += 1;

		j = 0;
		while(j < 3){

			temp = 80 * j;
			temp += pos_w;

			t = w[(int)temp];
			t ^= c[(int)j];
			t = GETBIT_u32_left(t,i); 
			a[(int)j] = t;

			t = y[(int)j];
			t ^= c[(int)j];
			t = GETBIT_u32_left(t,i);
			b[(int)j] = t;

			j += 1;
		}
		

		/* Player 0 */

		t = a[0];
		t &= b[1];

		ta = a[1];
		tb = b[0];
		t0 = ta & tb;
		t ^= t0;

		ta = a[0];
		tb = b[0];
		t0 = ta & tb;
		t ^= t0;

		tr = r[1];
		tr = GETBIT_u32_left(tr,i);
		t ^= tr;

		tc = c[0];
		tc = GETBIT_u32_left(tc,i);
		t ^= tc;

		tr = r[0];
		tr = GETBIT_u32_left(tr,i);
		t ^= tr;

		tc = c[0];
		tc = SETBIT_c(tc, bit_idx, t);
		c[0] = tc;


		/* Player 1 */

		t = a[1];
		t &= b[2];

		ta = a[2];
		tb = b[1];
		t0 = ta & tb;
		t ^= t0;

		ta = a[1];
		tb = b[1];
		t0 = ta & tb;
		t ^= t0;

		tr = r[2];
		tr = GETBIT_u32_left(tr,i);
		t ^= tr;

		tc = c[1];
		tc = GETBIT_u32_left(tc,i);
		t ^= tc;

		tr = r[1];
		tr = GETBIT_u32_left(tr,i);
		t ^= tr;

		tc = c[1];
		tc = SETBIT_c(tc, bit_idx, t);
		c[1] = tc;
		

		/* Player 2 */

		t = a[2];
		t &= b[0];

		ta = a[0];
		tb = b[2];
		t0 = ta & tb;
		t ^= t0;

		ta = a[2];
		tb = b[2];
		t0 = ta & tb;
		t ^= t0;

		tr = r[0];
		tr = GETBIT_u32_left(tr,i);
		t ^= tr;

		tc = c[2];
		tc = GETBIT_u32_left(tc,i);
		t ^= tc;

		tr = r[2];
		tr = GETBIT_u32_left(tr,i);
		t ^= tr;

		tc = c[2];
		tc = SETBIT_c(tc, bit_idx, t);
		c[2] = tc;
		
		i += 1;	
	}
	
	

	i = 0;
	while(i < 3){

		pos_aux = 80 * i;
		pos_aux += pos_w;

		t0 = w[(int)pos_aux];
		t1 = z[(int)i];
		t2 = c[(int)i];

		t0 ^= t1;
		t0 ^= t2;

		z[(int)i] = t0;


		temp_views = 64 * mpcRounds;
		temp_views *= 3;

		temp = mpcRounds * 1480;
		temp *= i;
		temp_views += temp;

		temp = mpc_idx * 1480;
		temp_views += temp; 

		temp_views += countY;

		t0 = c[(int)i];

		(u32)[views + (int)temp_views] = t0;

		i += 1;
	}
	countY += 4;

	return z, randCount, countY, views;
}

inline
fn mpc_ADD_K(stack u32[3] x, stack u32 k, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, reg u64 mpc_idx, stack u64 mpcRounds) -> stack u32[3], reg u64, reg u64, reg u64 {

	stack u32[3] c, r, aux, aux2;
	reg u64 bit_idx, idx0, idx1, player;

	inline u32 xor_aux;

	stack u32[3] a, b;
	reg u64 i;
	reg u64 j;
	reg u32 t, t0, t1, t2, word_a, word_b;

	reg u64 pos_rand, pos_views, idx, temp;

	c[0] = 0;
	c[1] = 0;
	c[2] = 0;

	i = 0;

	while(i < 3){

		pos_rand = i * 1472;
		pos_rand *= mpcRounds;

		temp = mpc_idx * 1472;
		pos_rand += temp;

		pos_rand += randCount;

		r[(int)i] = (u32)[randomness + (int)pos_rand];

		i += 1;
	}

	randCount += 4;

	
	i = 0;
	while(i < 31){

		bit_idx = i;
		bit_idx += 1;

		j = 0;

		while(j < 3){

			t, t1 = mpc_words_k(x, c, k, j);

			t = GETBIT_u32(t,i);
			a[(int)j] = t;

			t1 = GETBIT_u32(t1,i);
			b[(int)j] = t1;

			j += 1;
		}

		/* Set first word */

		
		idx0 = 1;
		idx1 = 0;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[0];
		t &= b[1];
		t ^= t0;

		t0 = a[1];
		t0 &= b[0];
		t ^= t0;

		t0 = a[0];
		t0 &= b[0];
		t ^= t0;

		t ^= t1;
		t ^= t2;


		player = 0;

		c = SETBIT_u32(c, bit_idx, t, player);



		/* Set second word */

		
		idx0 = 2;
		idx1 = 1;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[1];
		t &= b[2];
		t ^= t0;

		t0 = a[2];
		t0 &= b[1];
		t ^= t0;

		t0 = a[1];
		t0 &= b[1];
		t ^= t0;

		t ^= t1;
		t ^= t2;
		

		player = 1;

		c = SETBIT_u32(c, bit_idx, t, player);
		


		/* Set third word */

		
		idx0 = 0;
		idx1 = 2;

		t0, t1, t2 = getBits(r, c, i, idx0, idx1);
		
		t = a[2];
		t &= b[0];
		t ^= t0;

		t0 = a[0];
		t0 &= b[2];
		t ^= t0;

		t0 = a[2];
		t0 &= b[2];
		t ^= t0;

		t ^= t1;
		t ^= t2;
		

		player = 2;

		c = SETBIT_u32(c, bit_idx, t, player);

		i += 1;	
	}
	

	idx = 0;
	while(idx < 3){

		/* Set views to players' views.ys */

		pos_views = 3 * mpcRounds;
		pos_views *= 64;

		/* Set views to player i's views.ys */

		temp = idx;
		temp *= mpcRounds;		// which player info do we need (player * mpcRounds * view.y_size)
		temp *= 1480;	

		pos_views += temp;	

		/* Set views to current view.y */	

		temp = mpc_idx * 1480;

		pos_views += temp;

		/* Set the current byte to store */

		pos_views += countY;			// current pointer inside view.y
		


		x = mpc_xor_three(x,c,k,idx);
		

		t = c[(int)idx];

		(u32)[views + pos_views] = t;

		idx += 1;

	}

	countY += 4;

	return x, randCount, countY, views;
}

inline
fn mpc_AND(stack u32[3] x, stack u32[3] y, stack u32[3] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, reg u64 mpc_idx, stack u64 mpcRounds) -> stack u32[3], reg u64, reg u64, reg u64 {

	stack u32[3] r, y2;
	reg u64 i, pos_randomness, pos_r, pos_views, temp_pos, temp, temp_views;
	reg u32 t0, t1, t2, t_x, t_y, t_r, t_aux, temp0;
	reg u32[3] aux_z;

	aux_z[0] = y[0];
	aux_z[1] = y[1];
	aux_z[2] = y[2];

	i = 0;

	while(i < 3){

		pos_randomness = i * 1472;
		pos_randomness *= mpcRounds;

		temp = mpc_idx * 1472;
		pos_randomness += temp;

		pos_randomness += randCount;

		r[(int)i] = (u32)[randomness + (int)pos_randomness];

		i += 1;
	}
	randCount += 4; 


	// t[0] = (x[0] & y[1]) ^ (x[1] & y[0]) ^ (x[0] & y[0]) ^ r[0] ^ r[1] 
	
	t_x = x[0];
	t_y = aux_z[1];
	t0 = t_x & t_y;

	t_x = x[1];
	t_y = aux_z[0];
	t1 = t_x & t_y; 
	
	t_x = x[0];
	t_y = aux_z[0];
	t2 = t_x & t_y;


	t0 ^= t1;
	t0 ^= t2;
	
	t1 = r[0];
	t0 ^= t1;

	t1 = r[1];
	t0 ^= t1;

	z[0] = t0;


	// t[1] = (x[1] & y[2]) ^ (x[2] & y[1]) ^ (x[1] & y[1]) ^ r[1] ^ r[2] 
	

	t_x = x[1];
	t_y = aux_z[2];
	t0 = t_x & t_y;

	t_x = x[2];
	t_y = aux_z[1];
	t1 = t_x & t_y;
	
	t_x = x[1];
	t_y = aux_z[1];
	t2 = t_x & t_y;


	t0 ^= t1;
	t0 ^= t2;
	
	t1 = r[1];
	t0 ^= t1;

	t1 = r[2];
	t0 ^= t1;
	
	z[1] = t0;


	// t[2] = (x[2] & y[0]) ^ (x[0] & y[2]) ^ (x[2] & y[2]) ^ r[2] ^ r[0] 
	
	t_x = x[2];
	t_y = aux_z[0];
	t0 = t_x & t_y;

	t_x = x[0];
	t_y = aux_z[2];
	t1 = t_x & t_y;
	
	t_x = x[2];
	t_y = aux_z[2];
	t2 = t_x & t_y;


	t0 ^= t1;
	t0 ^= t2;
	
	t1 = r[2];
	t0 ^= t1;

	t1 = r[0];
	t0 ^= t1;
	
	z[2] = t0;
	
	i = 0;
	while(i < 3){

		/* Set views */

		pos_views = 3 * mpcRounds;	// Set views.y
		pos_views *= 64;

		temp_pos = i;				// Set playerX views.y
		temp_pos *= mpcRounds;		
		temp_pos *= 1480;	
		pos_views += temp_pos;		

		temp_pos = mpc_idx * 1480;	// Set playerX current view.y
		pos_views += temp_pos;

		/* Set the current byte to store */

		pos_views += countY;			// Set current u32 to be copyed

		/* Z => u32[3]; */

		temp0 = z[(int)i];

		(u32)[views + (int)pos_views] = temp0;
		
		i += 1;
	}

	countY += 4;

	return z, randCount, countY, views;
}

inline
fn mpc_MAJ(stack u32[3] a, stack u32[3] b, stack u32[3] c, stack u32[3] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY, reg u64 mpc_idx, stack u64 mpcRounds) -> stack u32[3], reg u64, reg u64, reg u64 {
	
	stack u32[3] t0, t1;
	reg u32 t;
	reg u64 temp_views;

	t0[0] = 0;
	t0[1] = 0;
	t0[2] = 0;

	t1[0] = 0;
	t1[1] = 0;
	t1[2] = 0;

	t0 = mpc_xor(a, b, t0);
	t1 = mpc_xor(a, c, t1);

	t = t1[0];
	z[0] = t;
	t = t1[1];
	z[1] = t;
	t = t1[2];
	z[2] = t;

	z, randCount, countY, views = mpc_AND(t0, t1, z, randomness, randCount, views, countY, mpc_idx, mpcRounds);

	z = mpc_xor(z, a, z);

	return z, randCount, countY, views;
}

/*************
*            *
*  MPC Sha1  *
*            *
*************/

inline
fn mpc_SHA1(stack u32[24] results, reg u64 inputs, stack u64 numBits, reg u64 randomness, reg u64 views, reg u64 countY, reg u64 mpc_idx, stack u64 mpcRounds) -> stack u32[24], reg u64, reg u64 {


	reg u64 chars;
	reg u64 temp_aux, temp_chunks, temp_inputs, temp_views, temp_w, pos_w, pos_results, pos_hHa, pos_randomness, temporary;
	reg u64 randCount;
	reg u32 storage_u32, storage_aux;
	reg u8 storage_u8;

	stack u8[192] chunks; 						// u8 chunks[3][64]
	stack u32[240] w; 							// u32 W[80][3];
	
	reg u64 j_aux;

	stack u64 i, j;
	stack u32[3] temp;		 					// uint32_t temp[3]; 
	stack u32[3] t0,t1,t2;						// uint32_t t0[3];

	stack u32[3] a, b, c, d, e, f, w_aux;
	stack u32 k;

	stack u32[5] hA;
	stack u32[3] hHa;
	stack u32[15] hHa_aux;
	stack u8[12] hHa_temp;

	reg u64 n;

	reg u8 t;

	hA[0] = 0x67452301;
	hA[1] = 0xEFCDAB89;
	hA[2] = 0x98BADCFE;
	hA[3] = 0x10325476;
	hA[4] = 0xC3D2E1F0;

	randCount = 0;

	/*  numBits is 128; 128 >> 3 = 16 bytes; */

	chars = numBits;
	chars = chars >> 3;

	j_aux = 0;
	while(j_aux < 192){

		chunks[(int)j_aux] = 0; 
		j_aux += 1;

	}

	j_aux = 0;
	while(j_aux < 240){

		w[(int)j_aux] = 0; 
		j_aux += 1;

	}
	
	
	i = 0;
	while(i < 3){

		/* Get to shares */

		temp_aux = 3 * 16;
		temp_aux *= mpcRounds;				

		temp_inputs = temp_aux;			


		/* Go to the i player's shares */

		temp_aux = i * 16;
		temp_aux *= mpcRounds;		

		temp_inputs += temp_aux;		


		/* Go to the current round's share */

		temp_aux = 16;
		temp_aux *= mpc_idx;		 	

		temp_inputs += temp_aux;


		temp_chunks = i * 64;

		j_aux = 0;
		while(j_aux < 16){
			storage_u8 = (u8)[inputs + (int)temp_inputs];
			chunks[(int)temp_chunks] = storage_u8;

			temp_chunks += 1;
			temp_inputs += 1;
			j_aux += 1;
		}

		temp_chunks = i * 64;
		temp_chunks += 16;
		chunks[(int)temp_chunks] = 0x80;

		temp_chunks = i * 64;
		temp_chunks += 62;

		n = numBits;
		n >>= 8;
		chunks[(int)temp_chunks] = n;

		temp_chunks += 1;

		n = numBits;
		chunks[(int)temp_chunks] = n;
		

		temp_chunks = i * 64;


		/* Set the pointer to the player's views.x to store the chunks */

		temp_views = i * 64;
		temp_views *= mpcRounds;				


		/* Set current views.x to store */

		temp_aux = 64 * mpc_idx;	 	// Set current player's view.x	
		temp_views += temp_aux;

		j = 0;
		while(j < 64){

			storage_u8 = chunks[(int)temp_chunks];

			(u8)[views + (int)temp_views] = storage_u8;

			n += 1;
			temp_views += 1;
			temp_chunks += 1;

			j += 1;
		}

		j = 0;
		while(j < 16){

			storage_u32 = get_chunks(chunks, i, j);

			temp_w = i;
			temp_w *= 80;
			temp_w += j;

			w[(int)temp_w] = storage_u32;

			j += 1;
		}

		i += 1;
	}

	
	j = 16;
	while(j < 80){
		i = 0;
		while(i < 3){
			pos_w = i;
			pos_w *= 80;
			pos_w += j;

			temp = w_to_temp(temp, w, pos_w);

			n = 1;
			w = mpc_LEFTROTATE_w(temp,n,w,pos_w);

			i += 1;
		}
		j += 1;
	}
	
	

	// uint32_t a[3] = { hA[0],hA[0],hA[0] };
	
	storage_u32 = hA[0];
	a[0] = storage_u32;
	a[1] = storage_u32;
	a[2] = storage_u32;


	// uint32_t b[3] = { hA[1],hA[1],hA[1] };

	storage_u32 = hA[1];
	b[0] = storage_u32;
	b[1] = storage_u32;
	b[2] = storage_u32;


	// uint32_t c[3] = { hA[2],hA[2],hA[2] };

	storage_u32 = hA[2];
	c[0] = storage_u32;
	c[1] = storage_u32;
	c[2] = storage_u32;


	// uint32_t d[3] = { hA[3],hA[3],hA[3] };

	storage_u32 = hA[3];
	d[0] = storage_u32;
	d[1] = storage_u32;
	d[2] = storage_u32;


	// uint32_t e[3] = { hA[4],hA[4],hA[4] };

	storage_u32 = hA[4];
	e[0] = storage_u32;
	e[1] = storage_u32;
	e[2] = storage_u32;



	temp_views = 64 * 3;
	temp_views *= mpcRounds;
	temp_views += countY;

	temp_aux = 0;
	
	j = 0;
	while(j < 80){
		
		if(j <= 19){

			f = mpc_xor(c,d,f);
			
			f, randCount, countY, views = mpc_AND(b, f, f, randomness, randCount, views, countY, mpc_idx, mpcRounds);

			f = mpc_xor(d,f,f);

			k = 0x5A827999;
		}
		if(j > 19){
			if( j <= 39) {

				f = mpc_xor(b,c,f);

				f = mpc_xor(d,f,f);

				k = 0x6ED9EBA1;
			}
			if(j > 39) { // if (j > 39)
				
				if( j <= 59) {

					f, randCount, countY, views = mpc_MAJ(b,c,d,f,randomness, randCount, views, countY, mpc_idx, mpcRounds);

					k = 0x8F1BBCDC;
				}
				if(j > 59) {
					f = mpc_xor(b,c,f);

					f = mpc_xor(d,f,f);

					k = 0xCA62C1D6;
				}		
			}

		}
		
		temp = mpc_LEFTROTATE_5(a,temp);

		temp, randCount, countY, views = mpc_ADD(f, temp, temp, randomness, randCount, views, countY, mpc_idx, mpcRounds);
		
		temp, randCount, countY, views = mpc_ADD(e, temp, temp, randomness, randCount, views, countY, mpc_idx, mpcRounds);

		temp, randCount, countY, views = mpc_ADD_K(temp, k, randomness, randCount, views, countY, mpc_idx, mpcRounds);

		n = j;
		storage_u32 = w[(int)n];
		w_aux[0] = storage_u32;
		n += 80;
		storage_u32 = w[(int)n];
		w_aux[0] = storage_u32;
		n += 80;
		storage_u32 = w[(int)n];
		w_aux[0] = storage_u32;

		temp, randCount, countY, views = mpc_ADD(w_aux, temp, temp, randomness, randCount, views, countY, mpc_idx, mpcRounds);
		
		
		storage_u32 = d[0];
		e[0] = storage_u32;

		storage_u32 = d[1];
		e[1] = storage_u32;

		storage_u32 = d[2];
		e[2] = storage_u32;


		storage_u32 = c[0];
		d[0] = storage_u32;

		storage_u32 = c[1];
		d[1] = storage_u32;

		storage_u32 = c[2];
		d[2] = storage_u32;

		
		c = mpc_LEFTROTATE_30(b, c);
			

		storage_u32 = a[0];
		b[0] = storage_u32;

		storage_u32 = a[1];
		b[1] = storage_u32;

		storage_u32 = a[2];
		b[2] = storage_u32;


		storage_u32 = temp[0];
		a[0] = storage_u32;

		storage_u32 = temp[1];
		a[1] = storage_u32;

		storage_u32 = temp[2];
		a[2] = storage_u32;

		j += 1;
	}

	storage_u32 = hA[0];
	hHa[0] = storage_u32;
	hHa[1] = storage_u32;
	hHa[2] = storage_u32;

	temp, randCount, countY, views = mpc_ADD(hHa, a, hHa, randomness, randCount, views, countY, mpc_idx, mpcRounds);

	storage_u32 = temp[0];
	hHa_aux[0] = storage_u32;
	storage_u32 = temp[1];
	hHa_aux[1] = storage_u32;
	storage_u32 = temp[2];
	hHa_aux[2] = storage_u32;


	storage_u32 = hA[1];
	hHa[0] = storage_u32;
	hHa[1] = storage_u32;
	hHa[2] = storage_u32;

	temp, randCount, countY, views = mpc_ADD(hHa, b, hHa, randomness, randCount, views, countY, mpc_idx, mpcRounds);

	storage_u32 = temp[0];
	hHa_aux[3] = storage_u32;
	storage_u32 = temp[1];
	hHa_aux[4] = storage_u32;
	storage_u32 = temp[2];
	hHa_aux[5] = storage_u32;


	storage_u32 = hA[2];
	hHa[0] = storage_u32;
	hHa[1] = storage_u32;
	hHa[2] = storage_u32;

	temp, randCount, countY, views = mpc_ADD(hHa, c, hHa, randomness, randCount, views, countY, mpc_idx, mpcRounds);

	storage_u32 = temp[0];
	hHa_aux[6] = storage_u32;
	storage_u32 = temp[1];
	hHa_aux[7] = storage_u32;
	storage_u32 = temp[2];
	hHa_aux[8] = storage_u32;


	storage_u32 = hA[3];
	hHa[0] = storage_u32;
	hHa[1] = storage_u32;
	hHa[2] = storage_u32;

	temp, randCount, countY, views = mpc_ADD(hHa, d, hHa, randomness, randCount, views, countY, mpc_idx, mpcRounds);

	storage_u32 = temp[0];
	hHa_aux[9] = storage_u32;
	storage_u32 = temp[1];
	hHa_aux[10] = storage_u32;
	storage_u32 = temp[2];
	hHa_aux[11] = storage_u32;


	storage_u32 = hA[4];
	hHa[0] = storage_u32;
	hHa[1] = storage_u32;
	hHa[2] = storage_u32;

	temp, randCount, countY, views = mpc_ADD(hHa, e, hHa, randomness, randCount, views, countY, mpc_idx, mpcRounds);

	storage_u32 = temp[0];
	hHa_aux[12] = storage_u32;
	storage_u32 = temp[1];
	hHa_aux[13] = storage_u32;
	storage_u32 = temp[2];
	hHa_aux[14] = storage_u32;


	j = 0;
	while(j < 5){

		j_aux = j;
		j_aux *= 3;

		storage_u32 = hHa_aux[(int)j_aux];
		j_aux += 1;
		hHa[0] = storage_u32;
		storage_u32 = hHa_aux[(int)j_aux];
		hHa[1] = storage_u32;
		j_aux += 1;
		storage_u32 = hHa_aux[(int)j_aux];
		hHa[2] = storage_u32;

		j_aux = j;
		storage_u32 = hHa[0];
		results[(int)j_aux] = storage_u32;
		storage_u32 = hHa[1];
		results[(int)j_aux + 8] = storage_u32;
		storage_u32 = hHa[2];
		results[(int)j_aux + 16] = storage_u32;

		j += 1;
	}


	return results, views, countY;
}

/***********************
*                      *
*  Commits & mpc_Sha1  *
*                      *
***********************/

inline
fn commits(stack u64 numBits, reg u64 keys_shares, reg u64 randomness, reg u64 views, reg u64 a, reg u64 mpc_idx, stack u64 mpcRounds) -> reg u64, reg u64 {

	stack u32[24] hashes;
	
	stack u32[5] result1, result2, result3;

	reg u64 i, j, temp_views, temp, a_temp, countY, temp_aux, pos, temporary;
	reg u32 var, storage_u32;

	reg u8 t;

	countY = 0;
	
	hashes, views, countY = mpc_SHA1(hashes, keys_shares, numBits, randomness, views, countY, mpc_idx, mpcRounds);
	

	i=0;
	while(i < 3){

		// Set views.y //

		temp_views = 64;
		temp_views *= mpcRounds;
		temp_views *= 3;

		temp = 1480 * mpcRounds;
		temp *= i;
		temp_views += temp;

		temp = mpc_idx * 1480;
		temp_views += temp;

		temp_views += countY;

		temp = i * 8;
		j = 0;
		while(j <  5){

			var = hashes[(int) temp];

			(u32)[views + (int)temp_views] = var;

			temp_views += 4;
			temp += 1;
			j += 1;
		}

		i += 1;
	}
	
	
	i = 0;
	while(i < 3){

		/* Set player 0 current a.yp */

		a_temp = i * 32;
		a_temp *= mpcRounds;

		temp = mpc_idx * 32;
		a_temp += temp;


		/* Set views.y */
		
		temp_views = 64;			//Set views.y
		temp_views *= mpcRounds;
		temp_views *= 3;

		temp = 1480 * mpcRounds;	// Set playerX views.y
		temp *= i;
		temp_views += temp;

		temp = mpc_idx * 1480;		// Set playerX current view.y
		temp_views += temp;

		temp_views += 1460;			// Set to the last 20 bytes
		

		//temp = i * 8;
		
		j = 0;
		while(j<5){

			var = (u32)[views + (int)temp_views];
			(u32)[a + (int)a_temp] = var;

			a_temp += 4;
			temp_views += 4;
			j += 1;
		}
		i+= 1;
	}
	
	
	return views, a;
}















/******************************
*                             *
*  SHA256 auxiliar functions  *
*                             *
******************************/


fn ROTLEFT(reg u32 a, reg u8 b) -> reg u32{

	a = ((a << b) | (a >> (32 - b)));
	return a;
} 

fn ROTRIGHT(reg u32 a, reg u8 b) -> stack u32 {

	a = ((a >> b) | (a << (32 - b)));
	return a;
}

fn ROTRIGHT_2(reg u32 a) -> stack u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 2;
	a_aux <<= 30;

	a |= a_aux;

	return a;
}

fn ROTRIGHT_13(reg u32 a) -> stack u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 13;
	a_aux <<= 19;

	a |= a_aux;

	return a;
}

fn ROTRIGHT_22(reg u32 a) -> stack u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 22;
	a_aux <<= 10;

	a |= a_aux;

	return a;
}

fn ROTRIGHT_6(reg u32 a) -> stack u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 6;
	a_aux <<= 26;

	a |= a_aux;

	return a;
}

fn ROTRIGHT_11(reg u32 a) -> stack u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 11;
	a_aux <<= 21;

	a |= a_aux;

	return a;
}

fn ROTRIGHT_25(reg u32 a) -> stack u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 25;
	a_aux <<= 7;

	a |= a_aux;

	return a;
}


inline
fn EP0(stack u32 x) -> reg u32{

    reg u32 res, res1, res2;
    stack u32 r,r1,r2;


    res = x;
    res = ROTRIGHT_2(res);
    r = res;

    res1 = x;
    res1 = ROTRIGHT_13(res1);
    r1 = res1;


    res2 = x;
    res2 = ROTRIGHT_22(res2);
    r2 = res2;
    
    res = r;
    res1 = r1;
    res ^= res1;
    res2 = r2;
    res ^= res2;

    return res;
}

inline
fn EP1(stack u32 x) -> reg u32{

    reg u32 res, res1, res2;

    res = x;
    res = ROTRIGHT_6(res);

    res1 = x;
    res1 = ROTRIGHT_11(res1);
    
    res2 = x;
    res2 = ROTRIGHT_25(res2);

    res ^= res1;
    res ^= res2;

    return res;
} 


fn ROTRIGHT_7(reg u32 a) -> reg u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 7;
	a_aux <<= 25;

	a ^= a_aux;

	return a;
}

fn ROTRIGHT_18(reg u32 a) -> reg u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 18;
	a_aux <<= 14;

	a ^= a_aux;

	return a;
}

fn ROTRIGHT_17(reg u32 a) -> reg u32 {

	reg u32 a1, a2;

	a1 = a;
	a1 >>= 17;

    a2 = a;
	a2 <<= 15;

	a1 |= a2;

	return a1;
}

fn ROTRIGHT_19(reg u32 a) -> reg u32 {

	reg u32 a1, a2;

	a1 = a;
	a1 >>= 19;

    a2 = a;
	a2 <<= 13;

	a1 |= a2;

	return a1;
}

inline
fn SIG0(reg u32 x) -> reg u32 {

    reg u32 x0, x1;

    x0 = x;
    x0 = ROTRIGHT_7(x0);

    x1 = x;
    x1 = ROTRIGHT_18(x1);

    x >>= 3;

    x0 ^= x1;
    x0 ^= x;

    return x0;
}

inline
fn SIG1(reg u32 x) -> reg u32{
    reg u32 x0, x1, x2;

    x0 = x;
    x0 = ROTRIGHT_17(x0);
    
    x1 = x;
    x1 = ROTRIGHT_19(x1);

    x2 = x;
    x2 = (x2 >> 10); 

    x0 ^= x1;
    x0 ^= x2;

    return x0;
}

inline
fn CH(stack u32 x, stack u32 y, stack u32 z) -> reg u32{
    
    reg u32 t0, t1;

    t0 = x;
    t0 &= y;

    t1 = x;
    t1 ^= 0xFFFFFFFF;
    t1 &= z;

    t0 ^= t1;

    return t0;
}

inline
fn MAJ(stack u32 x, stack u32 y, stack u32 z) -> reg u32{

    reg u32 t0, t1, tx, ty, tz;

    t0 = x;
    ty = y;
    t0 = t0 & ty;

    t1 = x;
    tz = z;
    t1 &= tz;
    t0 ^= t1;

    t1 = y;
    tz = z;
    t1 &= tz;
    t0 ^= t1;

    return t0;
}

inline
fn initializeK(stack u32[64] k) -> stack u32[64]{
    k[0] = 0x428a2f98;
    k[1] = 0x71374491;
    k[2] = 0xb5c0fbcf;
    k[3] = 0xe9b5dba5;
    k[4] = 0x3956c25b;
    k[5] = 0x59f111f1;
    k[6] = 0x923f82a4;
    k[7] = 0xab1c5ed5;
    k[8] = 0xd807aa98;
    k[9] = 0x12835b01;
    k[10] = 0x243185be;
    k[11] = 0x550c7dc3;
    k[12] = 0x72be5d74;
    k[13] = 0x80deb1fe;
    k[14] = 0x9bdc06a7;
    k[15] = 0xc19bf174;
    k[16] = 0xe49b69c1;
    k[17] = 0xefbe4786;
    k[18] = 0x0fc19dc6;
    k[19] = 0x240ca1cc;
    k[20] = 0x2de92c6f;
    k[21] = 0x4a7484aa;
    k[22] = 0x5cb0a9dc;
    k[23] = 0x76f988da;
    k[24] = 0x983e5152;
    k[25] = 0xa831c66d;
    k[26] = 0xb00327c8;
    k[27] = 0xbf597fc7;
    k[28] = 0xc6e00bf3;
    k[29] = 0xd5a79147;
    k[30] = 0x06ca6351;
    k[31] = 0x14292967;
    k[32] = 0x27b70a85;
    k[33] = 0x2e1b2138;
    k[34] = 0x4d2c6dfc;
    k[35] = 0x53380d13;
    k[36] = 0x650a7354;
    k[37] = 0x766a0abb;
    k[38] = 0x81c2c92e;
    k[39] = 0x92722c85;
    k[40] = 0xa2bfe8a1;
    k[41] = 0xa81a664b;
    k[42] = 0xc24b8b70;
    k[43] = 0xc76c51a3;
    k[44] = 0xd192e819;
    k[45] = 0xd6990624;
    k[46] = 0xf40e3585;
    k[47] = 0x106aa070;
    k[48] = 0x19a4c116;
    k[49] = 0x1e376c08;
    k[50] = 0x2748774c;
    k[51] = 0x34b0bcb5;
    k[52] = 0x391c0cb3;
    k[53] = 0x4ed8aa4a;
    k[54] = 0x5b9cca4f;
    k[55] = 0x682e6ff3;
    k[56] = 0x748f82ee;
    k[57] = 0x78a5636f;
    k[58] = 0x84c87814;
    k[59] = 0x8cc70208;
    k[60] = 0x90befffa;
    k[61] = 0xa4506ceb;
    k[62] = 0xbef9a3f7;
    k[63] = 0xc67178f2;

    return k;
}

inline
fn dbl_int_add(stack u32[2] ctx_bitlen, reg u64 c) -> stack u32[2] {

	reg u32 a, b;
	
	a = ctx_bitlen[0];
	
	b = 0xffffffff;
	b -= c;

	if(a > b){
		a = ctx_bitlen[1];
		a += 1; 
		ctx_bitlen[1] = a;
	} else {
		a += c;
		ctx_bitlen[0] = a;
	}

	return ctx_bitlen;
}

inline
fn compute_t1(stack u32 e, stack u32 f, stack u32 g, stack u32 h, stack u32[64] k, stack u32[64] m, reg u64 i) -> reg u32{

	reg u32 t, t1;

	t1 = h;
		
	t = EP1(e);
	t1 += t;

	t = CH(e,f,g);
	t1 += t;

	t = k[(int)i];
	t1 += t;
	
	t = m[(int)i];
	t1 += t;

	return t1;
}

inline
fn compute_t2(stack u32 a, stack u32 b, stack u32 c) -> reg u32{
	
	reg u32 t, t2;


	t2 = EP0(a);
	
	t = MAJ(a, b, c); 
	t2 += t;
	

	return t2;
}

inline
fn sha256_transform(stack u32[8] ctx_state, stack u8[64] ctx_data) -> stack u32[8], stack u8[64]
{
    stack u32 a, b, c, d, e, f, g, h;
    reg u32 t0, t1, t2, temp;

    stack u32[64] m;

    reg u32 sig0, sig1;

    reg u64 i, j,z;

    inline int idx;

    reg u8 t8;

    stack u32[64] k;
    k = initializeK(k);
    

    /* IGUAL!! */
    i = 0;
    z = 0;
    while(i < 16){

        t0 = ctx_data[u32 (int)i];

        t0 = #BSWAP_32(t0);

        m[(int)i] = t0;

        i += 1;
    }
    

    /* IGUAL */
    z = 0;
    while(i < 64){

        j = i;
        j -= 2;
        temp = m[(int)j];
        temp = SIG1(temp);
        m[(int)i] = temp;

        j = i;
        j -= 7;
        temp =  m[(int)j];
        m[(int)i] += temp;

        j = i;
        j -= 15;
        temp = m[(int)j];
        temp = SIG0(temp);
        m[(int)i] += temp;

        j = i;
        j -= 16;
        temp =  m[(int)j];
        m[(int)i] += temp;
        
        i += 1;
    } 
    

    temp = ctx_state[0];
    a = temp;
    temp = ctx_state[1];
    b = temp;
    temp = ctx_state[2];
    c = temp;
    temp = ctx_state[3];
    d = temp;
    temp = ctx_state[4];
    e = temp;
    temp = ctx_state[5];
    f = temp;
    temp = ctx_state[6];
    g = temp;
    temp = ctx_state[7];
    h = temp;

    
    i = 0;
    j = 0;
    while(i < 64){

    	t1 = compute_t1(e, f, g, h, k, m, i);
    	t2 = compute_t2(a,b,c);
        
        t0 = g;
        h = t0;

        t0 = f;
        g = t0;

        t0 = e;
        f = t0;

        t0 = d;
        t0 += t1;
        e = t0;


        t0 = c;
        d = t0;

        t0 = b;
        c = t0;

        t0 = a;
        b = t0;

        t0 = t1;
        t0 += t2;
        a = t0;

        j += 4;
        i += 1;
    }

    temp = ctx_state[0];
    temp += a;
    ctx_state[0] = temp;

    temp = ctx_state[1];
    temp += b;
    ctx_state[1] = temp;

    temp = ctx_state[2];
    temp += c;
    ctx_state[2] = temp;

    temp = ctx_state[3];
    temp += d;
    ctx_state[3] = temp;

    temp = ctx_state[4];
    temp += e;
    ctx_state[4] = temp;

    temp = ctx_state[5];
    temp += f;
    ctx_state[5] = temp;

    temp = ctx_state[6];
    temp += g;
    ctx_state[6] = temp;

    temp = ctx_state[7];
    temp += h;
    ctx_state[7] = temp;
    
    return ctx_state, ctx_data;
}


inline
fn sha256_update1(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u8[16] data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u8 t;
    stack u64 i_aux;
    reg u64 c;

    i = 0;
    while(i < len){

    	t = data[(int)i];
    	i_aux = i;

    	temp = ctx_datalen;
    	ctx_data[(int)temp] = t;
    	temp += 1;
    	ctx_datalen = temp;

    	if(ctx_datalen == 64){
    		ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
    		c = 512;
    		ctx_bitlen = dbl_int_add(ctx_bitlen,c);
    		ctx_datalen = 0;
    	}
    	
    	i = i_aux;
    	i += 1;
    }
    
    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}


inline
fn sha256_update2(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u8[64] data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u8 t;
    stack u64 i_aux;

    i = 0;
    while(i < len){
        i_aux = i;
        t = data[(int)i];

        temp = ctx_datalen;
        ctx_data[(int)temp] = t;
        temp += 1;
        ctx_datalen = temp;

        if(ctx_datalen == 64){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,temp);
            ctx_datalen = 0;
        }

        i = i_aux;
        i += 1;
    }
    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}

inline
fn sha256_update3(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u8[1480] data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u8 t;
    stack u64 i_aux;
    reg u32 c;

    i = 0;
    while(i < len){
        t = data[(int)i];

        temp = ctx_datalen;
        ctx_data[(int)temp] = t;
        temp += 1;
        ctx_datalen = temp;

        if(ctx_datalen == 64){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,temp);
            ctx_datalen = 0;
        }

        i += 1;
    }
    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}


inline
fn sha256_update4(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u8[4] data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u8 t;
    stack u64 i_aux;

    i = 0;
    while(i < len){
        t = data[(int)i];
        i_aux = i;
        
        temp = ctx_datalen;
        ctx_data[(int)temp] = t;
        temp += 1;
        ctx_datalen = temp;
        
        if(temp == 64){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,temp);
            ctx_datalen = 0;
        }

        i = i_aux;
        i += 1;
    }

    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}

inline
fn sha256_final1(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, reg u64 a, reg u64 round_idx, reg u64 player_idx, stack u64 mpcRounds) -> stack u32[8], stack u8[64], reg u64
{
    reg u64 i, temp;
    reg u32 value;
    reg u32 stored_value;
    reg u64 a_temp;
    stack u64 i_aux;
    reg u8 t8;

    // Pad whatever data is left in the buffer.
    

    i = ctx_datalen;

    if (i < 56) {
        ctx_data[(int)i] = 0x80;
        i += 1;
        while (i < 56){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
    }    
    else {
        ctx_data[(int)i] = 0x80;
        i += 1;
        while (i < 64){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
        ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);

        i = 0;
        while(i < 56){
        	ctx_data[(int)i] = 0x00;
        	i += 1;
        }
    }


    // Append to the padding the total message's length in bits and transform.
    

    temp = ctx_datalen;
    temp *= 8;
    ctx_bitlen = dbl_int_add(ctx_bitlen, temp);

    value = ctx_bitlen[0];
    value = #BSWAP_32(value);
    ctx_data[u32 15] = value;

    value = ctx_bitlen[1];
    value = #BSWAP_32(value);
    ctx_data[u32 14] = value;
	
	ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
    

    /* Set addrs to a.h */

    a_temp = 32 * mpcRounds;
    a_temp *= 3;

    /* Set addrs to a.h[player_idx] */

    temp = player_idx;
    temp *= 32;
    temp *= mpcRounds;

    a_temp += temp;

    /* Set current roud hash position */

    temp = 32 * round_idx;

    a_temp += temp;


    
    i = 0;
    while(i < 8){

    	value = ctx_state[(int)i];

    	value = #BSWAP_32(value);

    	(u32)[a + (int)a_temp] = value;

    	a_temp += 4;
    	i += 1;
    }
    

    return ctx_state, ctx_data, a; 
}

/*****************
*                *
*   H - SHA256   *
*                *
*****************/

inline
fn H(reg u64 keys_shares, reg u64 views, reg u64 rs, reg u64 a, stack u64 mpcRounds) {

	reg u64 i, j, z, temp, keys_addrs, views_addrs, rs_addrs, aux_z, views_x, aux;
	stack u64 i_aux, j_aux;

	stack u64 ctx_datalen;
	stack u32[2] ctx_bitlen;
	stack u32[8] ctx_state;
    stack u8[64] ctx_data;

	stack u8[16] keys_aux;
	stack u8[64] viewsX_aux;
	stack u8[1480] viewsY_aux;
	stack u8[4] rs_aux;

	reg u8 data;
	reg u8 len;


	i = 0;
    while(i < mpcRounds){

        j = 0;
        while(j < 3){

            ctx_datalen = 0;
            ctx_bitlen[0] = 0;
            ctx_bitlen[1] = 0;
            ctx_state[0] = 0x6a09e667;
            ctx_state[1] = 0xbb67ae85;
            ctx_state[2] = 0x3c6ef372;
            ctx_state[3] = 0xa54ff53a;
            ctx_state[4] = 0x510e527f;
            ctx_state[5] = 0x9b05688c;
            ctx_state[6] = 0x1f83d9ab;
            ctx_state[7] = 0x5be0cd19;

            /* Keys */


            keys_addrs = j * 16;
            keys_addrs *= mpcRounds;


            temp = i * 16;
            keys_addrs += temp;

            z = 0;
            while(z < 16){

                data = (u8)[keys_shares + (int)keys_addrs];
                keys_aux[(int)z] = data;
                
                keys_addrs += 1;
                z += 1;
            } 


            /* Views.x */

            views_addrs = j;
            views_addrs *= 64;
            views_addrs *= mpcRounds;

            temp = i;
            temp *= 64;
            views_addrs += temp;

            z = 0;
            while(z < 64){

                viewsX_aux[(int)z] = (u8)[views + (int)views_addrs];

                views_addrs += 1;
                z += 1;
            }


            /* Views.y */

            views_addrs = j;
            views_addrs *= 1480;
            views_addrs *= mpcRounds;

            views_x = 64 * mpcRounds;
            views_x *= 3;
            views_addrs += views_x;

            temp = i;
            temp *= 1480;
            views_addrs += temp;

            z = 0; 
            while(z < 1480){

                viewsY_aux[(int)z] = (u8)[views + (int) views_addrs];

                views_addrs += 1;
                z += 1;
            } 

            /* rs */

            rs_addrs = j;
            rs_addrs *= 4;
            rs_addrs *= mpcRounds;

            temp = i;
            temp *= 4;
            rs_addrs += temp;

            z = 0;
            while(z < 4){
                rs_aux[(int)z] = (u8)[rs + (int) rs_addrs];
                rs_addrs += 1;
                z += 1;
            }

            i_aux = i;
            j_aux = j;
            ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update1(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, keys_aux, 16);

            ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update2(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, viewsX_aux, 64);
            
            ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update3(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, viewsY_aux, 1480);
            
            ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update4(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, rs_aux, 4);
            

            i = i_aux;
            j = j_aux;
            ctx_state, ctx_data, a = sha256_final1(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, a, i, j, mpcRounds);


            j += 1;
        }

        i += 1;
    }

}






inline
fn sha256_update5(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u8[32] data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u8 t;
    stack u64 i_aux;
    
    i = 0;
    while(i < len){
        t = data[(int)i];
        i_aux = i;
        
        temp = ctx_datalen;
        ctx_data[(int)temp] = t;
        temp += 1;
        ctx_datalen = temp;
        
        if(ctx_datalen == 64){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,temp);
            ctx_datalen = 0;
        }

        i = i_aux;
        i += 1;
    }
    

    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}

inline
fn sha256_update6(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u8[26112] data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u8 t;
    stack u64 i_aux;

    i = 0;
    while(i < len){
        t = data[(int)i];
        i_aux = i;
        
        temp = ctx_datalen;
        ctx_data[(int)temp] = t;
        temp += 1;
        ctx_datalen = temp;
        
        if(temp == 64){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,temp);
            ctx_datalen = 0;
        }

        i = i_aux;
        i += 1;
    }

    
    temp = ctx_datalen;
    while(temp < 64){
    	ctx_data[(int)temp] = 0;
    	temp += 1;
    }
    

    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}


inline
fn sha256_final2(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u32[8] hash) -> stack u8[64], stack u32[8]
{
    reg u64 i, temp;
    reg u64 j;
    reg u32 t, value, stored_value;


    // Pad whatever data is left in the buffer.

    i = ctx_datalen;

    if (i < 56) {
        ctx_data[(int)i] = 0x80;
        i += 1;
        while (i < 56){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
    }    
    else {
        ctx_data[(int)i] = 0x80;
        i += 1;
        while (i < 64){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
        ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);

        i = 0;
        while(i < 56){
        	ctx_data[(int)i] = 0x00;
        	i += 1;
        }
    }


    // Append to the padding the total message's length in bits and transform.
    

    temp = ctx_datalen;
    temp *= 8;
    ctx_bitlen = dbl_int_add(ctx_bitlen, temp);

    value = ctx_bitlen[0];
    value = #BSWAP_32(value);
    ctx_data[u32 15] = value;

    value = ctx_bitlen[1];
    value = #BSWAP_32(value);
    ctx_data[u32 14] = value;
	
	ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);


    // Since this implementation uses little endian byte ordering and SHA uses big endian,
    // reverse all the bytes when copying the final state to the output hash.

    i = 0;
    while(i < 8){

    	value = ctx_state[(int)i];

    	value = #BSWAP_32(value);

    	hash[(int)i] = value;

        i += 1;
    }

    return ctx_data, hash;
}

/*****************
*                *
*       H3       *
*                *
*****************/

inline
fn H3(stack u32[8] y, reg u64 a, stack u64 s, stack u64[136] es) -> stack u64[136] {


	stack u32[8] hash; // unsigned char hash[SHA256_DIGEST_LENGTH];
	
	stack u8[64] ctx_data;
	stack u64 ctx_datalen;
	stack u32[2] ctx_bitlen;
	stack u32[8] ctx_state;

	reg u64 i, j, z, es_aux, temp, temp_as, temp_a;
	reg u64 bitTracker;
	reg u8 b1, b2;
	reg u32 j_aux;

	stack u64 bitTracker_aux;

	inline int len;

	reg u8 t;

	reg u64 counter;
	stack u64 counter_s;


	stack u8[32] hash_s;
	stack u8[26112] a_s; // 192 * mpcRounds

	ctx_datalen = 0;
    ctx_bitlen[0] = 0;
    ctx_bitlen[1] = 0;
    ctx_state[0] = 0x6a09e667;
    ctx_state[1] = 0xbb67ae85;
    ctx_state[2] = 0x3c6ef372;
    ctx_state[3] = 0xa54ff53a;
    ctx_state[4] = 0x510e527f;
    ctx_state[5] = 0x9b05688c;
    ctx_state[6] = 0x1f83d9ab;
    ctx_state[7] = 0x5be0cd19;

    counter_s = 0;

    i = 0;
    while(i < 20){
    	t = y[u8 (int)i];
    	hash_s[(int)i] = t;
    	i += 1;
    }

    i = 0;
    while(i < 64){
    	ctx_data[(int)i] = 0;
    	i += 1;
    }


	ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update5(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash_s, 20);


	i = 0;
	while(i < s){

		j = 0;
		while(j < 3){

			/* a.yp */

			temp_as = i * 192;

			temp = j * 32;
			temp_as += temp;


			temp_a = s * 32;
			temp_a *= j;

			temp = i * 32;
			temp_a += temp;

			z = 0;
			while(z < 32){
				t = (u8)[a + (int) temp_a];
				a_s[(int) temp_as] = t;

				temp_as += 1;
				temp_a += 1;
				z += 1;
			}
			

			/* a.h */

			temp_as = i * 192;

			temp = 3 * 32;
			temp_as += temp;

			temp = j * 32;
			temp_as += temp;


			temp_a = s * 32;
			temp_a *= 3;

			temp = s * 32;
			temp *= j;
			temp_a += temp;

			temp = i * 32;
			temp_a += temp;

			z = 0;
			while(z < 32){
				t = (u8)[a + (int) temp_a];
				a_s[(int) temp_as] = t;

				temp_as += 1;
				temp_a += 1;
				z += 1;
			}

			j += 1;
		}
		
		i += 1;
	}
	

	ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update6(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, a_s, 26112);
	

	ctx_data, hash = sha256_final2(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash);

		
	//Pick bits from hash
	i = 0;
	bitTracker_aux = 0;
	bitTracker = bitTracker_aux;
    
	while(i < s) {

		if(bitTracker_aux >= 256) { //Generate new hash

			ctx_datalen = 0;
            ctx_bitlen[0] = 0;
            ctx_bitlen[1] = 0;
            ctx_state[0] = 0x6a09e667;
            ctx_state[1] = 0xbb67ae85;
            ctx_state[2] = 0x3c6ef372;
            ctx_state[3] = 0xa54ff53a;
            ctx_state[4] = 0x510e527f;
            ctx_state[5] = 0x9b05688c;
            ctx_state[6] = 0x1f83d9ab;
            ctx_state[7] = 0x5be0cd19;

            j = 0;
		    while(j < 32){
		    	t = hash[u8 (int)j];
		    	hash_s[(int)j] = t;
		    	j += 1;
		    }

			ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update5(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash_s, 32);
			ctx_data, hash = sha256_final2(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash);

			bitTracker = 0;
		}
		bitTracker_aux = bitTracker;
		
		b1 = GETBIT_EXTENDED(hash, bitTracker_aux);
		bitTracker = bitTracker_aux;
		bitTracker += 1;
		bitTracker_aux = bitTracker;
		b2 = GETBIT_EXTENDED(hash, bitTracker_aux);
		
		if(b1 == 0) {
			if(b2 == 0) {
				es[(int)i] = 0;
				i += 1;
			} else {
				es[(int)i] = 1;
				i += 1;
			}
		} 
		else {
			if(b2 == 0) {
				es[(int)i] = 2;

				i += 1;
			}
		}

		bitTracker = bitTracker_aux;
		bitTracker += 1; 				// alredy added 1 priviously!!
	}
	
	return es;
}

/*****************
*                *
*     Prove      *
*                *
*****************/

inline
fn prove(stack u64[136] es, reg u64 keys_shares, reg u64 rs, reg u64 views, reg u64 zs, stack u64 mpcRounds) {

	reg u64 i, j, player0, player1;
	reg u64 temp_zs, temp_keys, x_player_view_offset, y_player_view_offset, temp_views, temp_rs, temp_aux, temp;
	reg u8 t;

	i = 0;
	temp_zs = 0;

	while(i < mpcRounds){

		player0 = es[(int)i];
		player1 = es[(int)i];
		player1 += 1;

		if(player1 == 3){
			player1 = 0;
		}


		/* Copy both players keys */

		temp_aux = i * 16;

		temp_keys = player0 * 16;
		temp_keys *= mpcRounds;
		temp_keys += temp_aux;

		j = 0;
		while(j < 16){

			t = (u8)[keys_shares + (int)temp_keys];
			(u8)[zs + (int)temp_zs] = t;

			temp_zs += 1;
			temp_keys += 1;
			j += 1;
		}

		temp_keys = player1 * 16;
		temp_keys *= mpcRounds;
		temp_keys += temp_aux;

		j = 0;
		while(j < 16){

			t = (u8)[keys_shares + (int)temp_keys];
			(u8)[zs + (int)temp_zs] = t;

			temp_zs += 1;
			temp_keys += 1;
			j += 1;
		}

		
		/* Copy player 0 view */


		x_player_view_offset = mpcRounds * 64;
		x_player_view_offset *= player0;

		temp_views = i * 64;					// set current view_x
		temp_views += x_player_view_offset;

		j = 0;
		while(j < 64){
			
			t = (u8)[views + (int)temp_views];
			(u8)[zs + (int)temp_zs] = t;

			temp_views += 1;
			temp_zs += 1;
			j += 1;
		}

		y_player_view_offset = mpcRounds * 3;	// total views_x of the three players
		y_player_view_offset *= 64;

		temp_aux = 1480 * mpcRounds;			// offset to player0's views_y
		temp_aux *= player0;
		y_player_view_offset += temp_aux;		

		temp_aux = i * 1480;					// offset for this round
		y_player_view_offset += temp_aux;

		temp_views = y_player_view_offset;

		j = 0;
		while(j < 1480){

			t = (u8)[views + (int)temp_views];
			(u8)[zs + (int)temp_zs] = t;

			temp_zs += 1;
			temp_views += 1;
			j += 1;
		}

		/* Copy player 1 view */

		x_player_view_offset = mpcRounds * 64;
		x_player_view_offset *= player1;

		temp_views = i * 64;						// set current view_x		
		temp_views += x_player_view_offset;


		j = 0;
		while(j < 64){

			t = (u8)[views + (int)temp_views];
			(u8)[zs + (int)temp_zs] = t;

			temp_views += 1;
			temp_zs += 1;
			j += 1;
		}

		y_player_view_offset = mpcRounds * 3;	// total views_x of the three players
		y_player_view_offset *= 64;

		temp_aux = 1480 * mpcRounds;
		temp_aux *= player1;
		y_player_view_offset += temp_aux;		// offset to player1 views_y

		temp_aux = i * 1480;					// offset for this round
		y_player_view_offset += temp_aux;


		temp_views = y_player_view_offset;

		j = 0;
		while(j < 1480){

			t = (u8)[views + (int)temp_views];
			(u8)[zs + (int)temp_zs] = t;

			temp_views += 1;
			temp_zs += 1;
			j += 1;
		}


		temp_rs = 4 * player0;
		temp_rs *= mpcRounds;

		temp = 4 * i;
		temp_rs += temp;

		j = 0;
		while(j < 4){

			t = (u8)[rs + (int)temp_rs];
			(u8)[zs + (int)temp_zs] = t;

			temp_zs += 1;
			temp_rs += 1;
			j += 1;
		}


		temp_rs = 4 * player1;
		temp_rs *= mpcRounds;

		temp = 4 * i;
		temp_rs += temp;

		j = 0;
		while(j < 4){

			t = (u8)[rs + (int)temp_rs];
			(u8)[zs + (int)temp_zs] = t;
			
			temp_zs += 1;
			temp_rs += 1;
			j += 1;
		}

		i += 1;
	}
}





/*********************************************************************
*                                                                    *
*     This ZKBoo version is running on 128 rounds. If you decide to  *
*   increase the number of rounds, please multiply the stack arrays  *
*   needed in it by the number of MPC rounds divided by 128.         *
*                                                                    *
*********************************************************************/

inline
fn preparationZKBoo(reg u64 rs, reg u64 randomValues, reg u64 keys_shares, reg u64 zs, reg u64 views, reg u64 a) {

	
	/****************************************/
	/*  Allocate space for ZKBoo variables  */
	/*                                      */
    /*	- Keys and key shares;              */
    /*	- Views and random value arrays;    */
    /*  - Tracking variables;               */
    /*  - Commit and challenge arrays;      */
    /*  - Proofs array;                     */
    /*                                      */
	/****************************************/



	stack u8[16] k0, k1, k2;

	reg u64 i, j, z;
	stack u64 mpcRounds, numBytes;
	reg u64  temp, temp_views, temp_aux;



	stack u64 zs_s;

	stack u32[8] finalHash;
	stack u64[136] es;

	reg u32 a_aux, b_aux;


	/**************************************/
	/*      Initialize ZKBoo values       */
	/**************************************/

	mpcRounds = 136;
	numBytes = 16 * 8;

	zs_s = zs;
	

	/************************/
	/*  Process MPC rounds  */
	/************************/
	
	i = 0;
	while(i < mpcRounds){

		views, a = commits(numBytes, keys_shares, randomValues, views, a, i, mpcRounds);

		H(keys_shares, views, rs, a, mpcRounds);

		i += 1;
	}
	
	
	/************************/
	/*  Generate Challenge  */
	/************************/
	
	
	temp_aux = 32;
	temp_aux *= mpcRounds;

	j = 0;
	i = 0;
	while(j<8){
		temp = j * 4;

		a_aux = (u32)[a + (int)temp];

		temp += temp_aux;

		a_aux ^= (u32)[a + (int)temp];

		//a_aux ^= b_aux;

		temp += temp_aux;

		a_aux ^= (u32)[a + (int)temp];

		finalHash[(int)j] = a_aux;
		
		i += 4;
		j += 1;
	}
	
	
	es = H3(finalHash, a, mpcRounds, es);
	
	/***********************/
	/*   Assemble proofs   */
	/***********************/
	
	zs = zs_s;
	prove(es, keys_shares, rs, views, zs, mpcRounds);
	
}


/***************************************************
*                                                  *
* This function receives arrays and values with    *
* random bytes used by the ZKBoo scheme.           *
*                                                  *
*	- Public Key                                   *
* 	- Keys_Shares( Keys[768], Shares[768] )        *
*	- Randomness                                   *
*   - Proofs                                       *
*	- Views( Views_x[3072], Views_y[71040] )       *
*	- A( A_yp[12288], A_h[12288] )                 *
*                                                  *
***************************************************/

export fn zkboo_encrypt(reg u64 rs, reg u64 randomValues, reg u64 keys_shares, reg u64 proofs, reg u64 views, reg u64 a){

	preparationZKBoo(rs, randomValues, keys_shares, proofs, views, a);
}
















