/*
ySize = 370;

typedef struct {
	unsigned char x[64]; 	// u64[8]
	uint32_t y[ySize];   	// u64[185]
} View;


typedef struct {
	uint32_t yp[3][8];      // u64[12]
	unsigned char h[3][32]; // u64[12] 
} a;


typedef struct {
	unsigned char ke[16];	// u64[2]
	unsigned char ke1[16];	// u64[2]
	View ve;				// u64[24]
	View ve1;				// u64[24]
	unsigned char re[4];	// u32
	unsigned char re1[4];	// u32
} z;

shares // u64[6]

*/

export
fn shares_xor(reg u64 player2, reg u64 input, reg u64 player0, reg u64 player1) {
	reg u64 i, storage_u64;

	i = 0;
	while(i<16){

		storage_u64 = (u64)[input + (int)i];


		storage_u64 ^= (u64)[player0 + (int)i];


		storage_u64 ^= (u64)[player1 + (int)i];

		(u64)[player2 + (int)i] = storage_u64;
		
		i += 8;
	}
}


inline
fn GETBIT_u32_inline(reg u32 x, inline int bit_idx) -> reg u32 {
	
	reg u64 aux;

	x = x >> bit_idx;

	x &= 0x00000001; 
	
	return x;	
}


inline
fn getBits_inline(stack u32[3] array_r, stack u32[3] array_c, inline int i, reg u64 idx0, reg u64 idx1) -> reg u32, reg u32, reg u32 {


	reg u32 word0, word1, word2;

	word0 = array_r[(int)idx0];
	word1 = array_c[(int)idx1];
	word2 = array_r[(int)idx1];


	word0 = GETBIT_u32_inline(word0, i);
	word1 = GETBIT_u32_inline(word1, i);
	word2 = GETBIT_u32_inline(word2, i);

	return word0, word1, word2;
}


inline
fn SETBIT_c_inline(reg u32 x, inline int bit_idx, reg u32 bit) -> reg u32 {

	reg u32 x0;
	reg u64 idx;

	x0 = 1;

	x0 <<= bit_idx;

	bit &= 0x00000001;

	if(bit == 0x00000001){
		x |= x0;
	} else{
		x0 ^= 0xffffffff;
		x &= x0;
	}

	return x;
}


inline
fn w_to_temp(stack u32[3] temp, stack u32[240] w, reg u64 pos_w) -> stack u32[3]{

	reg u32 aux0, aux1;

	/* Player 0 */

	aux0 = w[(int)pos_w - 9];
	aux1 = w[(int)pos_w - 24];

	aux0 ^= aux1;

	aux1 = w[(int)pos_w - 42];

	aux0 ^= aux1;

	aux1 = w[(int)pos_w - 48];

	aux0 ^= aux1;

	temp[0] = aux0;


	/* Player 1 */

	aux0 = w[(int)pos_w - 8];
	aux1 = w[(int)pos_w - 23];

	aux0 ^= aux1;

	aux1 = w[(int)pos_w - 41];

	aux0 ^= aux1;

	aux1 = w[(int)pos_w - 47];

	aux0 ^= aux1;

	temp[1] = aux0;


	/* Player 2 */


	aux0 = w[(int)pos_w - 7];
	aux1 = w[(int)pos_w - 22];

	aux0 ^= aux1;

	aux1 = w[(int)pos_w - 40];

	aux0 ^= aux1;

	aux1 = w[(int)pos_w - 46];

	aux0 ^= aux1;

	temp[2] = aux0;

	return temp;
}

inline
fn mpc_words_k(stack u32[3] x, stack u32[3] y, stack u32 k, inline int j) -> reg u32, reg u32 {


	reg u32 a, b, c;
	reg u32 word_a, word_b;

	a = x[j];
	b = y[j];
	c = k;

	word_a = a ^ b;
	word_b = c ^ b;

	return word_a, word_b;
}


inline
fn mpc_LEFTROTATE_w(stack u32[3] x, reg u64 i, stack u32[240] w, reg u64 pos_w) -> stack u32[240] {
	
	reg u32 storage_u32, x_0;
	reg u64 n, pos_aux;

	/* Player 0 */

	pos_aux = pos_w;
	storage_u32 = x[0];
	n = i;
	while(n > 0){
		storage_u32 <<= 1;
		n -= 1;
	}

	n = 32;

	x_0 = x[0];

	while(n > i){
		x_0 >>= 1;

		n -= 1;
	}
	
	storage_u32 |= x_0;

	w[(int)pos_aux] = storage_u32;


	/* Player 1 */

	pos_aux += 1;
	storage_u32 = x[1];
	n = i;
	while(n > 0){
		storage_u32 <<= 1;
		n -= 1;
	}

	n = 32;

	x_0 = x[1];

	while(n > i){
		x_0 >>= 1;

		n -= 1;
	}
	
	storage_u32 |= x_0;

	w[(int)pos_aux] = storage_u32;

	

	/* Player 2 */

	pos_aux += 1;

	storage_u32 = x[2];
	n = i;
	while(n > 0){
		storage_u32 <<= 1;
		n -= 1;
	}

	n = 32;

	x_0 = x[2];

	while(n > i){
		x_0 >>= 1;

		n -= 1;
	}
	
	storage_u32 |= x_0;

	w[(int)pos_aux] = storage_u32;

	return w;
}

inline
fn mpc_xor(stack u32[3] x, stack u32[3] y, stack u32[3] z) -> stack u32[3] {
	
	reg u32 aux;

	aux = x[0];
	aux ^= y[0];
	z[0] = aux;

	aux = x[1];
	aux ^= y[1];
	z[1] = aux;

	aux = x[2];
	aux ^= y[2];
	z[2] = aux;

	return z;
}

inline
fn mpc_LEFTROTATE_5(stack u32[3] a, stack u32[3] temp) -> stack u32[3] {
	
	reg u32 storage_u32, storage_aux; 
	
	storage_u32 = a[0];
	storage_aux = storage_u32;
	storage_u32 = storage_u32 << 5;
	storage_aux = storage_aux >> 27;
	storage_u32 |= storage_aux;
	temp[0] = storage_u32;

	storage_u32 = a[1];
	storage_aux = storage_u32;
	storage_u32 = storage_u32 << 5;
	storage_aux = storage_aux >> 27;
	storage_u32 |= storage_aux;
	temp[1] = storage_u32;

	storage_u32 = a[2];
	storage_aux = storage_u32;
	storage_u32 = storage_u32 << 5;
	storage_aux = storage_aux >> 27;
	storage_u32 |= storage_aux;
	temp[2] = storage_u32;

	return temp;
}

inline
fn mpc_LEFTROTATE_30(stack u32[3] a, stack u32[3] temp) -> stack u32[3] {
	
	reg u32 storage_u32, storage_aux; 
	
	storage_u32 = a[0];
	storage_aux = a[0];
	storage_u32 = storage_u32 << 30;
	storage_aux = storage_aux >> 2;
	storage_u32 |= storage_aux;
	temp[0] = storage_u32;

	storage_u32 = a[1];
	storage_aux = a[1];
	storage_u32 = storage_u32 << 30;
	storage_aux = storage_aux >> 2;
	storage_u32 |= storage_aux;
	temp[1] = storage_u32;

	storage_u32 = a[2];
	storage_aux = a[2];
	storage_u32 = storage_u32 << 30;
	storage_aux = storage_aux >> 2;
	storage_u32 |= storage_aux;
	temp[2] = storage_u32;

	return temp;
}

inline
fn mpc_ADD(stack u32[3] x, stack u32[3] y, stack u32[3] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY) -> stack u32[3], reg u64, reg u64 {

	stack u32[3] c, r, a, b;
	reg u32 t, t0, t1, t2, ta, tb, tc, tr;

	reg u64 j, bit_idx, idx0, idx1;
	reg u64 temp_views, temp, player, pos_randomness;

	reg u8 t8;
	inline int debug;

	stack u32[3] x_aux, y_aux;

	inline int i, bit_idx;

	t = x[0];
	x_aux[0] = t;
	t = x[1];
	x_aux[1] = t;
	t = x[2];
	x_aux[2] = t;

	t = y[0];
	y_aux[0] = t;
	t = y[1];
	y_aux[1] = t;
	t = y[2];
	y_aux[2] = t;

	c[0] = 0x00000000;
	c[1] = 0x00000000;
	c[2] = 0x00000000;

	pos_randomness = randCount;
	r[0] = (u32)[randomness + (int)pos_randomness];
	
	pos_randomness += 1472;
	r[1] = (u32)[randomness + (int)pos_randomness];
	
	pos_randomness += 1472;
	r[2] = (u32)[randomness + (int)pos_randomness];

	randCount += 4; 

	
	bit_idx = 1;
	for i=0 to 31{

		/* Player 0 */

		t = x[0];
		t1 = c[0];
		t ^= t1;
		t = GETBIT_u32_inline(t,i); 
		a[0] = t;

		t = y[0];
		t ^= t1;
		t = GETBIT_u32_inline(t,i);
		b[0] = t;

		/* Player 1 */

		t = x[1];
		t1 = c[1];
		t ^= t1;
		t = GETBIT_u32_inline(t,i);
		a[1] = t;

		t = y[1];
		t ^= t1;
		t = GETBIT_u32_inline(t,i);
		b[1] = t;

		/* Player 2 */

		t = x[2];
		t1 = c[2];
		t ^= t1;
		t = GETBIT_u32_inline(t,i);
		a[2] = t;

		t = y[2];
		t ^= t1;
		t = GETBIT_u32_inline(t,i);
		b[2] = t;


		/* Player 0 */

		t = a[0];
		t &= b[1];

		ta = a[1];
		tb = b[0];
		ta &= tb;
		t ^= ta;

		ta = a[0];
		tb = b[0];
		ta &= tb;
		t ^= ta;

		tr = r[1];
		tr = GETBIT_u32_inline(tr,i);
		t ^= tr;

		tc = c[0];
		tc = GETBIT_u32_inline(tc,i);
		t ^= tc;

		tr = r[0];
		tr = GETBIT_u32_inline(tr,i);
		t ^= tr;

		tc = c[0];
		tc = SETBIT_c_inline(tc, bit_idx, t);
		c[0] = tc;


		/* Player 1 */

		t = a[1];
		t &= b[2];

		ta = a[2];
		tb = b[1];
		ta &= tb;
		t ^= ta;

		ta = a[1];
		tb = b[1];
		ta &= tb;
		t ^= ta;

		tr = r[2];
		tr = GETBIT_u32_inline(tr,i);
		t ^= tr;

		tc = c[1];
		tc = GETBIT_u32_inline(tc,i);
		t ^= tc;

		tr = r[1];
		tr = GETBIT_u32_inline(tr,i);
		t ^= tr;

		tc = c[1];
		tc = SETBIT_c_inline(tc, bit_idx, t);
		c[1] = tc;
		

		/* Player 2 */

		t = a[2];
		t &= b[0];

		ta = a[0];
		tb = b[2];
		ta &= tb;
		t ^= ta;

		ta = a[2];
		tb = b[2];
		ta &= tb;
		t ^= ta;

		tr = r[0];
		tr = GETBIT_u32_inline(tr,i);
		t ^= tr;

		tc = c[2];
		tc = GETBIT_u32_inline(tc,i);
		t ^= tc;

		tr = r[2];
		tr = GETBIT_u32_inline(tr,i);
		t ^= tr;

		tc = c[2];
		tc = SETBIT_c_inline(tc, bit_idx, t);
		c[2] = tc;

		bit_idx += 1;
	}
	
	
	
	t0 = x_aux[0];
	t0 ^= y_aux[0];
	t0 ^= c[0];
	z[0] = t0;

	temp_views = 64;
	temp_views += countY;
	t0 = c[0];
	(u32)[views + (int)temp_views] = t0;

	
	t0 = x_aux[1];
	t0 ^= y_aux[1];
	t0 ^= c[1];
	z[1] = t0;

	temp_views += 1544;
	t0 = c[1];
	(u32)[views + (int)temp_views] = t0;


	t0 = x_aux[2];
	t0 ^= y_aux[2];
	t0 ^= c[2];
	z[2] = t0;

	temp_views += 1544;
	t0 = c[2];
	(u32)[views + (int)temp_views] = t0;
	

	countY += 4;

	return z, randCount, countY;
}

inline
fn mpc_ADD_K(stack u32[3] x, stack u32 k, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY) -> stack u32[3], reg u64, reg u64 {

	stack u32[3] c, r, aux, aux2;
	reg u64 bit_idx, idx0, idx1, player, pos_randomness, temp_views;

	inline u32 xor_aux;

	stack u32[3] a, b;
	inline int i, bit_idx;
	reg u64 j;
	reg u32 t, t0, t1, t2, ta, tb, tc, tr;

	reg u64 pos_rand, pos_views, idx, temp;

	c[0] = 0;
	c[1] = 0;
	c[2] = 0;

	i = 0;
	
	pos_randomness = randCount;
	r[0] = (u32)[randomness + (int)pos_randomness];
	
	pos_randomness += 1472;
	r[1] = (u32)[randomness + (int)pos_randomness];
	
	pos_randomness += 1472;
	r[2] = (u32)[randomness + (int)pos_randomness];
	
	randCount += 4; 
	
	bit_idx = 1;
	for i=0 to 31{

		/* Player 0 */

		t = x[0];
		t1 = c[0];
		t ^= t1;
		t = GETBIT_u32_inline(t,i);
		a[0] = t;
		
		t = k;
		t1 ^= t;
		t1 = GETBIT_u32_inline(t1,i);
		b[0] = t1;
		
		/* Player 1 */
		
		t = x[1];
		t1 = c[1];
		t ^= t1;
		t = GETBIT_u32_inline(t,i);
		a[1] = t;

		t = k;
		t1 ^= t;
		t1 = GETBIT_u32_inline(t1,i);
		b[1] = t1;
		
		/* Player 2 */
		
		t = x[2];
		t1 = c[2];
		t ^= t1;
		t = GETBIT_u32_inline(t,i);
		a[2] = t;

		t = k;
		t1 ^= t;
		t1 = GETBIT_u32_inline(t1,i);
		b[2] = t1;
		

		/* Player 0 */
		
		t = a[0];
		t &= b[1];

		ta = a[1];
		tb = b[0];
		ta &= tb;
		t ^= ta;

		ta = a[0];
		tb = b[0];
		ta &= tb;
		t ^= ta;

		tr = r[1];
		tr = GETBIT_u32_inline(tr,i);
		t ^= tr;

		tc = c[0];
		tc = GETBIT_u32_inline(tc,i);
		t ^= tc;

		tr = r[0];
		tr = GETBIT_u32_inline(tr,i);
		t ^= tr;

		tc = c[0];
		tc = SETBIT_c_inline(tc, bit_idx, t);
		c[0] = tc;
		

		/* Player 1 */
		
		t = a[1];
		t &= b[2];

		ta = a[2];
		tb = b[1];
		ta &= tb;
		t ^= ta;

		ta = a[1];
		tb = b[1];
		ta &= tb;
		t ^= ta;

		tr = r[2];
		tr = GETBIT_u32_inline(tr,i);
		t ^= tr;

		tc = c[1];
		tc = GETBIT_u32_inline(tc,i);
		t ^= tc;

		tr = r[1];
		tr = GETBIT_u32_inline(tr,i);
		t ^= tr;

		tc = c[1];
		tc = SETBIT_c_inline(tc, bit_idx, t);
		c[1] = tc;
		

		/* Player 2 */
		
		t = a[2];
		t &= b[0];

		ta = a[0];
		tb = b[2];
		ta &= tb;
		t ^= ta;

		ta = a[2];
		tb = b[2];
		ta &= tb;
		t ^= ta;

		tr = r[0];
		tr = GETBIT_u32_inline(tr,i);
		t ^= tr;

		tc = c[2];
		tc = GETBIT_u32_inline(tc,i);
		t ^= tc;

		tr = r[2];
		tr = GETBIT_u32_inline(tr,i);
		t ^= tr;

		tc = c[2];
		tc = SETBIT_c_inline(tc, bit_idx, t);
		c[2] = tc;
		
		bit_idx += 1;	
	}
	
	
	t = x[0]; 
	t ^= c[0];
	t ^= k;
	x[0] = t;

	temp_views = 64;
	temp_views += countY;
	t = c[0];
	(u32)[views + (int)temp_views] = t;


	t = x[1]; 
	t ^= c[1];
	t ^= k;
	x[1] = t;

	temp_views += 1544;
	t = c[1];
	(u32)[views + (int)temp_views] = t;

	
	t = x[2]; 
	t ^= c[2];
	t ^= k;
	x[2] = t;

	temp_views += 1544;
	t = c[2];
	(u32)[views + (int)temp_views] = t;
	

	countY += 4;

	return x, randCount, countY;
}

inline
fn mpc_AND(stack u32[3] x, stack u32[3] y, stack u32[3] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY) -> stack u32[3], reg u64, reg u64 {

	stack u32[3] r, y2;
	reg u64 i, pos_randomness, pos_r, pos_views, temp_pos, temp, temp_views;
	reg u32 t0, t1, t2, t_x, t_y, t_r, t_aux, temp0;
	reg u32[3] aux_y;

	aux_y[0] = y[0];
	aux_y[1] = y[1];
	aux_y[2] = y[2];

	i = 0;

	pos_randomness = randCount;
	r[0] = (u32)[randomness + (int)pos_randomness];
	
	pos_randomness += 1472;
	r[1] = (u32)[randomness + (int)pos_randomness];
	
	pos_randomness += 1472;
	r[2] = (u32)[randomness + (int)pos_randomness];

	randCount += 4; 


	// t[0] = (x[0] & y[1]) ^ (x[1] & y[0]) ^ (x[0] & y[0]) ^ r[0] ^ r[1];
	
	t0 = x[0];
	t_y = aux_y[1];
	t0 &= t_y;

	t1 = x[1];
	t_y = aux_y[0];
	t1 &= t_y; 
	
	t2 = x[0];
	t_y = aux_y[0];
	t2 &= t_y;


	t0 ^= t1;
	t0 ^= t2;
	
	t1 = r[0];
	t0 ^= t1;

	t1 = r[1];
	t0 ^= t1;

	z[0] = t0;


	// t[1] = (x[1] & y[2]) ^ (x[2] & y[1]) ^ (x[1] & y[1]) ^ r[1] ^ r[2] 
	

	t0 = x[1];
	t_y = aux_y[2];
	t0 &= t_y;

	t1 = x[2];
	t_y = aux_y[1];
	t1 &= t_y;
	
	t2 = x[1];
	t_y = aux_y[1];
	t2 &= t_y;


	t0 ^= t1;
	t0 ^= t2;
	
	t1 = r[1];
	t0 ^= t1;

	t1 = r[2];
	t0 ^= t1;
	
	z[1] = t0;


	// t[2] = (x[2] & y[0]) ^ (x[0] & y[2]) ^ (x[2] & y[2]) ^ r[2] ^ r[0] 
	
	t0 = x[2];
	t_y = aux_y[0];
	t0 &= t_y;

	t1 = x[0];
	t_y = aux_y[2];
	t1 &= t_y;
	
	t2 = x[2];
	t_y = aux_y[2];
	t2 &= t_y;


	t0 ^= t1;
	t0 ^= t2;
	
	t1 = r[2];
	t0 ^= t1;

	t1 = r[0];
	t0 ^= t1;
	
	z[2] = t0;
	

	pos_views = 64;
	pos_views += countY;
	temp0 = z[0];
	(u32)[views + (int)pos_views] = temp0;

	pos_views += 1544;  // Sum view structure (1480 + 64)
	temp0 = z[1];
	(u32)[views + (int)pos_views] = temp0;

	pos_views += 1544;
	temp0 = z[2];
	(u32)[views + (int)pos_views] = temp0;

	countY += 4;

	return z, randCount, countY;
}

inline
fn mpc_MAJ(stack u32[3] a, stack u32[3] b, stack u32[3] c, stack u32[3] z, reg u64 randomness, reg u64 randCount, reg u64 views, reg u64 countY) -> stack u32[3], reg u64, reg u64 {
	
	stack u32[3] t0, t1;
	reg u32 t;
	reg u64 temp_views;

	t0 = mpc_xor(a, b, t0);
	t1 = mpc_xor(a, c, t1);

	z, randCount, countY = mpc_AND(t0, t1, z, randomness, randCount, views, countY);

	z = mpc_xor(z, a, z);

	return z, randCount, countY;
}

/*************
*            *
*  MPC Sha1  *
*            *
*************/

inline
fn mpc_SHA1(stack u32[24] results, reg u64 shares, reg u64 numBits, reg u64 randomness, reg u64 localViews, reg u64 countY) -> stack u32[24], reg u64  {


	reg u64 chars;
	reg u64 temp_chunks, temp_shares, temp_views, tmp_shares, temp_w, pos_randomness, pos_w, temp_aux;
	reg u64 randCount, n;
	reg u64 storage_u64;
	reg u32 storage_u32;
	reg u8 storage_u8;

	stack u8[192] chunks; 						// u8 chunks[3][64]
	stack u32[240] w; 							// u32 W[80][3];
	

	reg u64 i, j, j_aux;
	stack u32[3] temp;		 					// uint32_t temp[3]; 
	stack u32[3] t0,t1,t2;						// uint32_t t0[3];

	stack u32[3] a, b, c, d, e, f, w_aux;
	stack u32 k;

	stack u32[5] hA;
	stack u32[3] hHa;
	stack u32[15] hHa_aux;
	stack u8[12] hHa_temp;


	hA[0] = 0x67452301;
	hA[1] = 0xEFCDAB89;
	hA[2] = 0x98BADCFE;
	hA[3] = 0x10325476;
	hA[4] = 0xC3D2E1F0;

	randCount = 0;

	/*  128 >> 3 = 16 bytes; */

	chars = 16;
	
	i = 0;
	while(i<24){
		chunks[u64(int)i] = 0;
		i += 1;
	}
		
	
	temp_shares = 0;
	i = 0;
	while(i < 3){

		temp_chunks = i * 8;

		storage_u64 = (u64)[shares + (int)temp_shares];
		chunks[u64(int)temp_chunks] = storage_u64;

		temp_chunks += 1;
		temp_shares += 8;

		storage_u64 = (u64)[shares + (int)temp_shares];
		chunks[u64(int)temp_chunks] = storage_u64;

		temp_shares += 8;
		
		temp_chunks = i * 64;
		temp_chunks += 16;
		chunks[(int)temp_chunks] = 0x80;

		temp_chunks += 46;  // temp_chunks = i * 64 + 62;

		n = numBits;
		n >>= 8;
		chunks[(int)temp_chunks] = n;

		temp_chunks += 1;

		n = numBits;
		chunks[(int)temp_chunks] = n;

		temp_views = i * 1544;
		temp_chunks = i * 8;

		// Set the pointer to the player's views.x to store the chunks	

		j = 0;
		while(j < 8){

			storage_u64 = chunks[u64 (int)temp_chunks];

			(u64)[localViews + (int)temp_views] = storage_u64;

			temp_views += 8;
			temp_chunks += 1;
			j += 1;
		}
		
		i += 1;
	}

	

	temp_chunks = 0;
	i = 0;
	while(i < 3){

		temp_w = i;
		j = 0;
		while(j < 16){

			storage_u32 = chunks[u32 (int)temp_chunks];

			storage_u32 = #BSWAP_32(storage_u32);

			w[(int)temp_w] = storage_u32;

			temp_chunks += 1;
			temp_w += 3;
			j += 1;
		}
		
		i += 1;
	}
	
	


	j = 48; // R16 começa na posição 48 (16 * 3)
	while(j < 240){

		temp = w_to_temp(temp, w, j);

		n = 1;
		w = mpc_LEFTROTATE_w(temp,n,w,j);

		j += 3;
	}
	

	// uint32_t a[3] = { hA[0],hA[0],hA[0] };
	
	storage_u32 = hA[0];
	a[0] = storage_u32;
	a[1] = storage_u32;
	a[2] = storage_u32;


	// uint32_t b[3] = { hA[1],hA[1],hA[1] };

	storage_u32 = hA[1];
	b[0] = storage_u32;
	b[1] = storage_u32;
	b[2] = storage_u32;


	// uint32_t c[3] = { hA[2],hA[2],hA[2] };

	storage_u32 = hA[2];
	c[0] = storage_u32;
	c[1] = storage_u32;
	c[2] = storage_u32;


	// uint32_t d[3] = { hA[3],hA[3],hA[3] };

	storage_u32 = hA[3];
	d[0] = storage_u32;
	d[1] = storage_u32;
	d[2] = storage_u32;


	// uint32_t e[3] = { hA[4],hA[4],hA[4] };

	storage_u32 = hA[4];
	e[0] = storage_u32;
	e[1] = storage_u32;
	e[2] = storage_u32;

	
	j = 0;
	while(j < 80){
		
		if(j <= 19){

			f = mpc_xor(c,d,f);
			
			f, randCount, countY = mpc_AND(b, f, f, randomness, randCount, localViews, countY);

			f = mpc_xor(d,f,f);

			k = 0x5A827999;
		}
		else{
			if( j <= 39) {

				f = mpc_xor(b,c,f);

				f = mpc_xor(d,f,f);

				k = 0x6ED9EBA1;
			}
			else {
				
				if( j <= 59) {

					f, randCount, countY = mpc_MAJ(b,c,d,f,randomness, randCount, localViews, countY);

					k = 0x8F1BBCDC;
				}
				else {
					f = mpc_xor(b,c,f);

					f = mpc_xor(d,f,f);

					k = 0xCA62C1D6;
				}		
			}
		}
		
		temp = mpc_LEFTROTATE_5(a,temp);
		
		temp, randCount, countY = mpc_ADD(f, temp, temp, randomness, randCount, localViews, countY);
	
		temp, randCount, countY = mpc_ADD(e, temp, temp, randomness, randCount, localViews, countY);

		temp, randCount, countY = mpc_ADD_K(temp, k, randomness, randCount, localViews, countY);

		n = j * 3;
		storage_u32 = w[(int)n];
		w_aux[0] = storage_u32;
		n += 1;
		storage_u32 = w[(int)n];
		w_aux[1] = storage_u32;
		n += 1;
		storage_u32 = w[(int)n];
		w_aux[2] = storage_u32;

		temp, randCount, countY = mpc_ADD(w_aux, temp, temp, randomness, randCount, localViews, countY);
		
		
		storage_u32 = d[0];
		e[0] = storage_u32;

		storage_u32 = d[1];
		e[1] = storage_u32;

		storage_u32 = d[2];
		e[2] = storage_u32;


		storage_u32 = c[0];
		d[0] = storage_u32;

		storage_u32 = c[1];
		d[1] = storage_u32;

		storage_u32 = c[2];
		d[2] = storage_u32;

		
		c = mpc_LEFTROTATE_30(b, c);
			

		storage_u32 = a[0];
		b[0] = storage_u32;

		storage_u32 = a[1];
		b[1] = storage_u32;

		storage_u32 = a[2];
		b[2] = storage_u32;


		storage_u32 = temp[0];
		a[0] = storage_u32;

		storage_u32 = temp[1];
		a[1] = storage_u32;

		storage_u32 = temp[2];
		a[2] = storage_u32;
		
		j += 1;
	}
	
	
	
	
	storage_u32 = hA[0];
	hHa[0] = storage_u32;
	hHa[1] = storage_u32;
	hHa[2] = storage_u32;

	temp, randCount, countY = mpc_ADD(hHa, a, hHa, randomness, randCount, localViews, countY);

	storage_u32 = temp[0];
	hHa_aux[0] = storage_u32;
	storage_u32 = temp[1];
	hHa_aux[1] = storage_u32;
	storage_u32 = temp[2];
	hHa_aux[2] = storage_u32;


	storage_u32 = hA[1];
	hHa[0] = storage_u32;
	hHa[1] = storage_u32;
	hHa[2] = storage_u32;

	temp, randCount, countY = mpc_ADD(hHa, b, hHa, randomness, randCount, localViews, countY);

	storage_u32 = temp[0];
	hHa_aux[3] = storage_u32;
	storage_u32 = temp[1];
	hHa_aux[4] = storage_u32;
	storage_u32 = temp[2];
	hHa_aux[5] = storage_u32;


	storage_u32 = hA[2];
	hHa[0] = storage_u32;
	hHa[1] = storage_u32;
	hHa[2] = storage_u32;

	temp, randCount, countY = mpc_ADD(hHa, c, hHa, randomness, randCount, localViews, countY);

	storage_u32 = temp[0];
	hHa_aux[6] = storage_u32;
	storage_u32 = temp[1];
	hHa_aux[7] = storage_u32;
	storage_u32 = temp[2];
	hHa_aux[8] = storage_u32;


	storage_u32 = hA[3];
	hHa[0] = storage_u32;
	hHa[1] = storage_u32;
	hHa[2] = storage_u32;

	temp, randCount, countY = mpc_ADD(hHa, d, hHa, randomness, randCount, localViews, countY);

	storage_u32 = temp[0];
	hHa_aux[9] = storage_u32;
	storage_u32 = temp[1];
	hHa_aux[10] = storage_u32;
	storage_u32 = temp[2];
	hHa_aux[11] = storage_u32;


	storage_u32 = hA[4];
	hHa[0] = storage_u32;
	hHa[1] = storage_u32;
	hHa[2] = storage_u32;

	temp, randCount, countY = mpc_ADD(hHa, e, hHa, randomness, randCount, localViews, countY);

	storage_u32 = temp[0];
	hHa_aux[12] = storage_u32;
	storage_u32 = temp[1];
	hHa_aux[13] = storage_u32;
	storage_u32 = temp[2];
	hHa_aux[14] = storage_u32;


	j = 0;
	while(j < 5){

		j_aux = j;
		j_aux *= 3;

		storage_u32 = hHa_aux[(int)j_aux];
		j_aux += 1;
		hHa[0] = storage_u32;
		storage_u32 = hHa_aux[(int)j_aux];
		hHa[1] = storage_u32;
		j_aux += 1;
		storage_u32 = hHa_aux[(int)j_aux];
		hHa[2] = storage_u32;


		storage_u32 = hHa[0];
		results[(int)j] = storage_u32;
		storage_u32 = hHa[1];
		results[(int)j + 8] = storage_u32;
		storage_u32 = hHa[2];
		results[(int)j + 16] = storage_u32;

		j += 1;
	}
	

	return results, countY;
}

/***********************
*                      *
*  Commits & mpc_Sha1  *
*                      *
***********************/


export
fn commit(reg u64 as, reg u64 shares, reg u64 randomness, reg u64 rs, reg u64 localViews) {
	
	stack u32[24] hashes;
	
	stack u32[5] result1, result2, result3;

	reg u64 numBits, j, temp_views, temp, a_temp, countY, temp_aux, pos, temporary;
	reg u32 var32, storage_u32;
	reg u64 var64;

	reg u8 t;

	countY = 0;

	numBits = 128;

	hashes, countY = mpc_SHA1(hashes, shares, numBits, randomness, localViews, countY);
	
	// Store hashes on views and a.yp

	
	temp_views = 64;
	temp_views += countY;

	var64 = hashes[u64 (int) 0];
	(u64)[localViews + (int)temp_views] = var64;
	(u64)[as + 0] = var64;

	temp_views += 8;

	var64 = hashes[u64 (int) 1];
	(u64)[localViews + (int)temp_views] = var64;
	(u64)[as + 8] = var64;

	temp_views += 8;

	var32 = hashes[ (int) 4];
	(u32)[localViews + (int)temp_views] = var32;
	(u32)[as + 16] = var32;



	temp_views = 1544;
	temp_views += 64;
	temp_views += countY;

	var64 = hashes[u64 (int) 4];
	(u64)[localViews + (int)temp_views] = var64;
	(u64)[as + 32] = var64;

	temp_views += 8;

	var64 = hashes[u64 (int) 5];
	(u64)[localViews + (int)temp_views] = var64;
	(u64)[as + 40] = var64;

	temp_views += 8;

	var32 = hashes[(int) 12];
	(u32)[localViews + (int)temp_views] = var32;
	(u32)[as + 48] = var32;

	temp_views = 3088;
	temp_views += 64;
	temp_views += countY;

	var64 = hashes[u64 (int) 8];
	(u64)[localViews + (int)temp_views] = var64;
	(u64)[as + 64] = var64;

	temp_views += 8;

	var64 = hashes[u64 (int) 9];
	(u64)[localViews + (int)temp_views] = var64;
	(u64)[as + 72] = var64;

	temp_views += 8;

	var32 = hashes[(int) 20];
	(u32)[localViews + (int)temp_views] = var32;
	(u32)[as + 80] = var32;
}













































inline
fn GETBIT_u32_v2(reg u8 x, reg u64 bit_idx) -> reg u8 {

	while(bit_idx > 0){
		x = x >> 1;
		bit_idx -= 1;
	}

	x &= 0x01; 
	
	return x;	
}

inline
fn GETBIT_EXTENDED(stack u32[8] aux, reg u64 bit_idx) -> reg u8 {

	reg u8 selectedBit;
	reg u64 bit_aux;
	reg u64 byte_aux;
	
	bit_aux = bit_idx;
	byte_aux = 0;

	while(bit_aux >= 8){
		byte_aux += 1;
		bit_aux -= 8;
	}

	selectedBit = aux[u8 (int)byte_aux];

	selectedBit = GETBIT_u32_v2(selectedBit, bit_aux);

	return  selectedBit;	
}



fn ROTLEFT(reg u32 a, reg u8 b) -> reg u32{

	a = ((a << b) | (a >> (32 - b)));
	return a;
} 

fn ROTRIGHT(reg u32 a, reg u8 b) -> stack u32 {

	a = ((a >> b) | (a << (32 - b)));
	return a;
}

fn ROTRIGHT_2(reg u32 a) -> stack u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 2;
	a_aux <<= 30;

	a |= a_aux;

	return a;
}

fn ROTRIGHT_13(reg u32 a) -> stack u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 13;
	a_aux <<= 19;

	a |= a_aux;

	return a;
}

fn ROTRIGHT_22(reg u32 a) -> stack u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 22;
	a_aux <<= 10;

	a |= a_aux;

	return a;
}

fn ROTRIGHT_6(reg u32 a) -> stack u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 6;
	a_aux <<= 26;

	a |= a_aux;

	return a;
}

fn ROTRIGHT_11(reg u32 a) -> stack u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 11;
	a_aux <<= 21;

	a |= a_aux;

	return a;
}

fn ROTRIGHT_25(reg u32 a) -> stack u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 25;
	a_aux <<= 7;

	a |= a_aux;

	return a;
}


inline
fn EP0(stack u32 x) -> reg u32{

    reg u32 res, res1, res2;
    stack u32 r,r1,r2;


    res = x;
    res = ROTRIGHT_2(res);
    r = res;

    res1 = x;
    res1 = ROTRIGHT_13(res1);
    r1 = res1;


    res2 = x;
    res2 = ROTRIGHT_22(res2);
    r2 = res2;
    
    res = r;
    res1 = r1;
    res ^= res1;
    res2 = r2;
    res ^= res2;

    return res;
}

inline
fn EP1(stack u32 x) -> reg u32{

    reg u32 res, res1, res2;

    res = x;
    res = ROTRIGHT_6(res);

    res1 = x;
    res1 = ROTRIGHT_11(res1);
    
    res2 = x;
    res2 = ROTRIGHT_25(res2);

    res ^= res1;
    res ^= res2;

    return res;
} 


fn ROTRIGHT_7(reg u32 a) -> reg u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 7;
	a_aux <<= 25;

	a ^= a_aux;

	return a;
}

fn ROTRIGHT_18(reg u32 a) -> reg u32 {

	reg u32 a_aux;

	a_aux = a;

	a >>= 18;
	a_aux <<= 14;

	a ^= a_aux;

	return a;
}

fn ROTRIGHT_17(reg u32 a) -> reg u32 {

	reg u32 a1, a2;

	a1 = a;
	a1 >>= 17;

    a2 = a;
	a2 <<= 15;

	a1 |= a2;

	return a1;
}

fn ROTRIGHT_19(reg u32 a) -> reg u32 {

	reg u32 a1, a2;

	a1 = a;
	a1 >>= 19;

    a2 = a;
	a2 <<= 13;

	a1 |= a2;

	return a1;
}
inline
fn SIG0(reg u32 x) -> reg u32 {

    reg u32 x0, x1;

    x0 = x;
    x0 = ROTRIGHT_7(x0);

    x1 = x;
    x1 = ROTRIGHT_18(x1);

    x >>= 3;

    x0 ^= x1;
    x0 ^= x;

    return x0;
}

inline
fn SIG1(reg u32 x) -> reg u32{
    reg u32 x0, x1, x2;

    x0 = x;
    x0 = ROTRIGHT_17(x0);
    
    x1 = x;
    x1 = ROTRIGHT_19(x1);

    x2 = x;
    x2 = (x2 >> 10); 

    x0 ^= x1;
    x0 ^= x2;

    return x0;
}

inline
fn CH(stack u32 x, stack u32 y, stack u32 z) -> reg u32{
    
    reg u32 t0, t1;

    t0 = x;
    t0 &= y;

    t1 = x;
    t1 ^= 0xFFFFFFFF;
    t1 &= z;

    t0 ^= t1;

    return t0;
}

inline
fn MAJ(stack u32 x, stack u32 y, stack u32 z) -> reg u32{

    reg u32 t0, t1, tx, ty, tz;

    t0 = x;
    ty = y;
    t0 = t0 & ty;

    t1 = x;
    tz = z;
    t1 &= tz;
    t0 ^= t1;

    t1 = y;
    tz = z;
    t1 &= tz;
    t0 ^= t1;

    return t0;
}

inline
fn initializeK(stack u32[64] k) -> stack u32[64]{
    k[0] = 0x428a2f98;
    k[1] = 0x71374491;
    k[2] = 0xb5c0fbcf;
    k[3] = 0xe9b5dba5;
    k[4] = 0x3956c25b;
    k[5] = 0x59f111f1;
    k[6] = 0x923f82a4;
    k[7] = 0xab1c5ed5;
    k[8] = 0xd807aa98;
    k[9] = 0x12835b01;
    k[10] = 0x243185be;
    k[11] = 0x550c7dc3;
    k[12] = 0x72be5d74;
    k[13] = 0x80deb1fe;
    k[14] = 0x9bdc06a7;
    k[15] = 0xc19bf174;
    k[16] = 0xe49b69c1;
    k[17] = 0xefbe4786;
    k[18] = 0x0fc19dc6;
    k[19] = 0x240ca1cc;
    k[20] = 0x2de92c6f;
    k[21] = 0x4a7484aa;
    k[22] = 0x5cb0a9dc;
    k[23] = 0x76f988da;
    k[24] = 0x983e5152;
    k[25] = 0xa831c66d;
    k[26] = 0xb00327c8;
    k[27] = 0xbf597fc7;
    k[28] = 0xc6e00bf3;
    k[29] = 0xd5a79147;
    k[30] = 0x06ca6351;
    k[31] = 0x14292967;
    k[32] = 0x27b70a85;
    k[33] = 0x2e1b2138;
    k[34] = 0x4d2c6dfc;
    k[35] = 0x53380d13;
    k[36] = 0x650a7354;
    k[37] = 0x766a0abb;
    k[38] = 0x81c2c92e;
    k[39] = 0x92722c85;
    k[40] = 0xa2bfe8a1;
    k[41] = 0xa81a664b;
    k[42] = 0xc24b8b70;
    k[43] = 0xc76c51a3;
    k[44] = 0xd192e819;
    k[45] = 0xd6990624;
    k[46] = 0xf40e3585;
    k[47] = 0x106aa070;
    k[48] = 0x19a4c116;
    k[49] = 0x1e376c08;
    k[50] = 0x2748774c;
    k[51] = 0x34b0bcb5;
    k[52] = 0x391c0cb3;
    k[53] = 0x4ed8aa4a;
    k[54] = 0x5b9cca4f;
    k[55] = 0x682e6ff3;
    k[56] = 0x748f82ee;
    k[57] = 0x78a5636f;
    k[58] = 0x84c87814;
    k[59] = 0x8cc70208;
    k[60] = 0x90befffa;
    k[61] = 0xa4506ceb;
    k[62] = 0xbef9a3f7;
    k[63] = 0xc67178f2;

    return k;
}

inline
fn dbl_int_add(stack u32[2] ctx_bitlen, reg u64 c) -> stack u32[2] {

	reg u32 a, b;
	
	a = ctx_bitlen[0];
	
	b = 0xffffffff;
	b -= c;

	if(a > b){
		a = ctx_bitlen[1];
		a += 1; 
		ctx_bitlen[1] = a;
	} else {
		a += c;
		ctx_bitlen[0] = a;
	}

	return ctx_bitlen;
}

inline
fn compute_t1(stack u32 e, stack u32 f, stack u32 g, stack u32 h, stack u32[64] k, stack u32[64] m, reg u64 i) -> reg u32{

	reg u32 t, t1;

	t1 = h;
		
	t = EP1(e);
	t1 += t;

	t = CH(e,f,g);
	t1 += t;

	t = k[(int)i];
	t1 += t;
	
	t = m[(int)i];
	t1 += t;

	return t1;
}

inline
fn compute_t2(stack u32 a, stack u32 b, stack u32 c) -> reg u32{
	
	reg u32 t, t2;


	t2 = EP0(a);
	
	t = MAJ(a, b, c); 
	t2 += t;
	

	return t2;
}

inline
fn sha256_transform(stack u32[8] ctx_state, stack u8[64] ctx_data) -> stack u32[8], stack u8[64]
{
    stack u32 a, b, c, d, e, f, g, h;
    reg u32 t0, t1, t2, temp;

    stack u32[64] m;

    reg u32 sig0, sig1;

    reg u64 i, j,z;

    inline int idx;

    reg u8 t8;

    stack u32[64] k;
    k = initializeK(k);
    

    i = 0;
    z = 0;
    while(i < 16){

        t0 = ctx_data[u32 (int)i];

        t0 = #BSWAP_32(t0);

        m[(int)i] = t0;

        i += 1;
    }
    

    /* IGUAL */
    z = 0;
    while(i < 64){

        j = i;
        j -= 2;
        temp = m[(int)j];
        temp = SIG1(temp);
        m[(int)i] = temp;

        j = i;
        j -= 7;
        temp =  m[(int)j];
        m[(int)i] += temp;

        j = i;
        j -= 15;
        temp = m[(int)j];
        temp = SIG0(temp);
        m[(int)i] += temp;

        j = i;
        j -= 16;
        temp =  m[(int)j];
        m[(int)i] += temp;
        
        i += 1;
    } 
    

    temp = ctx_state[0];
    a = temp;
    temp = ctx_state[1];
    b = temp;
    temp = ctx_state[2];
    c = temp;
    temp = ctx_state[3];
    d = temp;
    temp = ctx_state[4];
    e = temp;
    temp = ctx_state[5];
    f = temp;
    temp = ctx_state[6];
    g = temp;
    temp = ctx_state[7];
    h = temp;

    
    i = 0;
    j = 0;
    while(i < 64){

    	t1 = compute_t1(e, f, g, h, k, m, i);
    	t2 = compute_t2(a,b,c);
        
        t0 = g;
        h = t0;

        t0 = f;
        g = t0;

        t0 = e;
        f = t0;

        t0 = d;
        t0 += t1;
        e = t0;


        t0 = c;
        d = t0;

        t0 = b;
        c = t0;

        t0 = a;
        b = t0;

        t0 = t1;
        t0 += t2;
        a = t0;

        j += 4;
        i += 1;
    }

    temp = ctx_state[0];
    temp += a;
    ctx_state[0] = temp;

    temp = ctx_state[1];
    temp += b;
    ctx_state[1] = temp;

    temp = ctx_state[2];
    temp += c;
    ctx_state[2] = temp;

    temp = ctx_state[3];
    temp += d;
    ctx_state[3] = temp;

    temp = ctx_state[4];
    temp += e;
    ctx_state[4] = temp;

    temp = ctx_state[5];
    temp += f;
    ctx_state[5] = temp;

    temp = ctx_state[6];
    temp += g;
    ctx_state[6] = temp;

    temp = ctx_state[7];
    temp += h;
    ctx_state[7] = temp;
    
    return ctx_state, ctx_data;
}


inline
fn sha256_update(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, reg u64 data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u64 t;

    temp = ctx_datalen;
    temp >>= 3;

    i = 0;
    while(i < len){
        t = (u64)[data + (int)i];
        
        ctx_data[u64 (int)temp] = t;
        temp += 1;
        
        if(temp == 8){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,temp);
            temp = 0;
        }

        i += 8;
    }

    temp <<= 3;
    ctx_datalen = temp;

    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}

inline
fn sha256_update2(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, reg u64 data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u32 t;

    temp = ctx_datalen;

    temp >>= 2;

    i = 0;
    while(i < len){
        t = (u32)[data + (int)i];
        
        ctx_data[u32 (int)temp] = t;
        temp += 1;
        
        if(temp == 16){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen, temp);
            temp = 0;
        }

        i += 4;
    }

    temp <<= 2;
    ctx_datalen = temp;

    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}

inline
fn sha256_final(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, reg u64 finalHash)
{
    reg u64 i, temp;
    reg u32 value;

    // Pad whatever data is left in the buffer.
    

    i = ctx_datalen;

    if (i < 56) {
        ctx_data[(int)i] = 0x80;
        i += 1;
        while (i < 56){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
    }    
    else {
        ctx_data[(int)i] = 0x80;
        i += 1;
        while (i < 64){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
        ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);

        i = 0;
        while(i < 56){
        	ctx_data[(int)i] = 0x00;
        	i += 1;
        }
    }


    // Append to the padding the total message's length in bits and transform.
    

    temp = ctx_datalen;
    temp *= 8;
    ctx_bitlen = dbl_int_add(ctx_bitlen, temp);

    value = ctx_bitlen[0];
    value = #BSWAP_32(value);
    ctx_data[u32 15] = value;

    value = ctx_bitlen[1];
    value = #BSWAP_32(value);
    ctx_data[u32 14] = value;
	
	ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);

	temp = 0;    
    i = 0;
    while(i < 8){

    	value = ctx_state[(int)i];

    	value = #BSWAP_32(value);

    	(u32)[finalHash + (int)temp] = value;

    	temp += 4;
    	i += 1;
    } 
}


/*****************
*                *
*   H - SHA256   *
*                *
*****************/


export
fn H(reg u64 keys, reg u64 localViews, reg u64 rs, reg u64 a) {
	

	stack u64 ctx_datalen;
	stack u32[2] ctx_bitlen;
	stack u32[8] ctx_state;
    stack u8[64] ctx_data;

    reg u64 aux;

    ctx_datalen = 0;
    ctx_bitlen[0] = 0;
    ctx_bitlen[1] = 0;
    ctx_state[0] = 0x6a09e667;
    ctx_state[1] = 0xbb67ae85;
    ctx_state[2] = 0x3c6ef372;
    ctx_state[3] = 0xa54ff53a;
    ctx_state[4] = 0x510e527f;
    ctx_state[5] = 0x9b05688c;
    ctx_state[6] = 0x1f83d9ab;
    ctx_state[7] = 0x5be0cd19;


    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, keys, 16);

    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, localViews, 1544);
    
    ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update2(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, rs, 4);
    
    sha256_final(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, a);
}

inline
fn sha256_updateH3(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, reg u64 data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u32 t;

    temp = ctx_datalen;
    temp >>= 2;
    i = 0;
    while(i < len){
        t = (u32)[data + (int)i];
        
        ctx_data[u32 (int)temp] = t;
        temp += 1;
        
        if(temp == 16){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen,temp);
            temp = 0;
        }

        i += 4;
    }

    temp <<= 2;
    ctx_datalen = temp;


    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}

inline
fn sha256_update3(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u32[8] data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u32 t;

    temp = ctx_datalen;

    temp >>= 2;

    i = 0;
    while(i < len){
        t = data[(int)i];
        
        ctx_data[u32 (int)temp] = t;
        temp += 1;
        
        if(temp == 16){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen, temp);
            temp = 0;
        }

        i += 1;
    }

    temp <<= 2;
    ctx_datalen = temp;

    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}
inline
fn sha256_update4(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, reg u64 data, inline int len) -> stack u32[8], stack u8[64], stack u64, stack u32[2]
{
    reg u64 i, temp;
    reg u64 t;
    reg u32 t32;


    temp = ctx_datalen;
    temp >>= 2;

    t32 = (u32)[data + 0];
        
    ctx_data[u32 (int)temp] = t32;
    temp += 1;

    temp <<= 2;
    temp >>= 3;
    
    i = 4;
    while(i < len){
        t = (u64)[data + (int)i];
        
        ctx_data[u64 (int)temp] = t;
        temp += 1;
        
        if(temp == 8){
            ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);
            temp = 512;
            ctx_bitlen = dbl_int_add(ctx_bitlen, temp);
            temp = 0;
        }

        i += 8;
    }

    // Becouse of the adjustments we did to copy the first 4 bytes of data to ctx_data, our data is no longer of multiple of 8 but of 4; To fix this we need to copy the last 4 bytes after iteration!

    temp <<= 3;
    temp >>= 2;

    t32 = (u32)[data + 26108];
        
    ctx_data[u32 (int)temp] = t32;
    temp += 1;
    temp <<= 2;
    ctx_datalen = temp;

    return ctx_state, ctx_data, ctx_datalen, ctx_bitlen;
}


inline
fn sha256_finalH3(stack u32[8] ctx_state, stack u8[64] ctx_data, stack u64 ctx_datalen, stack u32[2] ctx_bitlen, stack u32[8] hash) -> stack u32[8], stack u8[64], stack u32[2], stack u32[8]
{
    reg u64 i, temp;
    reg u64 j;
    reg u32 t, value, stored_value;


    // Pad whatever data is left in the buffer.

    i = ctx_datalen;

    if (i < 56) {
        ctx_data[(int)i] = 0x80;
        i += 1;
        while (i < 56){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
    }    
    else {
        ctx_data[(int)i] = 0x80;
        i += 1;
        while (i < 64){
            ctx_data[(int)i] = 0x00;
            i += 1;
        }
        ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);

        i = 0;
        while(i < 56){
        	ctx_data[(int)i] = 0x00;
        	i += 1;
        }
    }


    // Append to the padding the total message's length in bits and transform.
    

    temp = ctx_datalen;
    temp *= 8;
    ctx_bitlen = dbl_int_add(ctx_bitlen, temp);


    value = ctx_bitlen[0];
    value = #BSWAP_32(value);
    ctx_data[u32 15] = value;

    value = ctx_bitlen[1];
    value = #BSWAP_32(value);
    ctx_data[u32 14] = value;
	
	ctx_state, ctx_data = sha256_transform(ctx_state, ctx_data);


    // Since this implementation uses little endian byte ordering and SHA uses big endian,
    // reverse all the bytes when copying the final state to the output hash.
    
    i = 0;
    while(i < 8){

    	value = ctx_state[(int)i];

    	value = #BSWAP_32(value);

    	hash[(int)i] = value;

        i += 1;
    }
    

    return ctx_state, ctx_data, ctx_bitlen, hash;
}

/*****************
*                *
*       H3       *
*                *
*****************/


export
fn H3 (reg u64 finalHash, reg u64 as, reg u64 es) {

	stack u32[8] hash; // unsigned char hash[SHA256_DIGEST_LENGTH];
	
	stack u8[64] ctx_data;
	stack u64 ctx_datalen;
	stack u32[2] ctx_bitlen;
	stack u32[8] ctx_state;

	reg u64 i, j, z, es_aux, temp;
	reg u64 bitTracker;
	reg u8 b1, b2;

	reg u64 len;

	reg u32 t;

	reg u64 counter;

	ctx_datalen = 0;
    ctx_bitlen[0] = 0;
    ctx_bitlen[1] = 0;
    ctx_state[0] = 0x6a09e667;
    ctx_state[1] = 0xbb67ae85;
    ctx_state[2] = 0x3c6ef372;
    ctx_state[3] = 0xa54ff53a;
    ctx_state[4] = 0x510e527f;
    ctx_state[5] = 0x9b05688c;
    ctx_state[6] = 0x1f83d9ab;
    ctx_state[7] = 0x5be0cd19;

    i = 0;
    while(i<64){
    	ctx_data[(int)i] = 0;
    	i += 1;
    }
    

	ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_updateH3(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, finalHash, 20);

	// Here we set the lengt to length(as) - 8 because we need to make performance adjustments 
	// (copy u64 instead of u32)

	ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update4(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, as, 26108);

	ctx_state, ctx_data, ctx_bitlen, hash = sha256_finalH3(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash);

	t = ctx_bitlen[0];
	(u32)[es + 0] = t;
	t = ctx_bitlen[1];
	(u32)[es + 4] = t;

	i = 104;
	j = 0;
	while(j < 8){
		t = hash[(int)j];
		(u32)[es + (int)i] = t; 
		j += 1;
		i += 4;
	}

		
	//Pick bits from hash
	i = 0;
	bitTracker = 0;
	len = 136;				// Nr de rondas
	len *= 8;

	
	while(i < len) {

		if(bitTracker >= 256) { //Generate new hash

			ctx_datalen = 0;
            ctx_bitlen[0] = 0;
            ctx_bitlen[1] = 0;
            ctx_state[0] = 0x6a09e667;
            ctx_state[1] = 0xbb67ae85;
            ctx_state[2] = 0x3c6ef372;
            ctx_state[3] = 0xa54ff53a;
            ctx_state[4] = 0x510e527f;
            ctx_state[5] = 0x9b05688c;
            ctx_state[6] = 0x1f83d9ab;
            ctx_state[7] = 0x5be0cd19;


			ctx_state, ctx_data, ctx_datalen, ctx_bitlen = sha256_update3(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash, 8);
			ctx_state, ctx_data, ctx_bitlen, hash = sha256_finalH3(ctx_state, ctx_data, ctx_datalen, ctx_bitlen, hash);

			bitTracker = 0;
		}
		
		b1 = GETBIT_EXTENDED(hash, bitTracker);
		bitTracker += 1;
		b2 = GETBIT_EXTENDED(hash, bitTracker);
		
		if(b1 == 0) {
			if(b2 == 0) {
				j = 0;
				(u64)[es + (int)i] = j;
				i += 8;
			} else {
				j = 1;
				(u64)[es + (int)i] = j;
				i += 8;
			}
		} 
		else {
			if(b2 == 0) {
				j = 2;
				(u64)[es + (int)i] = j;
				i += 8;
			}
		}

		bitTracker += 1; 				// alredy added 1 priviously!!
	}
	
	
}

/*****************
*                *
*     Prove      *
*                *
*****************/


export
fn prove(reg u64 zs, reg u64 es, reg u64 keys, reg u64 rs, reg u64 localViews) {
	
	reg u64 j, player0, player1;
	reg u64 temp_zs, temp_keys, temp_views, temp_rs;
	reg u64 t64;
	reg u32 t32;

	temp_zs = 0;

	player0 = (u64)[es + 0];
	player1 = player0;
	player1 += 1;

	if(player1 == 3){
		player1 = 0;
	}


	/* Copy both players keys */


	temp_keys = player0 * 16;

	t64 = (u64)[keys + (int)temp_keys];
	(u64)[zs + (int)temp_zs] = t64;

	temp_zs += 8;
	temp_keys += 8;

	t64 = (u64)[keys + (int)temp_keys];
	(u64)[zs + (int)temp_zs] = t64;

	temp_zs += 8;
	temp_keys += 8;


	temp_keys = player1 * 16;

	t64 = (u64)[keys + (int)temp_keys];
	(u64)[zs + (int)temp_zs] = t64;

	temp_zs += 8;
	temp_keys += 8;

	t64 = (u64)[keys + (int)temp_keys];
	(u64)[zs + (int)temp_zs] = t64;

	
	/* Copy player 0 view */


	temp_views = player0 * 1544;

	j = 0;
	while(j < 8){
		
		t64 = (u64)[localViews + (int)temp_views];
		(u64)[zs + (int)temp_zs] = t64;

		temp_views += 8;
		temp_zs += 8;
		j += 1;
	}

	j = 0;
	while(j < 185){

		t64 = (u64)[localViews + (int)temp_views];
		(u64)[zs + (int)temp_zs] = t64;

		temp_zs += 8;
		temp_views += 8;
		j += 1;
	}

	/* Copy player 1 view */

	temp_views = player1 * 1544;

	j = 0;
	while(j < 8){

		t64 = (u64)[localViews + (int)temp_views];
		(u64)[zs + (int)temp_zs] = t64;

		temp_views += 8;
		temp_zs += 8;
		j += 1;
	}

	j = 0;
	while(j < 185){

		t64 = (u64)[localViews + (int)temp_views];
		(u64)[zs + (int)temp_zs] = t64;

		temp_views += 8;
		temp_zs += 8;
		j += 1;
	}


	temp_rs = 4 * player0;


	t32 = (u32)[rs + (int)temp_rs];
	(u32)[zs + (int)temp_zs] = t32;

	temp_zs += 4;


	temp_rs = 4 * player1;
	
	t32 = (u32)[rs + (int)temp_rs];
	(u32)[zs + (int)temp_zs] = t32;

}
		

