/*
 ============================================================================
 Name        : MPC_SHA256_VERIFIER.c
 Author      : Sobuno
 Version     : 0.1
 Description : Verifies a proof for SHA-1 generated by MPC_SHA1.c
 ============================================================================
 */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "shared.h"


void printbits(uint32_t n) {
	if (n) {
		printbits(n >> 1);
		printf("%d", n & 1);
	}

}



int main(void) {
	setbuf(stdout, NULL);
	init_EVP();
	openmp_thread_setup();
	
	printf("Iterations of SHA: %d\n", NUM_ROUNDS);

	int average_total_time = 0;
	clock_t begin;
	
	a as[NUM_ROUNDS];
	z zs[NUM_ROUNDS];
	FILE *file;

	char outputFile[3*sizeof(int) + 8];
	sprintf(outputFile, "out%i.bin", NUM_ROUNDS);
	file = fopen(outputFile, "rb");
	if (!file) {
		printf("Unable to open file!");
	}
	fread(&as, sizeof(a), NUM_ROUNDS, file);
	fread(&zs, sizeof(z), NUM_ROUNDS, file);
	fclose(file);

	clock_t beginS, beginH3;
	clock_t deltaS, deltaH3;

	int totalV = 0, totalH, totalH3 = 0;

	uint32_t y[8];
	beginS = clock();
	reconstruct(as[0].yp[0],as[0].yp[1],as[0].yp[2],y);
	deltaS += clock() - beginS;

	int totalZRounds = 100;

	for(int z=0;z<totalZRounds;z++){

		int es[NUM_ROUNDS];

		beginH3 = clock();
		H3(y, as, NUM_ROUNDS, es);
		deltaH3 = clock() - beginH3;
		totalH3 += deltaH3;
 
		#pragma omp parallel for
		for(int i = 0; i<NUM_ROUNDS; i++) {
			//printf("-*- round %d -*-\n",i );

			//printf("\ne[%d] = %d\n",i,es[i]);

			int verifyResult = verify(as[i], es[i], zs[i], &totalH, &totalV);
			if (verifyResult != 0) {
				printf("Not Verified %d\n", i);
			}
		}
	}

	printf("\n\nAverage Total Time: \n\n - Shares_xor(): %ju\n - verify():     %ju\n  - H():         %ju\n  - H3():        %ju\n\n", deltaS, totalV/totalZRounds, totalH/totalZRounds, totalH3/totalZRounds);


	printf("Total Time: %ju\n\n", deltaS + (totalV + totalH + totalH3)/totalZRounds);

	openmp_thread_cleanup();
	cleanup_EVP();
	return EXIT_SUCCESS;
}